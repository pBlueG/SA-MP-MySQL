[#unordered_node_map]
== Class template unordered_node_map

:idprefix: unordered_node_map_

`boost::unordered_node_map` â€” A node-based, open-addressing unordered associative container that associates unique keys with another value.

`boost::unordered_node_map` uses an open-addressing layout like `boost::unordered_flat_map`, but,
being node-based, it provides pointer/iterator stability and node handling functionalities.
Its performance lies between those of `boost::unordered_map` and `boost::unordered_flat_map`.

As a result of its using open addressing, the interface of `boost::unordered_node_map` deviates in
a number of aspects from that of `boost::unordered_map`/`std::unordered_map`: 

  - `begin()` is not constant-time.
  - `erase(iterator)` returns `void`.
  - There is no API for bucket handling (except `bucket_count`).
  - The maximum load factor of the container is managed internally and can't be set by the user.

Other than this, `boost::unordered_node_map` is mostly a drop-in replacement of standard
unordered associative containers.

=== Synopsis

[listing,subs="+macros,+quotes"]
-----
// #include <boost/unordered/unordered_node_map.hpp>

namespace boost {
  template<class Key,
           class T,
           class Hash = boost::hash<Key>,
           class Pred = std::equal_to<Key>,
           class Allocator = std::allocator<std::pair<const Key, T>>>
  class unordered_node_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair<const Key, T>;
    using init_type            = std::pair<
                                   typename std::remove_const<Key>::type,
                                   typename std::remove_const<T>::type
                                 >;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits<Allocator>::pointer;
    using const_pointer        = typename std::allocator_traits<Allocator>::const_pointer;
    using reference            = value_type&;
    using const_reference      = const value_type&;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = _implementation-defined_;
    using const_iterator       = _implementation-defined_;

    using node_type            = _implementation-defined_;
    using insert_return_type   = _implementation-defined_;

    // construct/copy/destroy
    xref:#unordered_node_map_default_constructor[unordered_node_map]();
    explicit xref:#unordered_node_map_bucket_count_constructor[unordered_node_map](size_type n,
                                const hasher& hf = hasher(),
                                const key_equal& eql = key_equal(),
                                const allocator_type& a = allocator_type());
    template<class InputIterator>
      xref:#unordered_node_map_iterator_range_constructor[unordered_node_map](InputIterator f, InputIterator l,
                         size_type n = _implementation-defined_,
                         const hasher& hf = hasher(),
                         const key_equal& eql = key_equal(),
                         const allocator_type& a = allocator_type());
    xref:#unordered_node_map_copy_constructor[unordered_node_map](const unordered_node_map& other);
    xref:#unordered_node_map_move_constructor[unordered_node_map](unordered_node_map&& other);
    template<class InputIterator>
      xref:#unordered_node_map_iterator_range_constructor_with_allocator[unordered_node_map](InputIterator f, InputIterator l, const allocator_type& a);
    explicit xref:#unordered_node_map_allocator_constructor[unordered_node_map](const Allocator& a);
    xref:#unordered_node_map_copy_constructor_with_allocator[unordered_node_map](const unordered_node_map& other, const Allocator& a);
    xref:#unordered_node_map_move_constructor_with_allocator[unordered_node_map](unordered_node_map&& other, const Allocator& a);
    xref:#unordered_node_map_initializer_list_constructor[unordered_node_map](std::initializer_list<value_type> il,
                       size_type n = _implementation-defined_
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
    xref:#unordered_node_map_bucket_count_constructor_with_allocator[unordered_node_map](size_type n, const allocator_type& a);
    xref:#unordered_node_map_bucket_count_constructor_with_hasher_and_allocator[unordered_node_map](size_type n, const hasher& hf, const allocator_type& a);
    template<class InputIterator>
      xref:#unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator[unordered_node_map](InputIterator f, InputIterator l, size_type n, const allocator_type& a);
    template<class InputIterator>
      xref:#unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher[unordered_node_map](InputIterator f, InputIterator l, size_type n, const hasher& hf,
                         const allocator_type& a);
    xref:#unordered_node_map_initializer_list_constructor_with_allocator[unordered_node_map](std::initializer_list<value_type> il, const allocator_type& a);
    xref:#unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator[unordered_node_map](std::initializer_list<value_type> il, size_type n,
                       const allocator_type& a);
    xref:#unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator[unordered_node_map](std::initializer_list<value_type> il, size_type n, const hasher& hf,
                       const allocator_type& a);
    xref:#unordered_node_map_destructor[~unordered_node_map]();
    unordered_node_map& xref:#unordered_node_map_copy_assignment[operator++=++](const unordered_node_map& other);
    unordered_node_map& xref:#unordered_node_map_move_assignment[operator++=++](unordered_node_map&& other)
      noexcept(boost::allocator_traits<Allocator>::is_always_equal::value ||
              boost::allocator_traits<Allocator>::propagate_on_container_move_assignment::value);
    unordered_node_map& xref:#unordered_node_map_initializer_list_assignment[operator++=++](std::initializer_list<value_type>);
    allocator_type xref:#unordered_node_map_get_allocator[get_allocator]() const noexcept;

    // iterators
    iterator       xref:#unordered_node_map_begin[begin]() noexcept;
    const_iterator xref:#unordered_node_map_begin[begin]() const noexcept;
    iterator       xref:#unordered_node_map_end[end]() noexcept;
    const_iterator xref:#unordered_node_map_end[end]() const noexcept;
    const_iterator xref:#unordered_node_map_cbegin[cbegin]() const noexcept;
    const_iterator xref:#unordered_node_map_cend[cend]() const noexcept;

    // capacity
    ++[[nodiscard]]++ bool xref:#unordered_node_map_empty[empty]() const noexcept;
    size_type xref:#unordered_node_map_size[size]() const noexcept;
    size_type xref:#unordered_node_map_max_size[max_size]() const noexcept;

    // modifiers
    template<class... Args> std::pair<iterator, bool> xref:#unordered_node_map_emplace[emplace](Args&&... args);
    template<class... Args> iterator xref:#unordered_node_map_emplace_hint[emplace_hint](const_iterator position, Args&&... args);
    std::pair<iterator, bool> xref:#unordered_node_map_copy_insert[insert](const value_type& obj);
    std::pair<iterator, bool> xref:#unordered_node_map_copy_insert[insert](const init_type& obj);
    std::pair<iterator, bool> xref:#unordered_node_map_move_insert[insert](value_type&& obj);
    std::pair<iterator, bool> xref:#unordered_node_map_move_insert[insert](init_type&& obj);
    iterator       xref:#unordered_node_map_copy_insert_with_hint[insert](const_iterator hint, const value_type& obj);
    iterator       xref:#unordered_node_map_copy_insert_with_hint[insert](const_iterator hint, const init_type& obj);
    iterator       xref:#unordered_node_map_move_insert_with_hint[insert](const_iterator hint, value_type&& obj);
    iterator       xref:#unordered_node_map_copy_insert_with_hint[insert](const_iterator hint, init_type&& obj);
    template<class InputIterator> void xref:#unordered_node_map_insert_iterator_range[insert](InputIterator first, InputIterator last);
    void xref:#unordered_node_map_insert_initializer_list[insert](std::initializer_list<value_type>);
    insert_return_type xref:#unordered_node_map_insert_node[insert](node_type&& nh);
    iterator xref:#unordered_node_map_insert_node_with_hint[insert](const_iterator hint, node_type&& nh);

    template<class... Args>
      std::pair<iterator, bool> xref:#unordered_node_map_try_emplace[try_emplace](const key_type& k, Args&&... args);
    template<class... Args>
      std::pair<iterator, bool> xref:#unordered_node_map_try_emplace[try_emplace](key_type&& k, Args&&... args);
    template<class K, class... Args>
      std::pair<iterator, bool> xref:#unordered_node_map_try_emplace[try_emplace](K&& k, Args&&... args);
    template<class... Args>
      iterator xref:#unordered_node_map_try_emplace_with_hint[try_emplace](const_iterator hint, const key_type& k, Args&&... args);
    template<class... Args>
      iterator xref:#unordered_node_map_try_emplace_with_hint[try_emplace](const_iterator hint, key_type&& k, Args&&... args);
    template<class K, class... Args>
      iterator xref:#unordered_node_map_try_emplace_with_hint[try_emplace](const_iterator hint, K&& k, Args&&... args);
    template<class M>
      std::pair<iterator, bool> xref:#unordered_node_map_insert_or_assign[insert_or_assign](const key_type& k, M&& obj);
    template<class M>
      std::pair<iterator, bool> xref:#unordered_node_map_insert_or_assign[insert_or_assign](key_type&& k, M&& obj);
    template<class K, class M>
      std::pair<iterator, bool> xref:#unordered_node_map_insert_or_assign[insert_or_assign](K&& k, M&& obj);
    template<class M>
      iterator xref:#unordered_node_map_insert_or_assign_with_hint[insert_or_assign](const_iterator hint, const key_type& k, M&& obj);
    template<class M>
      iterator xref:#unordered_node_map_insert_or_assign_with_hint[insert_or_assign](const_iterator hint, key_type&& k, M&& obj);
    template<class K, class M>
      iterator xref:#unordered_node_map_insert_or_assign_with_hint[insert_or_assign](const_iterator hint, K&& k, M&& obj);

    void      xref:#unordered_node_map_erase_by_position[erase](iterator position);
    void      xref:#unordered_node_map_erase_by_position[erase](const_iterator position);
    size_type xref:#unordered_node_map_erase_by_key[erase](const key_type& k);
    template<class K> size_type xref:#unordered_node_map_erase_by_key[erase](K&& k);
    iterator  xref:#unordered_node_map_erase_range[erase](const_iterator first, const_iterator last);
    void      xref:#unordered_node_map_swap[swap](unordered_node_map& other)
      noexcept(boost::allocator_traits<Allocator>::is_always_equal::value ||
               boost::allocator_traits<Allocator>::propagate_on_container_swap::value);
    node_type xref:#unordered_node_map_extract_by_position[extract](const_iterator position);
    node_type xref:#unordered_node_map_extract_by_key[extract](const key_type& key);
    template<class K> node_type xref:#unordered_node_map_extract_by_key[extract](K&& key);
    void      xref:#unordered_node_map_clear[clear]() noexcept;

    template<class H2, class P2>
      void xref:#unordered_node_map_merge[merge](unordered_node_map<Key, T, H2, P2, Allocator>& source);
    template<class H2, class P2>
      void xref:#unordered_node_map_merge[merge](unordered_node_map<Key, T, H2, P2, Allocator>&& source);

    // observers
    hasher xref:#unordered_node_map_hash_function[hash_function]() const;
    key_equal xref:#unordered_node_map_key_eq[key_eq]() const;

    // map operations
    iterator         xref:#unordered_node_map_find[find](const key_type& k);
    const_iterator   xref:#unordered_node_map_find[find](const key_type& k) const;
    template<class K>
      iterator       xref:#unordered_node_map_find[find](const K& k);
    template<class K>
      const_iterator xref:#unordered_node_map_find[find](const K& k) const;
    size_type        xref:#unordered_node_map_count[count](const key_type& k) const;
    template<class K>
      size_type      xref:#unordered_node_map_count[count](const K& k) const;
    bool             xref:#unordered_node_map_contains[contains](const key_type& k) const;
    template<class K>
      bool           xref:#unordered_node_map_contains[contains](const K& k) const;
    std::pair<iterator, iterator>               xref:#unordered_node_map_equal_range[equal_range](const key_type& k);
    std::pair<const_iterator, const_iterator>   xref:#unordered_node_map_equal_range[equal_range](const key_type& k) const;
    template<class K>
      std::pair<iterator, iterator>             xref:#unordered_node_map_equal_range[equal_range](const K& k);
    template<class K>
      std::pair<const_iterator, const_iterator> xref:#unordered_node_map_equal_range[equal_range](const K& k) const;

    // element access
    mapped_type& xref:#unordered_node_map_operator[operator[+]+](const key_type& k);
    mapped_type& xref:#unordered_node_map_operator[operator[+]+](key_type&& k);
    template<class K> mapped_type& xref:#unordered_node_map_operator[operator[+]+](K&& k);
    mapped_type& xref:#unordered_node_map_at[at](const key_type& k);
    const mapped_type& xref:#unordered_node_map_at[at](const key_type& k) const;
    template<class K> mapped_type& xref:#unordered_node_map_at[at](const K& k);
    template<class K> const mapped_type& xref:#unordered_node_map_at[at](const K& k) const;

    // bucket interface
    size_type xref:#unordered_node_map_bucket_count[bucket_count]() const noexcept;

    // hash policy
    float xref:#unordered_node_map_load_factor[load_factor]() const noexcept;
    float xref:#unordered_node_map_max_load_factor[max_load_factor]() const noexcept;
    void xref:#unordered_node_map_set_max_load_factor[max_load_factor](float z);
    size_type xref:#unordered_node_map_max_load[max_load]() const noexcept;
    void xref:#unordered_node_map_rehash[rehash](size_type n);
    void xref:#unordered_node_map_reserve[reserve](size_type n);
  };

  // Deduction Guides
  template<class InputIterator,
           class Hash = boost::hash<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>>,
           class Pred = std::equal_to<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>>,
           class Allocator = std::allocator<xref:#unordered_node_map_iter_to_alloc_type[__iter-to-alloc-type__]<InputIterator>>>
    unordered_node_map(InputIterator, InputIterator, typename xref:#unordered_node_map_deduction_guides[__see below__]::size_type = xref:#unordered_node_map_deduction_guides[__see below__],
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -> unordered_node_map<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>, xref:#unordered_node_map_iter_mapped_type[__iter-mapped-type__]<InputIterator>, Hash,
                            Pred, Allocator>;

  template<class Key, class T, class Hash = boost::hash<Key>,
           class Pred = std::equal_to<Key>,
           class Allocator = std::allocator<std::pair<const Key, T>>>
    unordered_node_map(std::initializer_list<std::pair<Key, T>>,
                       typename xref:#unordered_node_map_deduction_guides[__see below__]::size_type = xref:#unordered_node_map_deduction_guides[__see below__], Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -> unordered_node_map<Key, T, Hash, Pred, Allocator>;

  template<class InputIterator, class Allocator>
    unordered_node_map(InputIterator, InputIterator, typename xref:#unordered_node_map_deduction_guides[__see below__]::size_type, Allocator)
      -> unordered_node_map<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>, xref:#unordered_node_map_iter_mapped_type[__iter-mapped-type__]<InputIterator>,
                            boost::hash<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>>,
                            std::equal_to<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>>, Allocator>;

  template<class InputIterator, class Allocator>
    unordered_node_map(InputIterator, InputIterator, Allocator)
      -> unordered_node_map<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>, xref:#unordered_node_map_iter_mapped_type[__iter-mapped-type__]<InputIterator>,
                            boost::hash<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>>,
                            std::equal_to<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>>, Allocator>;

  template<class InputIterator, class Hash, class Allocator>
    unordered_node_map(InputIterator, InputIterator, typename xref:#unordered_node_map_deduction_guides[__see below__]::size_type, Hash,
                       Allocator)
      -> unordered_node_map<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>, xref:#unordered_node_map_iter_mapped_type[__iter-mapped-type__]<InputIterator>, Hash,
                            std::equal_to<xref:#unordered_node_map_iter_key_type[__iter-key-type__]<InputIterator>>, Allocator>;

  template<class Key, class T, class Allocator>
    unordered_node_map(std::initializer_list<std::pair<Key, T>>, typename xref:#unordered_node_map_deduction_guides[__see below__]::size_type,
                       Allocator)
      -> unordered_node_map<Key, T, boost::hash<Key>, std::equal_to<Key>, Allocator>;

  template<class Key, class T, class Allocator>
    unordered_node_map(std::initializer_list<std::pair<Key, T>>, Allocator)
      -> unordered_node_map<Key, T, boost::hash<Key>, std::equal_to<Key>, Allocator>;

  template<class Key, class T, class Hash, class Allocator>
    unordered_node_map(std::initializer_list<std::pair<Key, T>>, typename xref:#unordered_node_map_deduction_guides[__see below__]::size_type,
                       Hash, Allocator)
      -> unordered_node_map<Key, T, Hash, std::equal_to<Key>, Allocator>;

  // Equality Comparisons
  template<class Key, class T, class Hash, class Pred, class Alloc>
    bool xref:#unordered_node_map_operator_2[operator==](const unordered_node_map<Key, T, Hash, Pred, Alloc>& x,
                    const unordered_node_map<Key, T, Hash, Pred, Alloc>& y);

  template<class Key, class T, class Hash, class Pred, class Alloc>
    bool xref:#unordered_node_map_operator_3[operator!=](const unordered_node_map<Key, T, Hash, Pred, Alloc>& x,
                    const unordered_node_map<Key, T, Hash, Pred, Alloc>& y);

  // swap
  template<class Key, class T, class Hash, class Pred, class Alloc>
    void xref:#unordered_node_map_swap_2[swap](unordered_node_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_node_map<Key, T, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template<class K, class T, class H, class P, class A, class Predicate>
    typename unordered_node_map<K, T, H, P, A>::size_type
       xref:#unordered_node_map_erase_if[erase_if](unordered_node_map<K, T, H, P, A>& c, Predicate pred);
}
-----

---

=== Description

*Template Parameters*

[cols="1,1"]
|===

|_Key_
.2+|`std::pair<const Key, T>` must be https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible[EmplaceConstructible^]
into the container from any `std::pair` object convertible to it, and it also must be
https://en.cppreference.com/w/cpp/named_req/Erasable[Erasable^] from the container.

|_T_

|_Hash_
|A unary function object type that acts a hash function for a `Key`. It takes a single argument of type `Key` and returns a value of type `std::size_t`.

|_Pred_
|A binary function object that induces an equivalence relation on values of type `Key`. It takes two arguments of type `Key` and returns a value of type `bool`.

|_Allocator_
|An allocator whose value type is the same as the container's value type.
`std::allocator_traits<Allocator>::pointer` and `std::allocator_traits<Allocator>::const_pointer`
must be convertible to/from `value_type*` and `const value_type*`, respectively.

|===

The element nodes of the container are held into an internal _bucket array_. A node is inserted into a bucket determined by the
hash code of its element, but if the bucket is already occupied (a _collision_), an available one in the vicinity of the
original position is used.

The size of the bucket array can be automatically increased by a call to `insert`/`emplace`, or as a result of calling
`rehash`/`reserve`. The _load factor_ of the container (number of elements divided by number of buckets) is never
greater than `max_load_factor()`, except possibly for small sizes where the implementation may decide to
allow for higher loads.

If `xref:hash_traits_hash_is_avalanching[hash_is_avalanching]<Hash>::value` is `true`, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.

---

=== Typedefs

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ iterator;
----

An iterator whose value type is `value_type`.

The iterator category is at least a forward iterator.

Convertible to `const_iterator`.

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ const_iterator;
----

A constant iterator whose value type is `value_type`.

The iterator category is at least a forward iterator.

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ node_type;
----

A class for holding extracted container elements, modelling 
https://en.cppreference.com/w/cpp/container/node_handle[NodeHandle].

---

[source,c++,subs=+quotes]
----
typedef _implementation-defined_ insert_return_type;
----

A specialization of an internal class template:

[source,c++,subs=+quotes]
----
template<class Iterator, class NodeType>
struct _insert_return_type_ // name is exposition only
{
  Iterator position;
  bool     inserted;
  NodeType node;
};
----

with `Iterator` = `iterator` and `NodeType` = `node_type`.

---

=== Constructors

==== Default Constructor
```c++
unordered_node_map();
```

Constructs an empty container using `hasher()` as the hash function,
`key_equal()` as the key equality predicate and `allocator_type()` as the allocator.

[horizontal]
Postconditions:;; `size() == 0`
Requires:;; If the defaults are used, `hasher`, `key_equal` and `allocator_type` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Bucket Count Constructor
```c++
explicit unordered_node_map(size_type n,
                            const hasher& hf = hasher(),
                            const key_equal& eql = key_equal(),
                            const allocator_type& a = allocator_type());
```

Constructs an empty container with at least `n` buckets, using `hf` as the hash
function, `eql` as the key equality predicate, and `a` as the allocator.

[horizontal]
Postconditions:;; `size() == 0`
Requires:;; If the defaults are used, `hasher`, `key_equal` and `allocator_type` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Iterator Range Constructor
[source,c++,subs="+quotes"]
----
template<class InputIterator>
  unordered_node_map(InputIterator f, InputIterator l,
                     size_type n = _implementation-defined_,
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
----

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, `eql` as the key equality predicate and `a` as the allocator, and inserts the elements from `[f, l)` into it.

[horizontal]
Requires:;; If the defaults are used, `hasher`, `key_equal` and `allocator_type` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Copy Constructor
```c++
unordered_node_map(unordered_node_map const& other);
```

The copy constructor. Copies the contained elements, hash function, predicate and allocator.

If `Allocator::select_on_container_copy_construction` exists and has the right signature, the allocator will be constructed from its result.

---

==== Move Constructor
```c++
unordered_node_map(unordered_node_map&& other);
```

The move constructor. The internal bucket array of `other` is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from `other`.

---

==== Iterator Range Constructor with Allocator
```c++
template<class InputIterator>
  unordered_node_map(InputIterator f, InputIterator l, const allocator_type& a);
```

Constructs an empty container using `a` as the allocator, with the default hash function and key equality predicate and inserts the elements from `[f, l)` into it.

[horizontal]
Requires:;; `hasher`, `key_equal` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Allocator Constructor
```c++
explicit unordered_node_map(Allocator const& a);
```

Constructs an empty container, using allocator `a`.

---

==== Copy Constructor with Allocator
```c++
unordered_node_map(unordered_node_map const& other, Allocator const& a);
```

Constructs a container, copying ``other``'s contained elements, hash function, and predicate, but using allocator `a`.

---

==== Move Constructor with Allocator
```c++
unordered_node_map(unordered_node_map&& other, Allocator const& a);
```

If `a == other.get_allocator()`, the element nodes of `other` are transferred directly to the new container;
otherwise, elements are moved-constructed from those of `other`. The hash function and predicate are moved-constructed
from `other`, and the allocator is copy-constructed from `a`.

---

==== Initializer List Constructor
[source,c++,subs="+quotes"]
----
unordered_node_map(std::initializer_list<value_type> il,
              size_type n = _implementation-defined_
              const hasher& hf = hasher(),
              const key_equal& eql = key_equal(),
              const allocator_type& a = allocator_type());
----

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, `eql` as the key equality predicate and `a`, and inserts the elements from `il` into it.

[horizontal]
Requires:;; If the defaults are used, `hasher`, `key_equal` and `allocator_type` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Bucket Count Constructor with Allocator
```c++
unordered_node_map(size_type n, allocator_type const& a);
```

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, the default hash function and key equality predicate and `a` as the allocator.

[horizontal]
Postconditions:;; `size() == 0`
Requires:;; `hasher` and `key_equal` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Bucket Count Constructor with Hasher and Allocator
```c++
unordered_node_map(size_type n, hasher const& hf, allocator_type const& a);
```

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, the default key equality predicate and `a` as the allocator.

[horizontal]
Postconditions:;; `size() == 0`
Requires:;; `key_equal` needs to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Iterator Range Constructor with Bucket Count and Allocator
[source,c++,subs="+quotes"]
----
template<class InputIterator>
  unordered_node_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a);
----

Constructs an empty container with at least `n` buckets, using `a` as the allocator and default hash function and key equality predicate, and inserts the elements from `[f, l)` into it.

[horizontal]
Requires:;; `hasher`, `key_equal` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== Iterator Range Constructor with Bucket Count and Hasher
[source,c++,subs="+quotes"]
----
    template<class InputIterator>
      unordered_node_map(InputIterator f, InputIterator l, size_type n, const hasher& hf,
                         const allocator_type& a);
----

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, `a` as the allocator, with the default key equality predicate, and inserts the elements from `[f, l)` into it.

[horizontal]
Requires:;; `key_equal` needs to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== initializer_list Constructor with Allocator

```c++
unordered_node_map(std::initializer_list<value_type> il, const allocator_type& a);
```

Constructs an empty container using `a` and default hash function and key equality predicate, and inserts the elements from `il` into it.

[horizontal]
Requires:;; `hasher` and `key_equal` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== initializer_list Constructor with Bucket Count and Allocator

```c++
unordered_node_map(std::initializer_list<value_type> il, size_type n, const allocator_type& a);
```

Constructs an empty container with at least `n` buckets, using `a` and default hash function and key equality predicate, and inserts the elements from `il` into it.

[horizontal]
Requires:;; `hasher` and `key_equal` need to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

==== initializer_list Constructor with Bucket Count and Hasher and Allocator

```c++
unordered_node_map(std::initializer_list<value_type> il, size_type n, const hasher& hf,
                   const allocator_type& a);
```

Constructs an empty container with at least `n` buckets, using `hf` as the hash function, `a` as the allocator and default key equality predicate,and inserts the elements from `il` into it.

[horizontal]
Requires:;; `key_equal` needs to be https://en.cppreference.com/w/cpp/named_req/DefaultConstructible[DefaultConstructible^].

---

=== Destructor

```c++
~unordered_node_map();
```

[horizontal]
Note:;; The destructor is applied to every element, and all memory is deallocated

---

=== Assignment

==== Copy Assignment

```c++
unordered_node_map& operator=(unordered_node_map const& other);
```

The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from `other`, 
copy-assigns the allocator from `other` if `Alloc::propagate_on_container_copy_assignment` exists and `Alloc::propagate_on_container_copy_assignment::value` is `true`,
and finally inserts copies of the elements of `other`.

[horizontal]
Requires:;; `value_type` is https://en.cppreference.com/w/cpp/named_req/CopyInsertable[CopyInsertable^]

---

==== Move Assignment
```c++
unordered_node_map& operator=(unordered_node_map&& other)
  noexcept(boost::allocator_traits<Allocator>::is_always_equal::value ||
           boost::allocator_traits<Allocator>::propagate_on_container_move_assignment::value);
```
The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from `other`,
and move-assigns the allocator from `other` if `Alloc::propagate_on_container_move_assignment` exists and `Alloc::propagate_on_container_move_assignment::value` is `true`.
If at this point the allocator is equal to `other.get_allocator()`, the internal bucket array of `other` is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of `other`.

---

==== Initializer List Assignment
```c++
unordered_node_map& operator=(std::initializer_list<value_type> il);
```

Assign from values in initializer list. All previously existing elements are destroyed.

[horizontal]
Requires:;; `value_type` is https://en.cppreference.com/w/cpp/named_req/CopyInsertable[CopyInsertable^]

=== Iterators

==== begin
```c++
iterator begin() noexcept;
const_iterator begin() const noexcept;
```

[horizontal]
Returns:;; An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.
Complexity:;; O(`bucket_count()`)

---

==== end
```c++
iterator end() noexcept;
const_iterator end() const noexcept;
```

[horizontal]
Returns:;; An iterator which refers to the past-the-end value for the container.

---

==== cbegin
```c++
const_iterator cbegin() const noexcept;
```

[horizontal]
Returns:;; A `const_iterator` referring to the first element of the container, or if the container is empty the past-the-end value for the container.
Complexity:;; O(`bucket_count()`)

---

==== cend
```c++
const_iterator cend() const noexcept;
```

[horizontal]
Returns:;; A `const_iterator` which refers to the past-the-end value for the container.

---

=== Size and Capacity

==== empty

```c++
[[nodiscard]] bool empty() const noexcept;
```

[horizontal]
Returns:;; `size() == 0`

---

==== size

```c++
size_type size() const noexcept;
```

[horizontal]
Returns:;; `std::distance(begin(), end())`

---

==== max_size

```c++
size_type max_size() const noexcept;
```

[horizontal]
Returns:;; `size()` of the largest possible container.

---

=== Modifiers

==== emplace
```c++
template<class... Args> std::pair<iterator, bool> emplace(Args&&... args);
```

Inserts an object, constructed with the arguments `args`, in the container if and only if there is no element in the container with an equivalent key.

[horizontal]
Requires:;; `value_type` is constructible from `args`.
Returns:;; The `bool` component of the return type is `true` if an insert took place. +
+
If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. +

---

==== emplace_hint
```c++
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
```

Inserts an object, constructed with the arguments `args`, in the container if and only if there is no element in the container with an equivalent key.

`position` is a suggestion to where the element should be inserted. This implementation ignores it.

[horizontal]
Requires:;; `value_type` is constructible from `args`.
Returns:;; The `bool` component of the return type is `true` if an insert took place. +
+
If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. +

---

==== Copy Insert
```c++
std::pair<iterator, bool> insert(const value_type& obj);
std::pair<iterator, bool> insert(const init_type& obj);
```

Inserts `obj` in the container if and only if there is no element in the container with an equivalent key.

[horizontal]
Requires:;; `value_type` is https://en.cppreference.com/w/cpp/named_req/CopyInsertable[CopyInsertable^].
Returns:;; The `bool` component of the return type is `true` if an insert took place. +
+
If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. +
+
A call of the form `insert(x)`, where `x` is equally convertible to both `const value_type&` and `const init_type&`, is not ambiguous and selects the `init_type` overload.

---

==== Move Insert
```c++
std::pair<iterator, bool> insert(value_type&& obj);
std::pair<iterator, bool> insert(init_type&& obj);
```

Inserts `obj` in the container if and only if there is no element in the container with an equivalent key.

[horizontal]
Requires:;; `value_type` is https://en.cppreference.com/w/cpp/named_req/MoveInsertable[MoveInsertable^].
Returns:;; The `bool` component of the return type is `true` if an insert took place. +
+
If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. +
+
A call of the form `insert(x)`, where `x` is equally convertible to both `value_type&&` and `init_type&&`, is not ambiguous and selects the `init_type` overload.

---

==== Copy Insert with Hint
```c++
iterator insert(const_iterator hint, const value_type& obj);
iterator insert(const_iterator hint, const init_type& obj);
```
Inserts `obj` in the container if and only if there is no element in the container with an equivalent key.

`hint` is a suggestion to where the element should be inserted. This implementation ignores it.

[horizontal]
Requires:;; `value_type` is https://en.cppreference.com/w/cpp/named_req/CopyInsertable[CopyInsertable^].
Returns:;; The `bool` component of the return type is `true` if an insert took place. +
+
If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. +
+
A call of the form `insert(hint, x)`, where `x` is equally convertible to both `const value_type&` and `const init_type&`, is not ambiguous and selects the `init_type` overload.

---

==== Move Insert with Hint
```c++
iterator insert(const_iterator hint, value_type&& obj);
iterator insert(const_iterator hint, init_type&& obj);
```

Inserts `obj` in the container if and only if there is no element in the container with an equivalent key.

`hint` is a suggestion to where the element should be inserted. This implementation ignores it.

[horizontal]
Requires:;; `value_type` is https://en.cppreference.com/w/cpp/named_req/MoveInsertable[MoveInsertable^].
Returns:;; The `bool` component of the return type is `true` if an insert took place. +
+
If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. +
+
A call of the form `insert(hint, x)`, where `x` is equally convertible to both `value_type&&` and `init_type&&`, is not ambiguous and selects the `init_type` overload.

---

==== Insert Iterator Range
```c++
template<class InputIterator> void insert(InputIterator first, InputIterator last);
```

Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.

[horizontal]
Requires:;; `value_type` is https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible[EmplaceConstructible^] into the container from `*first`.
Throws:;; When inserting a single element, if an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.

---

==== Insert Initializer List
```c++
void insert(std::initializer_list<value_type>);
```

Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.

[horizontal]
Requires:;; `value_type` is https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible[EmplaceConstructible^] into the container from `*first`.
Throws:;; When inserting a single element, if an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.

---

==== Insert Node
```c++
insert_return_type insert(node_type&& nh);
```

If `nh` is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to `nh.key()`.
`nh` is empty when the function returns.

[horizontal]
Returns:;; An `insert_return_type` object constructed from `position`, `inserted` and `node`: +
* If `nh` is empty, `inserted` is `false`, `position` is `end()`, and `node` is empty.
* Otherwise if the insertion took place, `inserted` is true, `position` points to the inserted element, and `node` is empty.
* If the insertion failed, `inserted` is false, `node` has the previous value of `nh`, and `position` points to an element with a key equivalent to `nh.key()`.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Behavior is undefined if `nh` is not empty and the allocators of `nh` and the container are not equal.

---

==== Insert Node with Hint
```c++
iterator insert(const_iterator hint, node_type&& nh);
```

If `nh` is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to `nh.key()`.
`nh` becomes empty if insertion took place, otherwise it is not changed.

`hint` is a suggestion to where the element should be inserted. This implementation ignores it.

[horizontal]
Returns:;; The iterator returned is `end()` if `nh` is empty.
If insertion took place, then the iterator points to the newly inserted element; otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Behavior is undefined if `nh` is not empty and the allocators of `nh` and the container are not equal.

---

==== try_emplace
```c++
template<class... Args>
  std::pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template<class... Args>
  std::pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template<class K, class... Args>
  std::pair<iterator, bool> try_emplace(K&& k, Args&&... args);
```

Inserts a new node into the container if there is no existing element with key `k` contained within it.

If there is an existing element with key `k` this function does nothing.

[horizontal]
Returns:;; The `bool` component of the return type is `true` if an insert took place. +
+
If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; This function is similiar to xref:#unordered_node_map_emplace[emplace], with the difference that no `value_type` is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form: +
+
--
```c++
// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward<Key>(k)),
           std::forward_as_tuple(boost::forward<Args>(args)...))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward<K>(k)),
           std::forward_as_tuple(boost::forward<Args>(args)...))
```

unlike xref:#unordered_node_map_emplace[emplace], which simply forwards all arguments to ``value_type``'s constructor.

Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.

The `template <class K, class... Args>` overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs and neither `iterator` nor `const_iterator` are implicitly convertible from `K`. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

--

---

==== try_emplace with Hint
```c++
template<class... Args>
  iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
template<class... Args>
  iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
template<class K, class... Args>
  iterator try_emplace(const_iterator hint, K&& k, Args&&... args);
```

Inserts a new node into the container if there is no existing element with key `k` contained within it.

If there is an existing element with key `k` this function does nothing.

`hint` is a suggestion to where the element should be inserted.  This implementation ignores it.

[horizontal]
Returns:;; If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; This function is similiar to xref:#unordered_node_map_emplace_hint[emplace_hint], with the difference that no `value_type` is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form: +
+
--
```c++
// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward<Key>(k)),
           std::forward_as_tuple(boost::forward<Args>(args)...))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward<K>(k)),
           std::forward_as_tuple(boost::forward<Args>(args)...))
```

unlike xref:#unordered_node_map_emplace_hint[emplace_hint], which simply forwards all arguments to ``value_type``'s constructor.

Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.

The `template <class K, class... Args>` overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs and neither `iterator` nor `const_iterator` are implicitly convertible from `K`. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

--

---

==== insert_or_assign
```c++
template<class M>
  std::pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template<class M>
  std::pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template<class K, class M>
  std::pair<iterator, bool> insert_or_assign(K&& k, M&& obj);
```

Inserts a new element into the container or updates an existing one by assigning to the contained value.

If there is an element with key `k`, then it is updated by assigning `boost::forward<M>(obj)`.

If there is no such element, it is added to the container as:
```c++
// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward<Key>(k)),
           std::forward_as_tuple(boost::forward<M>(obj)))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward<K>(k)),
           std::forward_as_tuple(boost::forward<M>(obj)))
```

[horizontal]
Returns:;; The `bool` component of the return type is `true` if an insert took place. +
+
If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.  +
+
The `template<class K, class M>` only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== insert_or_assign with Hint
```c++
template<class M>
  iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
template<class M>
  iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
template<class K, class M>
  iterator insert_or_assign(const_iterator hint, K&& k, M&& obj);
```

Inserts a new element into the container or updates an existing one by assigning to the contained value.

If there is an element with key `k`, then it is updated by assigning `boost::forward<M>(obj)`.

If there is no such element, it is added to the container as:
```c++
// first two overloads
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward<Key>(k)),
           std::forward_as_tuple(boost::forward<M>(obj)))

// third overload
value_type(std::piecewise_construct,
           std::forward_as_tuple(boost::forward<K>(k)),
           std::forward_as_tuple(boost::forward<M>(obj)))
```

`hint` is a suggestion to where the element should be inserted. This implementation ignores it.

[horizontal]
Returns:;; If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. +
+
The `template<class K, class M>` only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---


==== Erase by Position

```c++
void erase(iterator position);
void erase(const_iterator position);
```

Erase the element pointed to by `position`.

[horizontal]
Throws:;; Nothing.

---

==== Erase by Key
```c++
size_type erase(const key_type& k);
template<class K> size_type erase(K&& k);
```

Erase all elements with key equivalent to `k`.

[horizontal]
Returns:;; The number of elements erased.
Throws:;; Only throws an exception if it is thrown by `hasher` or `key_equal`.
Notes:;; The `template<class K>` overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs and neither `iterator` nor `const_iterator` are implicitly convertible from `K`. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== Erase Range

```c++
iterator erase(const_iterator first, const_iterator last);
```

Erases the elements in the range from `first` to `last`.

[horizontal]
Returns:;; The iterator following the erased elements - i.e. `last`.
Throws:;; Nothing in this implementation (neither the `hasher` nor the `key_equal` objects are called).

---

==== swap
```c++
void swap(unordered_node_map& other)
  noexcept(boost::allocator_traits<Allocator>::is_always_equal::value ||
           boost::allocator_traits<Allocator>::propagate_on_container_swap::value);
```

Swaps the contents of the container with the parameter.

If `Allocator::propagate_on_container_swap` is declared and `Allocator::propagate_on_container_swap::value` is `true` then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.

[horizontal]
Throws:;; Nothing unless `key_equal` or `hasher` throw on swapping.

---

==== Extract by Position
```c++
node_type extract(const_iterator position);
```

Extracts the element pointed to by `position`.

[horizontal]
Returns:;; A `node_type` object holding the extracted element.
Throws:;; Nothing.

---

==== Extract by Key
```c++
node_type erase(const key_type& k);
template<class K> node_type erase(K&& k);
```

Extracts the element with key equivalent to `k`, if it exists.

[horizontal]
Returns:;; A `node_type` object holding the extracted element, or empty if no element was extracted.
Throws:;; Only throws an exception if it is thrown by `hasher` or `key_equal`.
Notes:;; The `template<class K>` overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs and neither `iterator` nor `const_iterator` are implicitly convertible from `K`. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== clear
```c++
void clear() noexcept;
```

Erases all elements in the container.

[horizontal]
Postconditions:;; `size() == 0`, `max_load() >= max_load_factor() * bucket_count()`

---

==== merge
```c++
template<class H2, class P2>
  void merge(unordered_node_map<Key, T, H2, P2, Allocator>& source);
template<class H2, class P2>
  void merge(unordered_node_map<Key, T, H2, P2, Allocator>&& source);
```

Transfers all the element nodes from `source` whose key is not already present in `*this`.

---

=== Observers

==== get_allocator
```
allocator_type get_allocator() const noexcept;
```

[horizontal]
Returns:;; The container's allocator.

---

==== hash_function
```
hasher hash_function() const;
```

[horizontal]
Returns:;; The container's hash function.

---

==== key_eq
```
key_equal key_eq() const;
```

[horizontal]
Returns:;; The container's key equality predicate

---

=== Lookup

==== find
```c++
iterator         find(const key_type& k);
const_iterator   find(const key_type& k) const;
template<class K>
  iterator       find(const K& k);

```

[horizontal]
Returns:;; An iterator pointing to an element with key equivalent to `k`, or `end()` if no such element exists.
Notes:;; The `template <typename K>` overloads only participate in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== count
```c++
size_type        count(const key_type& k) const;
template<class K>
  size_type      count(const K& k) const;
```

[horizontal]
Returns:;; The number of elements with key equivalent to `k`.
Notes:;; The `template <typename K>` overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== contains
```c++
bool             contains(const key_type& k) const;
template<class K>
  bool           contains(const K& k) const;
```

[horizontal]
Returns:;; A boolean indicating whether or not there is an element with key equal to `key` in the container
Notes:;; The `template <typename K>` overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== equal_range
```c++
std::pair<iterator, iterator>               equal_range(const key_type& k);
std::pair<const_iterator, const_iterator>   equal_range(const key_type& k) const;
template<class K>
  std::pair<iterator, iterator>             equal_range(const K& k);
template<class K>
  std::pair<const_iterator, const_iterator> equal_range(const K& k) const;
```

[horizontal]
Returns:;; A range containing all elements with key equivalent to `k`. If the container doesn't contain any such elements, returns `std::make_pair(b.end(), b.end())`.
Notes:;; The `template <typename K>` overloads only participate in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== operator++[++++]++
```c++
mapped_type& operator[](const key_type& k);
mapped_type& operator[](key_type&& k);
template<class K> mapped_type& operator[](K&& k);
```

[horizontal]
Effects:;; If the container does not already contain an element with a key equivalent to `k`, inserts the value `std::pair<key_type const, mapped_type>(k, mapped_type())`.
Returns:;; A reference to `x.second` where `x` is the element already in the container, or the newly inserted element with a key equivalent to `k`.
Throws:;; If an exception is thrown by an operation other than a call to `hasher` the function has no effect.
Notes:;; Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. +
+
The `template<class K>` overload only participates in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

==== at
```c++
mapped_type& at(const key_type& k);
const mapped_type& at(const key_type& k) const;
template<class K> mapped_type& at(const K& k);
template<class K> const mapped_type& at(const K& k) const;
```

[horizontal]
Returns:;; A reference to `x.second` where `x` is the (unique) element whose key is equivalent to `k`.
Throws:;; An exception object of type `std::out_of_range` if no such element is present.
Notes:;; The `template<class K>` overloads only participate in overload resolution if `Hash::is_transparent` and `Pred::is_transparent` are valid member typedefs. The library assumes that `Hash` is callable with both `K` and `Key` and that `Pred` is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the `Key` type.

---

=== Bucket Interface

==== bucket_count
```c++
size_type bucket_count() const noexcept;
```

[horizontal]
Returns:;; The size of the bucket array.

---

=== Hash Policy

==== load_factor
```c++
float load_factor() const noexcept;
```

[horizontal]
Returns:;; `static_cast<float>(size())/static_cast<float>(bucket_count())`, or `0` if `bucket_count() == 0`.

---

==== max_load_factor

```c++
float max_load_factor() const noexcept;
```

[horizontal]
Returns:;; Returns the container's maximum load factor.

---

==== Set max_load_factor
```c++
void max_load_factor(float z);
```

[horizontal]
Effects:;; Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with `boost::unordered_map`.

---


==== max_load

```c++
size_type max_load() const noexcept;
```

[horizontal]
Returns:;; The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.
Note:;; After construction, rehash or clearance, the container's maximum load is at least `max_load_factor() * bucket_count()`.
This number may decrease on erasure under high-load conditions.

---

==== rehash
```c++
void rehash(size_type n);
```

Changes if necessary the size of the bucket array so that there are at least `n` buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the `bucket_count()` associated with the container.

When `size() == 0`, `rehash(0)` will deallocate the underlying buckets array.

Invalidates iterators and changes the order of elements.

[horizontal]
Throws:;; The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.

---

==== reserve
```c++
void reserve(size_type n);
```

Equivalent to `a.rehash(ceil(n / a.max_load_factor()))`.

Similar to `rehash`, this function can be used to grow or shrink the number of buckets in the container.

Invalidates iterators and changes the order of elements.

[horizontal]
Throws:;; The function has no effect if an exception is thrown, unless it is thrown by the container's hash function or comparison function.

=== Deduction Guides
A deduction guide will not participate in overload resolution if any of the following are true:

  - It has an `InputIterator` template parameter and a type that does not qualify as an input iterator is deduced for that parameter.
  - It has an `Allocator` template parameter and a type that does not qualify as an allocator is deduced for that parameter.
  - It has a `Hash` template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.
  - It has a `Pred` template parameter and a type that qualifies as an allocator is deduced for that parameter.

A `size_Â­type` parameter type in a deduction guide refers to the `size_Â­type` member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.

==== __iter-value-type__
[listings,subs="+macros,+quotes"]
-----
template<class InputIterator>
  using __iter-value-type__ =
    typename std::iterator_traits<InputIterator>::value_type; // exposition only
-----

==== __iter-key-type__
[listings,subs="+macros,+quotes"]
-----
template<class InputIterator>
  using __iter-key-type__ = std::remove_const_t<
    std::tuple_element_t<0, xref:#unordered_map_iter_value_type[__iter-value-type__]<InputIterator>>>; // exposition only
-----

==== __iter-mapped-type__
[listings,subs="+macros,+quotes"]
-----
template<class InputIterator>
  using __iter-mapped-type__ =
    std::tuple_element_t<1, xref:#unordered_map_iter_value_type[__iter-value-type__]<InputIterator>>;  // exposition only
-----

==== __iter-to-alloc-type__
[listings,subs="+macros,+quotes"]
-----
template<class InputIterator>
  using __iter-to-alloc-type__ = std::pair<
    std::add_const_t<std::tuple_element_t<0, xref:#unordered_map_iter_value_type[__iter-value-type__]<InputIterator>>>,
    std::tuple_element_t<1, xref:#unordered_map_iter_value_type[__iter-value-type__]<InputIterator>>>; // exposition only
-----

=== Equality Comparisons

==== operator==
```c++
template<class Key, class T, class Hash, class Pred, class Alloc>
  bool operator==(const unordered_node_map<Key, T, Hash, Pred, Alloc>& x,
                  const unordered_node_map<Key, T, Hash, Pred, Alloc>& y);
```

Return `true` if `x.size() == y.size()` and for every element in `x`, there is an element in `y` with the same key, with an equal value (using `operator==` to compare the value types).

[horizontal]
Notes:;; Behavior is undefined if the two containers don't have equivalent equality predicates.

---

==== operator!=
```c++
template<class Key, class T, class Hash, class Pred, class Alloc>
  bool operator!=(const unordered_node_map<Key, T, Hash, Pred, Alloc>& x,
                  const unordered_node_map<Key, T, Hash, Pred, Alloc>& y);
```

Return `false` if `x.size() == y.size()` and for every element in `x`, there is an element in `y` with the same key, with an equal value (using `operator==` to compare the value types).

[horizontal]
Notes:;; Behavior is undefined if the two containers don't have equivalent equality predicates.

=== Swap
```c++
template<class Key, class T, class Hash, class Pred, class Alloc>
  void swap(unordered_node_map<Key, T, Hash, Pred, Alloc>& x,
            unordered_node_map<Key, T, Hash, Pred, Alloc>& y)
    noexcept(noexcept(x.swap(y)));
```

Swaps the contents of `x` and `y`.

If `Allocator::propagate_on_container_swap` is declared and `Allocator::propagate_on_container_swap::value` is `true` then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.

[horizontal]
Effects:;; `x.swap(y)`
Throws:;; Nothing unless `key_equal` or `hasher` throw on swapping.

---

=== erase_if
```c++
template<class K, class T, class H, class P, class A, class Predicate>
  typename unordered_node_map<K, T, H, P, A>::size_type
    erase_if(unordered_node_map<K, T, H, P, A>& c, Predicate pred);
```

Traverses the container `c` and removes all elements for which the supplied predicate returns `true`.

[horizontal]
Returns:;; The number of erased elements.
Notes:;; Equivalent to: +
+
```c++
auto original_size = c.size();
for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}
return original_size - c.size();
```

---
