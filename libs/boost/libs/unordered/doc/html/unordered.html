<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>Boost.Unordered</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Boost.Unordered</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#intro">Introduction</a></li>
<li><a href="#buckets">The Data Structure</a>
<ul class="sectlevel2">
<li><a href="#buckets_controlling_the_number_of_buckets">Controlling the number of buckets</a></li>
<li><a href="#buckets_iterator_invalidation">Iterator Invalidation</a></li>
<li><a href="#buckets_fast_closed_addressing_implementation">Fast Closed Addressing Implementation</a></li>
<li><a href="#buckets_open_addressing_implementation">Open Addressing Implementation</a></li>
</ul>
</li>
<li><a href="#hash_equality">Equality Predicates and Hash Functions</a>
<ul class="sectlevel2">
<li><a href="#hash_equality_custom_types">Custom Types</a></li>
</ul>
</li>
<li><a href="#comparison">Comparison with Associative Containers</a></li>
<li><a href="#compliance">Standard Compliance</a>
<ul class="sectlevel2">
<li><a href="#compliance_closed_addressing_containers">Closed-addressing containers</a>
<ul class="sectlevel3">
<li><a href="#compliance_move_emulation">Move emulation</a></li>
<li><a href="#compliance_use_of_allocators">Use of allocators</a></li>
<li><a href="#compliance_constructiondestruction_using_allocators">Construction/Destruction using allocators</a></li>
<li><a href="#compliance_pointer_traits">Pointer Traits</a></li>
<li><a href="#compliance_pairs">Pairs</a></li>
<li><a href="#compliance_miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li><a href="#compliance_open_addressing_containers">Open-addressing containers</a></li>
</ul>
</li>
<li><a href="#benchmarks">Benchmarks</a>
<ul class="sectlevel2">
<li><a href="#benchmarks_boostunordered_multiset">boost::unordered_[multi]set</a>
<ul class="sectlevel3">
<li><a href="#benchmarks_gcc_11_libstdc_v3_x64">GCC 11 + libstdc++-v3, x64</a></li>
<li><a href="#benchmarks_clang_12_libc_x64">Clang 12 + libc++, x64</a></li>
<li><a href="#benchmarks_visual_studio_2019_dinkumware_x64">Visual Studio 2019 + Dinkumware, x64</a></li>
</ul>
</li>
<li><a href="#benchmarks_boostunordered_flatnode_map">boost::unordered_(flat|node)_map</a>
<ul class="sectlevel3">
<li><a href="#benchmarks_gcc_11_x64">GCC 11, x64</a></li>
<li><a href="#benchmarks_clang_12_x64">Clang 12, x64</a></li>
<li><a href="#benchmarks_visual_studio_2019_x64">Visual Studio 2019, x64</a></li>
<li><a href="#benchmarks_clang_12_arm64">Clang 12, ARM64</a></li>
<li><a href="#benchmarks_gcc_11_x86">GCC 11, x86</a></li>
<li><a href="#benchmarks_clang_12_x86">Clang 12, x86</a></li>
<li><a href="#benchmarks_visual_studio_2019_x86">Visual Studio 2019, x86</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#rationale">Implementation Rationale</a>
<ul class="sectlevel2">
<li><a href="#rationale_closed_addressing_containers">Closed-addressing containers</a>
<ul class="sectlevel3">
<li><a href="#rationale_data_structure">Data Structure</a></li>
<li><a href="#rationale_number_of_buckets">Number of Buckets</a></li>
</ul>
</li>
<li><a href="#rationale_open_addresing_containers">Open-addresing containers</a>
<ul class="sectlevel3">
<li><a href="#rationale_hash_function">Hash function</a></li>
<li><a href="#rationale_platform_interoperability">Platform interoperability</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#unordered_map">Class template unordered_map</a>
<ul class="sectlevel3">
<li><a href="#unordered_map_synopsis">Synopsis</a></li>
<li><a href="#unordered_map_description">Description</a></li>
<li><a href="#unordered_map_typedefs">Typedefs</a></li>
<li><a href="#unordered_map_constructors">Constructors</a></li>
<li><a href="#unordered_map_destructor">Destructor</a></li>
<li><a href="#unordered_map_assignment">Assignment</a></li>
<li><a href="#unordered_map_iterators">Iterators</a></li>
<li><a href="#unordered_map_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_map_modifiers">Modifiers</a></li>
<li><a href="#unordered_map_observers">Observers</a></li>
<li><a href="#unordered_map_lookup">Lookup</a></li>
<li><a href="#unordered_map_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_map_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_map_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_map_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_map_swap_2">Swap</a></li>
<li><a href="#unordered_map_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#unordered_multimap">Class template unordered_multimap</a>
<ul class="sectlevel3">
<li><a href="#unordered_multimap_synopsis">Synopsis</a></li>
<li><a href="#unordered_multimap_description">Description</a></li>
<li><a href="#unordered_multimap_typedefs">Typedefs</a></li>
<li><a href="#unordered_multimap_constructors">Constructors</a></li>
<li><a href="#unordered_multimap_destructor">Destructor</a></li>
<li><a href="#unordered_multimap_assignment">Assignment</a></li>
<li><a href="#unordered_multimap_iterators">Iterators</a></li>
<li><a href="#unordered_multimap_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_multimap_modifiers">Modifiers</a></li>
<li><a href="#unordered_multimap_observers">Observers</a></li>
<li><a href="#unordered_multimap_lookup">Lookup</a></li>
<li><a href="#unordered_multimap_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_multimap_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_multimap_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_multimap_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_multimap_swap_2">Swap</a></li>
<li><a href="#unordered_multimap_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#unordered_set">Class template unordered_set</a>
<ul class="sectlevel3">
<li><a href="#unordered_set_synopsis">Synopsis</a></li>
<li><a href="#unordered_set_description">Description</a></li>
<li><a href="#unordered_set_typedefs">Typedefs</a></li>
<li><a href="#unordered_set_constructors">Constructors</a></li>
<li><a href="#unordered_set_destructor">Destructor</a></li>
<li><a href="#unordered_set_assignment">Assignment</a></li>
<li><a href="#unordered_set_iterators">Iterators</a></li>
<li><a href="#unordered_set_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_set_modifiers">Modifiers</a></li>
<li><a href="#unordered_set_observers">Observers</a></li>
<li><a href="#unordered_set_lookup">Lookup</a></li>
<li><a href="#unordered_set_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_set_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_set_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_set_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_set_swap_2">Swap</a></li>
<li><a href="#unordered_set_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#unordered_multiset">Class template unordered_multiset</a>
<ul class="sectlevel3">
<li><a href="#unordered_multiset_synopsis">Synopsis</a></li>
<li><a href="#unordered_multiset_description">Description</a></li>
<li><a href="#unordered_multiset_typedefs">Typedefs</a></li>
<li><a href="#unordered_multiset_constructors">Constructors</a></li>
<li><a href="#unordered_multiset_destructor">Destructor</a></li>
<li><a href="#unordered_multiset_assignment">Assignment</a></li>
<li><a href="#unordered_multiset_iterators">Iterators</a></li>
<li><a href="#unordered_multiset_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_multiset_modifiers">Modifiers</a></li>
<li><a href="#unordered_multiset_observers">Observers</a></li>
<li><a href="#unordered_multiset_lookup">Lookup</a></li>
<li><a href="#unordered_multiset_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_multiset_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_multiset_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_multiset_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_multiset_swap_2">Swap</a></li>
<li><a href="#unordered_multiset_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#hash_traits">Hash traits</a>
<ul class="sectlevel3">
<li><a href="#hash_traits_synopsis">Synopsis</a></li>
<li><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a></li>
</ul>
</li>
<li><a href="#unordered_flat_map">Class template unordered_flat_map</a>
<ul class="sectlevel3">
<li><a href="#unordered_flat_map_synopsis">Synopsis</a></li>
<li><a href="#unordered_flat_map_description">Description</a></li>
<li><a href="#unordered_flat_map_typedefs">Typedefs</a></li>
<li><a href="#unordered_flat_map_constructors">Constructors</a></li>
<li><a href="#unordered_flat_map_destructor">Destructor</a></li>
<li><a href="#unordered_flat_map_assignment">Assignment</a></li>
<li><a href="#unordered_flat_map_iterators">Iterators</a></li>
<li><a href="#unordered_flat_map_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_flat_map_modifiers">Modifiers</a></li>
<li><a href="#unordered_flat_map_observers">Observers</a></li>
<li><a href="#unordered_flat_map_lookup">Lookup</a></li>
<li><a href="#unordered_flat_map_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_flat_map_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_flat_map_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_flat_map_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_flat_map_swap_2">Swap</a></li>
<li><a href="#unordered_flat_map_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#unordered_flat_set">Class template unordered_flat_set</a>
<ul class="sectlevel3">
<li><a href="#unordered_flat_set_synopsis">Synopsis</a></li>
<li><a href="#unordered_flat_set_description">Description</a></li>
<li><a href="#unordered_flat_set_typedefs">Typedefs</a></li>
<li><a href="#unordered_flat_set_constructors">Constructors</a></li>
<li><a href="#unordered_flat_set_destructor">Destructor</a></li>
<li><a href="#unordered_flat_set_assignment">Assignment</a></li>
<li><a href="#unordered_flat_set_iterators">Iterators</a></li>
<li><a href="#unordered_flat_set_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_flat_set_modifiers">Modifiers</a></li>
<li><a href="#unordered_flat_set_observers">Observers</a></li>
<li><a href="#unordered_flat_set_lookup">Lookup</a></li>
<li><a href="#unordered_flat_set_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_flat_set_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_flat_set_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_flat_set_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_flat_set_swap_2">Swap</a></li>
<li><a href="#unordered_flat_set_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#unordered_node_map">Class template unordered_node_map</a>
<ul class="sectlevel3">
<li><a href="#unordered_node_map_synopsis">Synopsis</a></li>
<li><a href="#unordered_node_map_description">Description</a></li>
<li><a href="#unordered_node_map_typedefs">Typedefs</a></li>
<li><a href="#unordered_node_map_constructors">Constructors</a></li>
<li><a href="#unordered_node_map_destructor">Destructor</a></li>
<li><a href="#unordered_node_map_assignment">Assignment</a></li>
<li><a href="#unordered_node_map_iterators">Iterators</a></li>
<li><a href="#unordered_node_map_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_node_map_modifiers">Modifiers</a></li>
<li><a href="#unordered_node_map_observers">Observers</a></li>
<li><a href="#unordered_node_map_lookup">Lookup</a></li>
<li><a href="#unordered_node_map_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_node_map_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_node_map_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_node_map_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_node_map_swap_2">Swap</a></li>
<li><a href="#unordered_node_map_erase_if">erase_if</a></li>
</ul>
</li>
<li><a href="#unordered_node_set">Class template unordered_node_set</a>
<ul class="sectlevel3">
<li><a href="#unordered_node_set_synopsis">Synopsis</a></li>
<li><a href="#unordered_node_set_description">Description</a></li>
<li><a href="#unordered_node_set_typedefs">Typedefs</a></li>
<li><a href="#unordered_node_set_constructors">Constructors</a></li>
<li><a href="#unordered_node_set_destructor">Destructor</a></li>
<li><a href="#unordered_node_set_assignment">Assignment</a></li>
<li><a href="#unordered_node_set_iterators">Iterators</a></li>
<li><a href="#unordered_node_set_size_and_capacity">Size and Capacity</a></li>
<li><a href="#unordered_node_set_modifiers">Modifiers</a></li>
<li><a href="#unordered_node_set_observers">Observers</a></li>
<li><a href="#unordered_node_set_lookup">Lookup</a></li>
<li><a href="#unordered_node_set_bucket_interface">Bucket Interface</a></li>
<li><a href="#unordered_node_set_hash_policy">Hash Policy</a></li>
<li><a href="#unordered_node_set_deduction_guides">Deduction Guides</a></li>
<li><a href="#unordered_node_set_equality_comparisons">Equality Comparisons</a></li>
<li><a href="#unordered_node_set_swap_2">Swap</a></li>
<li><a href="#unordered_node_set_erase_if">erase_if</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#changes">Change Log</a>
<ul class="sectlevel2">
<li><a href="#changes_release_1_82_0_major_update">Release 1.82.0 - Major update</a></li>
<li><a href="#changes_release_1_81_0_major_update">Release 1.81.0 - Major update</a></li>
<li><a href="#changes_release_1_80_0_major_update">Release 1.80.0 - Major update</a></li>
<li><a href="#changes_release_1_79_0">Release 1.79.0</a></li>
<li><a href="#changes_release_1_67_0">Release 1.67.0</a></li>
<li><a href="#changes_release_1_66_0">Release 1.66.0</a></li>
<li><a href="#changes_release_1_65_0">Release 1.65.0</a></li>
<li><a href="#changes_release_1_64_0">Release 1.64.0</a></li>
<li><a href="#changes_release_1_63_0">Release 1.63.0</a></li>
<li><a href="#changes_release_1_62_0">Release 1.62.0</a></li>
<li><a href="#changes_release_1_58_0">Release 1.58.0</a></li>
<li><a href="#changes_release_1_57_0">Release 1.57.0</a></li>
<li><a href="#changes_release_1_56_0">Release 1.56.0</a></li>
<li><a href="#changes_release_1_55_0">Release 1.55.0</a></li>
<li><a href="#changes_release_1_54_0">Release 1.54.0</a></li>
<li><a href="#changes_release_1_53_0">Release 1.53.0</a></li>
<li><a href="#changes_release_1_52_0">Release 1.52.0</a></li>
<li><a href="#changes_release_1_51_0">Release 1.51.0</a></li>
<li><a href="#changes_release_1_50_0">Release 1.50.0</a></li>
<li><a href="#changes_release_1_49_0">Release 1.49.0</a></li>
<li><a href="#changes_release_1_48_0_major_update">Release 1.48.0 - Major update</a></li>
<li><a href="#changes_release_1_45_0">Release 1.45.0</a></li>
<li><a href="#changes_release_1_43_0">Release 1.43.0</a></li>
<li><a href="#changes_release_1_42_0">Release 1.42.0</a></li>
<li><a href="#changes_release_1_41_0_major_update">Release 1.41.0 - Major update</a></li>
<li><a href="#changes_release_1_40_0">Release 1.40.0</a></li>
<li><a href="#changes_release_1_39_0">Release 1.39.0</a></li>
<li><a href="#changes_release_1_38_0">Release 1.38.0</a></li>
<li><a href="#changes_release_1_37_0">Release 1.37.0</a></li>
<li><a href="#changes_release_1_36_0">Release 1.36.0</a></li>
<li><a href="#changes_boost_1_35_0_add_on_31st_march_2008">Boost 1.35.0 Add-on - 31st March 2008</a></li>
<li><a href="#changes_review_version">Review Version</a></li>
</ul>
</li>
<li><a href="#bibliography">Bibliography</a></li>
<li><a href="#copyright">Copyright and License</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="intro"><a class="link" href="#intro">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>For accessing data based on key lookup, the C++ standard library offers <code>std::set</code>,
<code>std::map</code>, <code>std::multiset</code> and <code>std::multimap</code>. These are generally
implemented using balanced binary trees so that lookup time has
logarithmic complexity. That is generally okay, but in many cases a
<a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">hash table</a> can perform better, as accessing data has constant complexity,
on average. The worst case complexity is linear, but that occurs rarely and
with some care, can be avoided.</p>
</div>
<div class="paragraph">
<p>Also, the existing containers require a 'less than' comparison object
to order their elements. For some data types this is impossible to implement
or isn&#8217;t practical. In contrast, a hash table only needs an equality function
and a hash function for the key.</p>
</div>
<div class="paragraph">
<p>With this in mind, unordered associative containers were added to the C++
standard. Boost.Unordered provides an implementation of the containers described in C++11,
with some <a href="#compliance">deviations from the standard</a> in
order to work with non-C++11 compilers and libraries.</p>
</div>
<div class="paragraph">
<p><code>unordered_set</code> and <code>unordered_multiset</code> are defined in the header
<code>&lt;boost/unordered/unordered_set.hpp&gt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_set</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_multiset</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unordered_map</code> and <code>unordered_multimap</code> are defined in the header
<code>&lt;boost/unordered/unordered_map.hpp&gt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_map</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_multimap</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These containers, and all other implementations of standard unordered associative
containers, use an approach to its internal data structure design called
<strong>closed addressing</strong>. Starting in Boost 1.81, Boost.Unordered also provides containers
<code>boost::unordered_flat_set</code> and <code>boost::unordered_flat_map</code>, which use a
different data structure strategy commonly known as <strong>open addressing</strong> and depart in
a small number of ways from the standard so as to offer much better performance
in exchange (more than 2 times faster in typical scenarios):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// #include &lt;boost/unordered/unordered_flat_set.hpp&gt;</span>
<span class="c1">//</span>
<span class="c1">// Note: no multiset version</span>

<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_flat_set</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// #include &lt;boost/unordered/unordered_flat_map.hpp&gt;</span>
<span class="c1">//</span>
<span class="c1">// Note: no multimap version</span>

<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_flat_map</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Starting in Boost 1.82, the containers <code>boost::unordered_node_set</code> and <code>boost::unordered_node_map</code>
are introduced: they use open addressing like <code>boost::unordered_flat_set</code> and <code>boost::unordered_flat_map</code>,
but internally store element <em>nodes</em>, like <code>boost::unordered_set</code> and <code>boost::unordered_map</code>,
which provide stability of pointers and references to the elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// #include &lt;boost/unordered/unordered_node_set.hpp&gt;</span>
<span class="c1">//</span>
<span class="c1">// Note: no multiset version</span>

<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_node_set</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// #include &lt;boost/unordered/unordered_node_map.hpp&gt;</span>
<span class="c1">//</span>
<span class="c1">// Note: no multimap version</span>

<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
        <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_node_map</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These are all the containers provided by Boost.Unordered:</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 1. Boost.Unordered containers</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top"></th>
<th class="tableblock halign-center valign-top"><p class="tableblock"><strong>Node-based</strong></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock"><strong>Flat</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock"><strong>Closed addressing</strong></p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::unordered_set</code><br>
<code>boost::unordered_map</code><br>
<code>boost::unordered_multiset</code><br>
<code>boost::unordered_multimap</code></p></td>
<td class="tableblock halign-center valign-middle"></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock"><strong>Open addressing</strong></p></th>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>boost::unordered_node_set</code><br>
<code>boost::unordered_node_map</code></p></td>
<td class="tableblock halign-center valign-middle"><p class="tableblock"><code>boost::unordered_flat_set</code><br>
<code>boost::unordered_flat_map</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Closed-addressing containers are C++98-compatible. Open-addressing containers require a
reasonably compliant C++11 compiler.</p>
</div>
<div class="paragraph">
<p>Boost.Unordered containers are used in a similar manner to the normal associative
containers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
<span class="n">map</span> <span class="n">x</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="s">"one"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="s">"two"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">x</span><span class="p">[</span><span class="s">"three"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"missing"</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But since the elements aren&#8217;t ordered, the output of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="n">map</span><span class="o">::</span><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">i</span><span class="o">:</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">.</span><span class="n">first</span><span class="o">&lt;&lt;</span><span class="s">","</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">.</span><span class="n">second</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>can be in any order. For example, it might be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">two</span><span class="p">,</span><span class="mi">2</span>
<span class="n">one</span><span class="p">,</span><span class="mi">1</span>
<span class="n">three</span><span class="p">,</span><span class="mi">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To store an object in an unordered associative container requires both a
key equality function and a hash function. The default function objects in
the standard containers support a few basic types including integer types,
floating point types, pointer types, and the standard strings. Since
Boost.Unordered uses <a href="../../../container_hash/index.html" target="_blank" rel="noopener">boost::hash</a> it also supports some other types,
including standard containers. To use any types not supported by these methods
you have to extend Boost.Hash to support the type or use
your own custom equality predicates and hash functions. See the
<a href="#hash_equality">Equality Predicates and Hash Functions</a> section
for more details.</p>
</div>
<div class="paragraph">
<p>There are other differences, which are listed in the
<a href="#comparison">Comparison with Associative Containers</a> section.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="buckets"><a class="link" href="#buckets">The Data Structure</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The containers are made up of a number of 'buckets', each of which can contain
any number of elements. For example, the following diagram shows a <a href="#unordered_set"><code>boost::unordered_set</code></a> with 7 buckets containing 5 elements, <code>A</code>,
<code>B</code>, <code>C</code>, <code>D</code> and <code>E</code> (this is just for illustration, containers will typically
have more buckets).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../diagrams/buckets.png" alt="buckets">
</div>
</div>
<div class="paragraph">
<p>In order to decide which bucket to place an element in, the container applies
the hash function, <code>Hash</code>, to the element&#8217;s key (for <code>unordered_set</code> and
<code>unordered_multiset</code> the key is the whole element, but is referred to as the key
so that the same terminology can be used for sets and maps). This returns a
value of type <code>std::size_t</code>. <code>std::size_t</code> has a much greater range of values
then the number of buckets, so the container applies another transformation to
that value to choose a bucket to place the element in.</p>
</div>
<div class="paragraph">
<p>Retrieving the elements for a given key is simple. The same process is applied
to the key to find the correct bucket. Then the key is compared with the
elements in the bucket to find any elements that match (using the equality
predicate <code>Pred</code>). If the hash function has worked well the elements will be
evenly distributed amongst the buckets so only a small number of elements will
need to be examined.</p>
</div>
<div class="paragraph">
<p>There is <a href="#hash_equality">more information on hash functions and
equality predicates in the next section</a>.</p>
</div>
<div class="paragraph">
<p>You can see in the diagram that <code>A</code> &amp; <code>D</code> have been placed in the same bucket.
When looking for elements in this bucket up to 2 comparisons are made, making
the search slower. This is known as a <strong>collision</strong>. To keep things fast we try to
keep collisions to a minimum.</p>
</div>
<div class="paragraph">
<p>If instead of <code>boost::unordered_set</code> we had used <a href="#unordered_flat_set"><code>boost::unordered_flat_set</code></a>, the
diagram would look as follows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../diagrams/buckets-oa.png" alt="buckets oa">
</div>
</div>
<div class="paragraph">
<p>In open-addressing containers, buckets can hold at most one element; if a collision happens
(like is the case of <code>D</code> in the example), the element uses some other available bucket in
the vicinity of the original position. Given this simpler scenario, Boost.Unordered
open-addressing containers offer a very limited API for accessing buckets.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 2. Methods for Accessing Buckets</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>All containers</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket_count() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The number of buckets.</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>Closed-addressing containers only</strong><br>
<code>boost::unordered_[multi]set</code>, <code>boost::unordered_[multi]map</code></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type max_bucket_count() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">An upper bound on the number of buckets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket_size(size_type n) const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The number of elements in bucket <code>n</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type bucket(key_type const&amp; k) const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the index of the bucket which would contain <code>k</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local_iterator begin(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle" rowspan="6"><p class="tableblock">Return begin and end iterators for bucket <code>n</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local_iterator end(size_type n)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator begin(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator end(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator cbegin(size_type n) const</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const_local_iterator cend(size_type n) const</code></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="buckets_controlling_the_number_of_buckets"><a class="link" href="#buckets_controlling_the_number_of_buckets">Controlling the number of buckets</a></h3>
<div class="paragraph">
<p>As more elements are added to an unordered associative container, the number
of collisions will increase causing performance to degrade.
To combat this the containers increase the bucket count as elements are inserted.
You can also tell the container to change the bucket count (if required) by
calling <code>rehash</code>.</p>
</div>
<div class="paragraph">
<p>The standard leaves a lot of freedom to the implementer to decide how the
number of buckets is chosen, but it does make some requirements based on the
container&#8217;s 'load factor', the number of elements divided by the number of buckets.
Containers also have a 'maximum load factor' which they should try to keep the
load factor below.</p>
</div>
<div class="paragraph">
<p>You can&#8217;t control the bucket count directly but there are two ways to
influence it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify the minimum number of buckets when constructing a container or when calling <code>rehash</code>.</p>
</li>
<li>
<p>Suggest a maximum load factor by calling <code>max_load_factor</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>max_load_factor</code> doesn&#8217;t let you set the maximum load factor yourself, it just
lets you give a <em>hint</em>. And even then, the standard doesn&#8217;t actually
require the container to pay much attention to this value. The only time the
load factor is <em>required</em> to be less than the maximum is following a call to
<code>rehash</code>. But most implementations will try to keep the number of elements
below the max load factor, and set the maximum load factor to be the same as
or close to the hint - unless your hint is unreasonably small or large.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 3. Methods for Controlling Bucket Size</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>All containers</strong></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Construct an empty container with at least <code>n</code> buckets (<code>X</code> is the container type).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X(InputIterator i, InputIterator j, size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Construct an empty container with at least <code>n</code> buckets and insert elements from the range <code>[i, j)</code> (<code>X</code> is the container type).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float load_factor() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">The average number of elements per bucket.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float max_load_factor() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the current maximum load factor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float max_load_factor(float z)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.<br>
<strong>Open-addressing containers:</strong> this function does nothing: users are not allowed to change the maximum load factor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void rehash(size_type n)</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Changes the number of buckets so that there at least <code>n</code> buckets, and so that the load factor is less than the maximum load factor.</p></td>
</tr>
<tr>
<th class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><strong>Open-addressing containers only</strong><br>
<code>boost::unordered_flat_set</code>, <code>boost::unordered_flat_map</code><br>
<code>boost::unordered_node_set</code>, <code>boost::unordered_node_map</code><br></p></th>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><strong>Method</strong></p></th>
<th class="tableblock halign-left valign-middle"><p class="tableblock"><strong>Description</strong></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size_type max_load() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the maximum number of allowed elements in the container before rehash.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A note on <code>max_load</code> for open-addressing containers: the maximum load will be
(<code>max_load_factor() * bucket_count()</code>) right after <code>rehash</code> or on container creation, but may
slightly decrease when erasing elements in high-load situations. For instance, if we
have a <a href="#unordered_flat_map"><code>boost::unordered_flat_map</code></a> with <code>size()</code> almost
at <code>max_load()</code> level and then erase 1,000 elements, <code>max_load()</code> may decrease by around a
few dozen elements. This is done internally by Boost.Unordered in order
to keep its performance stable, and must be taken into account when planning for rehash-free insertions.</p>
</div>
</div>
<div class="sect2">
<h3 id="buckets_iterator_invalidation"><a class="link" href="#buckets_iterator_invalidation">Iterator Invalidation</a></h3>
<div class="paragraph">
<p>It is not specified how member functions other than <code>rehash</code> and <code>reserve</code> affect
the bucket count, although <code>insert</code> can only invalidate iterators
when the insertion causes the container&#8217;s load to be greater than the maximum allowed.
For most implementations this means that <code>insert</code> will only
change the number of buckets when this happens. Iterators can be
invalidated by calls to <code>insert</code>, <code>rehash</code> and <code>reserve</code>.</p>
</div>
<div class="paragraph">
<p>As for pointers and references,
they are never invalidated for node-based containers
(<code>boost::unordered_[multi]set</code>, <code>boost::unordered_[multi]map</code>, <code>boost::unordered_node_set</code>, <code>boost::unordered_node_map</code>),
but they will when rehashing occurs for
<code>boost::unordered_flat_set</code> and <code>boost::unordered_flat_map</code>: this is because
these containers store elements directly into their holding buckets, so
when allocating a new bucket array the elements must be transferred by means of move construction.</p>
</div>
<div class="paragraph">
<p>In a similar manner to using <code>reserve</code> for <code>vector</code>s, it can be a good idea
to call <code>reserve</code> before inserting a large number of elements. This will get
the expensive rehashing out of the way and let you store iterators, safe in
the knowledge that they won&#8217;t be invalidated. If you are inserting <code>n</code>
elements into container <code>x</code>, you could first call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">x</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Note</dt>
<dd>
<p><code>reserve(n)</code> reserves space for at least <code>n</code> elements, allocating enough buckets
so as to not exceed the maximum load factor.</p>
<div class="paragraph">
<p>Because the maximum load factor is defined as the number of elements divided by the total
number of available buckets, this function is logically equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">x</span><span class="p">.</span><span class="n">rehash</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">x</span><span class="p">.</span><span class="n">max_load_factor</span><span class="p">()))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#unordered_map_rehash">reference for more details</a> on the <code>rehash</code> function.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="buckets_fast_closed_addressing_implementation"><a class="link" href="#buckets_fast_closed_addressing_implementation">Fast Closed Addressing Implementation</a></h3>
<style>
  .imageblock > .title {
    text-align: inherit;
  }
</style>
<div class="paragraph">
<p>Boost.Unordered sports one of the fastest implementations of closed addressing, also commonly known as <a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining">separate chaining</a>. An example figure representing the data structure is below:</p>
</div>
<div id="img-bucket-groups" class="imageblock text-center">
<div class="content">
<img src="../diagrams/bucket-groups.png" alt="bucket groups">
</div>
<div class="title">Figure 1. A simple bucket group approach</div>
</div>
<div class="paragraph">
<p>An array of "buckets" is allocated and each bucket in turn points to its own individual linked list. This makes meeting the standard requirements of bucket iteration straight-forward. Unfortunately, iteration of the entire container is often times slow using this layout as each bucket must be examined for occupancy, yielding a time complexity of <code>O(bucket_count() + size())</code> when the standard requires complexity to be <code>O(size())</code>.</p>
</div>
<div class="paragraph">
<p>Canonical standard implementations will wind up looking like the diagram below:</p>
</div>
<div class="imageblock text-center text-center">
<div class="content">
<a class="image" href="../diagrams/singly-linked.png" target="_blank" rel="noopener"><img src="../diagrams/singly-linked.png" alt="singly linked"></a>
</div>
<div class="title">Figure 2. The canonical standard approach</div>
</div>
<div class="paragraph">
<p>It&#8217;s worth noting that this approach is only used by libc++ and libstdc++; the MSVC Dinkumware implementation uses a different one. A more detailed analysis of the standard containers can be found <a href="http://bannalia.blogspot.com/2013/10/implementation-of-c-unordered.html">here</a>.</p>
</div>
<div class="paragraph">
<p>This unusually laid out data structure is chosen to make iteration of the entire container efficient by inter-connecting all of the nodes into a singly-linked list. One might also notice that buckets point to the node <em>before</em> the start of the bucket&#8217;s elements. This is done so that removing elements from the list can be done efficiently without introducing the need for a doubly-linked list. Unfortunately, this data structure introduces a guaranteed extra indirection. For example, to access the first element of a bucket, something like this must be done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="k">const</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_bucket_idx</span><span class="p">(</span><span class="n">hash_function</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="n">node</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span> <span class="c1">// first load</span>
<span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">// second load</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">is_in_bucket</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="c1">// third load</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With a simple bucket group layout, this is all that must be done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="k">const</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">get_bucket_idx</span><span class="p">(</span><span class="n">hash_function</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span> <span class="c1">// first load</span>
<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span> <span class="c1">// second load</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In practice, the extra indirection can have a dramatic performance impact to common operations such as <code>insert</code>, <code>find</code> and <code>erase</code>. But to keep iteration of the container fast, Boost.Unordered introduces a novel data structure, a "bucket group". A bucket group is a fixed-width view of a subsection of the buckets array. It contains a bitmask (a <code>std::size_t</code>) which it uses to track occupancy of buckets and contains two pointers so that it can form a doubly-linked list with non-empty groups. An example diagram is below:</p>
</div>
<div id="img-fca-layout" class="imageblock text-center">
<div class="content">
<img src="../diagrams/fca.png" alt="fca">
</div>
<div class="title">Figure 3. The new layout used by Boost</div>
</div>
<div class="paragraph">
<p>Thus container-wide iteration is turned into traversing the non-empty bucket groups (an operation with constant time complexity) which reduces the time complexity back to <code>O(size())</code>. In total, a bucket group is only 4 words in size and it views <code>sizeof(std::size_t) * CHAR_BIT</code> buckets meaning that for all common implementations, there&#8217;s only 4 bits of space overhead per bucket introduced by the bucket groups.</p>
</div>
<div class="paragraph">
<p>A more detailed description of Boost.Unordered&#8217;s closed-addressing implementation is
given in an
<a href="https://bannalia.blogspot.com/2022/06/advancing-state-of-art-for.html">external article</a>.
For more information on implementation rationale, read the
<a href="#rationale_boostunordered_multiset_and_boostunordered_multimap">corresponding section</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="buckets_open_addressing_implementation"><a class="link" href="#buckets_open_addressing_implementation">Open Addressing Implementation</a></h3>
<div class="paragraph">
<p>The diagram shows the basic internal layout of <code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> and
<code>boost:unordered_flat_set</code>/<code>unordered_node_set</code>.</p>
</div>
<div id="img-foa-layout" class="imageblock text-center">
<div class="content">
<img src="../diagrams/foa.png" alt="foa">
</div>
<div class="title">Figure 4. Open-addressing layout used by Boost.Unordered.</div>
</div>
<div class="paragraph">
<p>As with all open-addressing containers, elements (or pointers to the element nodes in the case of
<code>boost::unordered_node_map</code> and <code>boost::unordered_node_set</code>) are stored directly in the bucket array.
This array is logically divided into 2<sup><em>n</em></sup> <em>groups</em> of 15 elements each.
In addition to the bucket array, there is an associated <em>metadata array</em> with 2<sup><em>n</em></sup>
16-byte words.</p>
</div>
<div id="img-foa-metadata" class="imageblock text-center">
<div class="content">
<img src="../diagrams/foa-metadata.png" alt="foa metadata">
</div>
<div class="title">Figure 5. Breakdown of a metadata word.</div>
</div>
<div class="paragraph">
<p>A metadata word is divided into 15 <em>h</em><sub><em>i</em></sub> bytes (one for each associated
bucket), and an <em>overflow byte</em> (<em>ofw</em> in the diagram). The value of <em>h</em><sub><em>i</em></sub> is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 if the corresponding bucket is empty.</p>
</li>
<li>
<p>1 to encode a special empty bucket called a <em>sentinel</em>, which is used internally to
stop iteration when the container has been fully traversed.</p>
</li>
<li>
<p>If the bucket is occupied, a <em>reduced hash value</em> obtained from the hash value of
the element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When looking for an element with hash value <em>h</em>, SIMD technologies such as
<a href="https://en.wikipedia.org/wiki/SSE2">SSE2</a> and
<a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(Neon)">Neon</a> allow us
to very quickly inspect the full metadata word and look for the reduced value of <em>h</em> among all the
15 buckets with just a handful of CPU instructions: non-matching buckets can be
readily discarded, and those whose reduced hash value matches need be inspected via full
comparison with the corresponding element. If the looked-for element is not present,
the overflow byte is inspected:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the bit in the position <em>h</em> mod 8 is zero, lookup terminates (and the
element is not present).</p>
</li>
<li>
<p>If the bit is set to 1 (the group has been <em>overflowed</em>), further groups are
checked using <a href="https://en.wikipedia.org/wiki/Quadratic_probing"><em>quadratic probing</em></a>, and
the process is repeated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Insertion is algorithmically similar: empty buckets are located using SIMD,
and when going past a full group its corresponding overflow bit is set to 1.</p>
</div>
<div class="paragraph">
<p>In architectures without SIMD support, the logical layout stays the same, but the metadata
word is codified using a technique we call <em>bit interleaving</em>: this layout allows us
to emulate SIMD with reasonably good performance using only standard arithmetic and
logical operations.</p>
</div>
<div id="img-foa-metadata-interleaving" class="imageblock text-center">
<div class="content">
<img src="../diagrams/foa-metadata-interleaving.png" alt="foa metadata interleaving">
</div>
<div class="title">Figure 6. Bit-interleaved metadata word.</div>
</div>
<div class="paragraph">
<p>A more detailed description of Boost.Unordered&#8217;s open-addressing implementation is
given in an
<a href="https://bannalia.blogspot.com/2022/11/inside-boostunorderedflatmap.html">external article</a>.
For more information on implementation rationale, read the
<a href="#rationale_boostunordered_flat_set_and_boostunordered_flat_map">corresponding section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hash_equality"><a class="link" href="#hash_equality">Equality Predicates and Hash Functions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>While the associative containers use an ordering relation to specify how the
elements are stored, the unordered associative containers use an equality
predicate and a hash function. For example, <a href="#unordered_map">boost::unordered_map</a>
is declared as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Mapped</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">&gt;,</span>
    <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span> <span class="k">const</span><span class="p">,</span> <span class="n">Mapped</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">unordered_map</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The hash function comes first as you might want to change the hash function
but not the equality predicate. For example, if you wanted to use the
<a href="http://www.isthe.com/chongo/tech/comp/fnv/" target="_blank" rel="noopener">FNV-1 hash</a> you could write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">hash</span><span class="o">::</span><span class="n">fnv_1</span><span class="o">&gt;</span>
    <span class="n">dictionary</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is an <a href="../../examples/fnv1.hpp" target="_blank" rel="noopener">implementation of FNV-1</a> in the examples directory.</p>
</div>
<div class="paragraph">
<p>If you wish to use a different equality function, you will also need to use a matching hash function. For example, to implement a case insensitive dictionary you need to define a case insensitive equality predicate and hash function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">iequal_to</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">algorithm</span><span class="o">::</span><span class="n">iequals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">ihash</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">locale</span> <span class="n">locale</span><span class="p">;</span>

        <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="n">it</span> <span class="o">!=</span> <span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="n">locale</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which you can then use in a case insensitive dictionary:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">ihash</span><span class="p">,</span> <span class="n">iequal_to</span><span class="o">&gt;</span>
    <span class="n">idictionary</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a simplified version of the example at
<a href="../../examples/case_insensitive.hpp" target="_blank" rel="noopener">/libs/unordered/examples/case_insensitive.hpp</a> which supports other locales and string types.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Be careful when using the equality (<code>==</code>) operator with custom equality
predicates, especially if you&#8217;re using a function pointer. If you compare two
containers with different equality predicates then the result is undefined.
For most stateless function objects this is impossible - since you can only
compare objects with the same equality predicate you know the equality
predicates must be equal. But if you&#8217;re using function pointers or a stateful
equality predicate (e.g. <code>boost::function</code>) then you can get into trouble.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="hash_equality_custom_types"><a class="link" href="#hash_equality_custom_types">Custom Types</a></h3>
<div class="paragraph">
<p>Similarly, a custom hash function can be used for custom types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">point_hash</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">boost</span><span class="o">::</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">point</span><span class="p">,</span> <span class="n">point_hash</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the default hash function is <a href="../../../container_hash/index.html" target="_blank" rel="noopener">Boost.Hash</a>,
we can extend it to support the type so that the hash function doesn&#8217;t need to be explicitly given:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">struct</span> <span class="nc">point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">hash_value</span><span class="p">(</span><span class="n">point</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">seed</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Now the default function objects work.</span>
<span class="n">boost</span><span class="o">::</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="../../../container_hash/index.html" target="_blank" rel="noopener">Boost.Hash documentation</a> for more detail on how to
do this. Remember that it relies on extensions to the standard - so it
won&#8217;t work for other implementations of the unordered associative containers,
you&#8217;ll need to explicitly use Boost.Hash.</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 4 Methods for accessing the hash and equality functions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-middle">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasher hash_function() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the container&#8217;s hash function.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>key_equal key_eq() const</code></p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">Returns the container&#8217;s key equality function..</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="comparison"><a class="link" href="#comparison">Comparison with Associative Containers</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 5 Interface differences</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Associative Containers</th>
<th class="tableblock halign-left valign-top">Unordered Associative Containers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parameterized by an ordering relation <code>Compare</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parameterized by a function object <code>Hash</code> and an equivalence relation <code>Pred</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys can be compared using <code>key_compare</code> which is accessed by member function <code>key_comp()</code>, values can be compared using <code>value_compare</code> which is accessed by member function <code>value_comp()</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys can be hashed using <code>hasher</code> which is accessed by member function <code>hash_function()</code>, and checked for equality using <code>key_equal</code> which is accessed by member function <code>key_eq()</code>. There is no function object for compared or hashing values.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructors have optional extra parameters for the comparison object.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructors have optional extra parameters for the initial minimum number of buckets, a hash function and an equality object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys <code>k1</code>, <code>k2</code> are considered equivalent if <code>!Compare(k1, k2) &amp;&amp; !Compare(k2, k1)</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keys <code>k1</code>, <code>k2</code> are considered equivalent if <code>Pred(k1, k2)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Member function <code>lower_bound(k)</code> and <code>upper_bound(k)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No equivalent. Since the elements aren&#8217;t ordered <code>lower_bound</code> and <code>upper_bound</code> would be meaningless.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>equal_range(k)</code> returns an empty range at the position that <code>k</code> would be inserted if <code>k</code> isn&#8217;t present in the container.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>equal_range(k)</code> returns a range at the end of the container if <code>k</code> isn&#8217;t present in the container. It can&#8217;t return a positioned range as <code>k</code> could be inserted into multiple place.<br>
<strong>Closed-addressing containers:</strong> To find out the bucket that <code>k</code> would be inserted into use <code>bucket(k)</code>. But remember that an insert can cause the container to rehash - meaning that the element can be inserted into a different bucket.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iterator</code>, <code>const_iterator</code> are of the bidirectional category.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iterator</code>, <code>const_iterator</code> are of at least the forward category.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterators, pointers and references to the container&#8217;s elements are never invalidated.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#buckets_iterator_invalidation">Iterators can be invalidated by calls to insert or rehash</a>.<br>
<strong>Node-based containers:</strong> Pointers and references to the container&#8217;s elements are never invalidated.<br>
<strong>Flat containers:</strong> Pointers and references to the container&#8217;s elements are invalidated when rehashing occurs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterators iterate through the container in the order defined by the comparison object.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterators iterate through the container in an arbitrary order, that can change as elements are inserted, although equivalent elements are always adjacent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">No equivalent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Closed-addressing containers:</strong> Local iterators can be used to iterate through individual buckets. (The order of local iterators and iterators aren&#8217;t required to have any correspondence.)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can be compared using the <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> operators.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can be compared using the <code>==</code> and <code>!=</code> operators.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">When inserting with a hint, implementations are permitted to ignore the hint.</p></td>
</tr>
</tbody>
</table>
<hr>
<table class="tableblock frame-all grid-rows stretch">
<caption class="title">Table 6 Complexity Guarantees</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Operation</th>
<th class="tableblock halign-left valign-top">Associative Containers</th>
<th class="tableblock halign-left valign-top">Unordered Associative Containers</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Construction of empty container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<em>n</em>) where <em>n</em> is the minimum number of buckets.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Construction of container from a range of <em>N</em> elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<em>N log N</em>), O(<em>N</em>) if the range is sorted with <code>value_comp()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case O(<em>N</em>), worst case O(<em>N<sup>2</sup></em>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Insert a single element</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case constant, worst case linear</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Insert a single element with a hint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Amortized constant if <code>t</code> elements inserted right after hint, logarithmic otherwise</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case constant, worst case linear (ie. the same as a normal insert).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inserting a range of <em>N</em> elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>N</em> log(<code>size()</code> + <em>N</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case O(<em>N</em>), worst case O(<em>N</em> * <code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Erase by key, <code>k</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(log(<code>size()</code>) + <code>count(k)</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(<code>count(k)</code>), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Erase a single element by iterator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Amortized constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(1), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Erase a range of <em>N</em> elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(log(<code>size()</code>) + <em>N</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(<em>N</em>), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clearing the container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<code>size()</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Find</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(1), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Count</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">O(log(<code>size()</code>) + <code>count(k)</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(1), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>equal_range(k)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average case: O(<code>count(k)</code>), Worst case: O(<code>size()</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lower_bound</code>,<code>upper_bound</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">logarithmic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">n/a</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="compliance"><a class="link" href="#compliance">Standard Compliance</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="compliance_closed_addressing_containers"><a class="link" href="#compliance_closed_addressing_containers">Closed-addressing containers</a></h3>
<div class="paragraph">
<p><code>unordered_[multi]set</code> and <code>unordered_[multi]map</code> are intended to provide a conformant
implementation of the C++20 standard that will work with C++98 upwards.
This wide compatibility does mean some compromises have to be made.
With a compiler and library that fully support C++11, the differences should
be minor.</p>
</div>
<div class="sect3">
<h4 id="compliance_move_emulation"><a class="link" href="#compliance_move_emulation">Move emulation</a></h4>
<div class="paragraph">
<p>Support for move semantics is implemented using Boost.Move. If rvalue
references are available it will use them, but if not it uses a close,
but imperfect emulation. On such compilers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Non-copyable objects can be stored in the containers.
They can be constructed in place using <code>emplace</code>, or if they support
Boost.Move, moved into place.</p>
</li>
<li>
<p>The containers themselves are not movable.</p>
</li>
<li>
<p>Argument forwarding is not perfect.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="compliance_use_of_allocators"><a class="link" href="#compliance_use_of_allocators">Use of allocators</a></h4>
<div class="paragraph">
<p>C++11 introduced a new allocator system. It&#8217;s backwards compatible due to
the lax requirements for allocators in the old standard, but might need
some changes for allocators which worked with the old versions of the
unordered containers.
It uses a traits class, <code>allocator_traits</code> to handle the allocator
adding extra functionality, and making some methods and types optional.
During development a stable release of
<code>allocator_traits</code> wasn&#8217;t available so an internal partial implementation
is always used in this version. Hopefully a future version will use the
standard implementation where available.</p>
</div>
<div class="paragraph">
<p>The member functions <code>construct</code>, <code>destroy</code> and <code>max_size</code> are now
optional, if they&#8217;re not available a fallback is used.
A full implementation of <code>allocator_traits</code> requires sophisticated
member function detection so that the fallback is used whenever the
member function call is not well formed.
This requires support for SFINAE expressions, which are available on
GCC from version 4.4 and Clang.</p>
</div>
<div class="paragraph">
<p>On other compilers, there&#8217;s just a test to see if the allocator has
a member, but no check that it can be called. So rather than using a
fallback there will just be a compile error.</p>
</div>
<div class="paragraph">
<p><code>propagate_on_container_copy_assignment</code>,
<code>propagate_on_container_move_assignment</code>,
<code>propagate_on_container_swap</code> and
<code>select_on_container_copy_construction</code> are also supported.
Due to imperfect move emulation, some assignments might check
<code>propagate_on_container_copy_assignment</code> on some compilers and
<code>propagate_on_container_move_assignment</code> on others.</p>
</div>
</div>
<div class="sect3">
<h4 id="compliance_constructiondestruction_using_allocators"><a class="link" href="#compliance_constructiondestruction_using_allocators">Construction/Destruction using allocators</a></h4>
<div class="paragraph">
<p>The following support is required for full use of C++11 style
construction/destruction:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Variadic templates.</p>
</li>
<li>
<p>Piecewise construction of <code>std::pair</code>.</p>
</li>
<li>
<p>Either <code>std::allocator_traits</code> or expression SFINAE.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is detected using Boost.Config. The macro
<code>BOOST_UNORDERED_CXX11_CONSTRUCTION</code> will be set to 1 if it is found, or 0
otherwise.</p>
</div>
<div class="paragraph">
<p>When this is the case <code>allocator_traits::construct</code> and
<code>allocator_traits::destroy</code> will always be used, apart from when piecewise
constructing a <code>std::pair</code> using <code>boost::tuple</code> (see <a href="#compliance_pairs">below</a>), but that should be easily avoided.</p>
</div>
<div class="paragraph">
<p>When support is not available <code>allocator_traits::construct</code> and
<code>allocator_traits::destroy</code> are never called.</p>
</div>
</div>
<div class="sect3">
<h4 id="compliance_pointer_traits"><a class="link" href="#compliance_pointer_traits">Pointer Traits</a></h4>
<div class="paragraph">
<p><code>pointer_traits</code> aren&#8217;t used. Instead, pointer types are obtained from
rebound allocators, this can cause problems if the allocator can&#8217;t be
used with incomplete types. If <code>const_pointer</code> is not defined in the
allocator, <code>boost::pointer_to_other&lt;pointer, const value_type&gt;::type</code>
is used to obtain a const pointer.</p>
</div>
</div>
<div class="sect3">
<h4 id="compliance_pairs"><a class="link" href="#compliance_pairs">Pairs</a></h4>
<div class="paragraph">
<p>Since the containers use <code>std::pair</code> they&#8217;re limited to the version
from the current standard library. But since C++11 <code>std::pair</code>'s
<code>piecewise_construct</code> based constructor is very useful, <code>emplace</code>
emulates it with a <code>piecewise_construct</code> in the <code>boost::unordered</code>
namespace. So for example, the following will work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">boost</span><span class="o">::</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>

<span class="n">x</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">unordered</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="s">"key"</span><span class="p">),</span> <span class="n">boost</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Older drafts of the standard also supported variadic constructors
for <code>std::pair</code>, where the first argument would be used for the
first part of the pair, and the remaining for the second part.</p>
</div>
</div>
<div class="sect3">
<h4 id="compliance_miscellaneous"><a class="link" href="#compliance_miscellaneous">Miscellaneous</a></h4>
<div class="paragraph">
<p>When swapping, <code>Pred</code> and <code>Hash</code> are not currently swapped by calling
<code>swap</code>, their copy constructors are used. As a consequence when swapping
an exception may be thrown from their copy constructor.</p>
</div>
<div class="paragraph">
<p>Variadic constructor arguments for <code>emplace</code> are only used when both
rvalue references and variadic template parameters are available.
Otherwise <code>emplace</code> can only take up to 10 constructors arguments.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="compliance_open_addressing_containers"><a class="link" href="#compliance_open_addressing_containers">Open-addressing containers</a></h3>
<div class="paragraph">
<p>The C++ standard does not currently provide any open-addressing container
specification to adhere to, so <code>boost::unordered_flat_set</code>/<code>unordered_node_set</code> and
<code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> take inspiration from <code>std::unordered_set</code> and
<code>std::unordered_map</code>, respectively, and depart from their interface where
convenient or as dictated by their internal data structure, which is
radically different from that imposed by the standard (closed addressing).</p>
</div>
<div class="paragraph">
<p>Open-addressing containers provided by Boost.Unordered only work with reasonably
compliant C++11 (or later) compilers. Language-level features such as move semantics
and variadic template parameters are then not emulated.
The containers are fully <a href="https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer" target="_blank" rel="noopener">AllocatorAware</a>.</p>
</div>
<div class="paragraph">
<p>The main differences with C++ unordered associative containers are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In general:</p>
<div class="ulist">
<ul>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> returns <code>void</code> instead of an iterator to the following element.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>).</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user. The maximum load,
exposed through the public function <code>max_load</code>, may decrease on erasure under high-load conditions.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Flat containers (<code>boost::unordered_flat_set</code> and <code>boost::unordered_flat_map</code>):</p>
<div class="ulist">
<ul>
<li>
<p><code>value_type</code> must be move-constructible.</p>
</li>
<li>
<p>Pointer stability is not kept under rehashing.</p>
</li>
<li>
<p>There is no API for node extraction/insertion.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="benchmarks"><a class="link" href="#benchmarks">Benchmarks</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="benchmarks_boostunordered_multiset"><a class="link" href="#benchmarks_boostunordered_multiset">boost::unordered_[multi]set</a></h3>
<div class="paragraph">
<p>All benchmarks were created using <code>unordered_set&lt;unsigned int&gt;</code> (non-duplicate) and <code>unordered_multiset&lt;unsigned int&gt;</code> (duplicate). The source code can be <a href="https://github.com/boostorg/boost_unordered_benchmarks/tree/boost_unordered_set" target="_blank" rel="noopener">found here</a>.</p>
</div>
<div class="paragraph">
<p>The insertion benchmarks insert <code>n</code> random values, where <code>n</code> is between 10,000 and 3 million. For the duplicated benchmarks, the same random values are repeated an average of 5 times.</p>
</div>
<div class="paragraph">
<p>The erasure benchmarks erase all <code>n</code> elements randomly until the container is empty.</p>
</div>
<div class="paragraph">
<p>The successful lookup benchmarks are done by looking up all <code>n</code> values, in their original insertion order.</p>
</div>
<div class="paragraph">
<p>The unsuccessful lookup benchmarks use <code>n</code> randomly generated integers but using a different seed value.</p>
</div>
<div class="sect3">
<h4 id="benchmarks_gcc_11_libstdc_v3_x64"><a class="link" href="#benchmarks_gcc_11_libstdc_v3_x64">GCC 11 + libstdc++-v3, x64</a></h4>
<div class="sect4">
<h5 id="benchmarks_insertion"><a class="link" href="#benchmarks_insertion">Insertion</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running insertion.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice.png" alt="running insertion.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20non-unique.png" alt="running%20insertion.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20non-unique%205.png" alt="running%20insertion.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice norehash.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20norehash.png" alt="running%20insertion.xlsx.practice norehash" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice norehash non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20norehash%20non-unique.png" alt="running%20insertion.xlsx.practice norehash non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice norehash non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/running%20insertion.xlsx.practice%20norehash%20non-unique%205.png" alt="running%20insertion.xlsx.practice norehash non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5,<br>
prior <code>reserve</code></p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_erasure"><a class="link" href="#benchmarks_erasure">Erasure</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice.png" alt="scattered%20erasure.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice%20non-unique.png" alt="scattered%20erasure.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20erasure.xlsx.practice%20non-unique%205.png" alt="scattered%20erasure.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_successful_lookup"><a class="link" href="#benchmarks_successful_lookup">Successful Lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice.png" alt="scattered%20successful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20successful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20successful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20successful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_unsuccessful_lookup"><a class="link" href="#benchmarks_unsuccessful_lookup">Unsuccessful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/gcc/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_12_libc_x64"><a class="link" href="#benchmarks_clang_12_libc_x64">Clang 12 + libc++, x64</a></h4>
<div class="sect4">
<h5 id="benchmarks_insertion_2"><a class="link" href="#benchmarks_insertion_2">Insertion</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice.png" alt="running%20insertion.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20non-unique.png" alt="running%20insertion.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20non-unique%205.png" alt="running%20insertion.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice norehash.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20norehash.png" alt="running%20insertion.xlsx.practice norehash" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice norehash non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20norehash%20non-unique.png" alt="running%20insertion.xlsx.practice norehash non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice norehash non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/running%20insertion.xlsx.practice%20norehash%20non-unique%205.png" alt="running%20insertion.xlsx.practice norehash non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5,<br>
prior <code>reserve</code></p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_erasure_2"><a class="link" href="#benchmarks_erasure_2">Erasure</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice.png" alt="scattered%20erasure.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice%20non-unique.png" alt="scattered%20erasure.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20erasure.xlsx.practice%20non-unique%205.png" alt="scattered%20erasure.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_successful_lookup_2"><a class="link" href="#benchmarks_successful_lookup_2">Successful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice.png" alt="scattered%20successful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20successful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20successful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20successful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_unsuccessful_lookup_2"><a class="link" href="#benchmarks_unsuccessful_lookup_2">Unsuccessful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/clang_libcpp/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="benchmarks_visual_studio_2019_dinkumware_x64"><a class="link" href="#benchmarks_visual_studio_2019_dinkumware_x64">Visual Studio 2019 + Dinkumware, x64</a></h4>
<div class="sect4">
<h5 id="benchmarks_insertion_3"><a class="link" href="#benchmarks_insertion_3">Insertion</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice.png" alt="running%20insertion.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20non-unique.png" alt="running%20insertion.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20non-unique%205.png" alt="running%20insertion.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice norehash.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20norehash.png" alt="running%20insertion.xlsx.practice norehash" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice norehash non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20norehash%20non-unique.png" alt="running%20insertion.xlsx.practice norehash non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice norehash non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/running%20insertion.xlsx.practice%20norehash%20non-unique%205.png" alt="running%20insertion.xlsx.practice norehash non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
prior <code>reserve</code></p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5,<br>
prior <code>reserve</code></p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_erasure_3"><a class="link" href="#benchmarks_erasure_3">Erasure</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice.png" alt="scattered%20erasure.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice%20non-unique.png" alt="scattered%20erasure.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20erasure.xlsx.practice%20non-unique%205.png" alt="scattered%20erasure.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_successful_lookup_3"><a class="link" href="#benchmarks_successful_lookup_3">Successful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice.png" alt="scattered%20successful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20successful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20successful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20successful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="benchmarks_unsuccessful_lookup_3"><a class="link" href="#benchmarks_unsuccessful_lookup_3">Unsuccessful lookup</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice non-unique.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice non-unique 5.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-set/vs/scattered%20unsuccessful%20looukp.xlsx.practice%20non-unique%205.png" alt="scattered%20unsuccessful%20looukp.xlsx.practice non unique 5" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">non-duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">duplicate elements,<br>
max load factor 5</p></th>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="benchmarks_boostunordered_flatnode_map"><a class="link" href="#benchmarks_boostunordered_flatnode_map">boost::unordered_(flat|node)_map</a></h3>
<div class="paragraph">
<p>All benchmarks were created using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="https://abseil.io/docs/cpp/guides/container" target="_blank" rel="noopener">absl::flat_hash_map</a>&lt;uint64_t, uint64_t&gt;</code></p>
</li>
<li>
<p><code>boost::unordered_map&lt;uint64_t, uint64_t&gt;</code></p>
</li>
<li>
<p><code>boost::unordered_flat_map&lt;uint64_t, uint64_t&gt;</code></p>
</li>
<li>
<p><code>boost::unordered_node_map&lt;uint64_t, uint64_t&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The source code can be <a href="https://github.com/boostorg/boost_unordered_benchmarks/tree/boost_unordered_flat_map" target="_blank" rel="noopener">found here</a>.</p>
</div>
<div class="paragraph">
<p>The insertion benchmarks insert <code>n</code> random values, where <code>n</code> is between 10,000 and 10 million.</p>
</div>
<div class="paragraph">
<p>The erasure benchmarks erase traverse the <code>n</code> elements and erase those with odd key (50% on average).</p>
</div>
<div class="paragraph">
<p>The successful lookup benchmarks are done by looking up all <code>n</code> values, in their original insertion order.</p>
</div>
<div class="paragraph">
<p>The unsuccessful lookup benchmarks use <code>n</code> randomly generated integers but using a different seed value.</p>
</div>
<div class="sect3">
<h4 id="benchmarks_gcc_11_x64"><a class="link" href="#benchmarks_gcc_11_x64">GCC 11, x64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x64/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x64/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x64/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x64/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x64/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x64/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_12_x64"><a class="link" href="#benchmarks_clang_12_x64">Clang 12, x64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x64/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x64/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x64/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x64/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x64/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x64/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_visual_studio_2019_x64"><a class="link" href="#benchmarks_visual_studio_2019_x64">Visual Studio 2019, x64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x64/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x64/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x64/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x64/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x64/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x64/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_12_arm64"><a class="link" href="#benchmarks_clang_12_arm64">Clang 12, ARM64</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-arm64/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-arm64/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-arm64/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-arm64/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-arm64/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-arm64/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-arm64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-arm64/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_gcc_11_x86"><a class="link" href="#benchmarks_gcc_11_x86">GCC 11, x86</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x86/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x86/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x86/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x86/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x86/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x86/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/gcc-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/gcc-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_clang_12_x86"><a class="link" href="#benchmarks_clang_12_x86">Clang 12, x86</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x86/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x86/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x86/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x86/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x86/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x86/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/clang-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/clang-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="benchmarks_visual_studio_2019_x86"><a class="link" href="#benchmarks_visual_studio_2019_x86">Visual Studio 2019, x86</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x86/Running%20insertion.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x86/Running%20insertion.xlsx.plot.png" alt="Running%20insertion.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x86/Running%20erasure.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x86/Running%20erasure.xlsx.plot.png" alt="Running%20erasure.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x86/Scattered%20successful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x86/Scattered%20successful%20looukp.xlsx.plot.png" alt="Scattered%20successful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
<td class="tableblock halign-center valign-middle"><div class="content"><div class="imageblock">
<div class="content">
<a class="image" href="../diagrams/benchmarks-flat_map/vs-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" target="_blank" rel="noopener"><img src="../diagrams/benchmarks-flat_map/vs-x86/Scattered%20unsuccessful%20looukp.xlsx.plot.png" alt="Scattered%20unsuccessful%20looukp.xlsx.plot" width="250"></a>
</div>
</div></div></td>
</tr>
<tr>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running insertion</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">running erasure</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">successful lookup</p></th>
<th class="tableblock halign-center valign-middle"><p class="tableblock">unsuccessful lookup</p></th>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale"><a class="link" href="#rationale">Implementation Rationale</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="rationale_closed_addressing_containers"><a class="link" href="#rationale_closed_addressing_containers">Closed-addressing containers</a></h3>
<div class="paragraph">
<p><code>boost::unordered_[multi]set</code> and <code>boost::unordered_[multi]map</code>
adhere to the standard requirements for unordered associative
containers, so the interface was fixed. But there are
still some implementation decisions to make. The priorities are
conformance to the standard and portability.</p>
</div>
<div class="paragraph">
<p>The <a href="http://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">Wikipedia article on hash tables</a>
has a good summary of the implementation issues for hash tables in general.</p>
</div>
<div class="sect3">
<h4 id="rationale_data_structure"><a class="link" href="#rationale_data_structure">Data Structure</a></h4>
<div class="paragraph">
<p>By specifying an interface for accessing the buckets of the container the
standard pretty much requires that the hash table uses closed addressing.</p>
</div>
<div class="paragraph">
<p>It would be conceivable to write a hash table that uses another method. For
example, it could use open addressing, and use the lookup chain to act as a
bucket but there are some serious problems with this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The standard requires that pointers to elements aren&#8217;t invalidated, so
the elements can&#8217;t be stored in one array, but will need a layer of
indirection instead - losing the efficiency and most of the memory gain,
the main advantages of open addressing.</p>
</li>
<li>
<p>Local iterators would be very inefficient and may not be able to
meet the complexity requirements.</p>
</li>
<li>
<p>There are also the restrictions on when iterators can be invalidated. Since
open addressing degrades badly when there are a high number of collisions the
restrictions could prevent a rehash when it&#8217;s really needed. The maximum load
factor could be set to a fairly low value to work around this - but the
standard requires that it is initially set to 1.0.</p>
</li>
<li>
<p>And since the standard is written with a eye towards closed
addressing, users will be surprised if the performance doesn&#8217;t reflect that.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So closed addressing is used.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale_number_of_buckets"><a class="link" href="#rationale_number_of_buckets">Number of Buckets</a></h4>
<div class="paragraph">
<p>There are two popular methods for choosing the number of buckets in a hash
table. One is to have a prime number of buckets, another is to use a power
of 2.</p>
</div>
<div class="paragraph">
<p>Using a prime number of buckets, and choosing a bucket by using the modulus
of the hash function&#8217;s result will usually give a good result. The downside
is that the required modulus operation is fairly expensive. This is what the
containers used to do in most cases.</p>
</div>
<div class="paragraph">
<p>Using a power of 2 allows for much quicker selection of the bucket to use,
but at the expense of losing the upper bits of the hash value. For some
specially designed hash functions it is possible to do this and still get a
good result but as the containers can take arbitrary hash functions this can&#8217;t
be relied on.</p>
</div>
<div class="paragraph">
<p>To avoid this a transformation could be applied to the hash function, for an
example see
<a href="http://web.archive.org/web/20121102023700/http://www.concentric.net/~Ttwang/tech/inthash.htm" target="_blank" rel="noopener">Thomas Wang&#8217;s article on integer hash functions</a>.
Unfortunately, a transformation like Wang&#8217;s requires knowledge of the number
of bits in the hash value, so it was only used when <code>size_t</code> was 64 bit.</p>
</div>
<div class="paragraph">
<p>Since release 1.79.0, <a href="https://en.wikipedia.org/wiki/Hash_function#Fibonacci_hashing">Fibonacci hashing</a>
is used instead. With this implementation, the bucket number is determined
by using <code>(h * m) &gt;&gt; (w - k)</code>, where <code>h</code> is the hash value, <code>m</code> is <code>2^w</code> divided
by the golden ratio, <code>w</code> is the word size (32 or 64), and <code>2^k</code> is the
number of buckets. This provides a good compromise between speed and
distribution.</p>
</div>
<div class="paragraph">
<p>Since release 1.80.0, prime numbers are chosen for the number of buckets in
tandem with sophisticated modulo arithmetic. This removes the need for "mixing"
the result of the user&#8217;s hash function as was used for release 1.79.0.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rationale_open_addresing_containers"><a class="link" href="#rationale_open_addresing_containers">Open-addresing containers</a></h3>
<div class="paragraph">
<p>The C++ standard specification of unordered associative containers impose
severe limitations on permissible implementations, the most important being
that closed addressing is implicitly assumed. Slightly relaxing this specification
opens up the possibility of providing container variations taking full
advantage of open-addressing techniques.</p>
</div>
<div class="paragraph">
<p>The design of <code>boost::unordered_flat_set</code>/<code>unordered_node_set</code> and <code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> has been
guided by Peter Dimov&#8217;s <a href="https://pdimov.github.io/articles/unordered_dev_plan.html" target="_blank" rel="noopener">Development Plan for Boost.Unordered</a>.
We discuss here the most relevant principles.</p>
</div>
<div class="sect3">
<h4 id="rationale_hash_function"><a class="link" href="#rationale_hash_function">Hash function</a></h4>
<div class="paragraph">
<p>Given its rich functionality and cross-platform interoperability,
<code>boost::hash</code> remains the default hash function of open-addressing containers.
As it happens, <code>boost::hash</code> for integral and other basic types does not possess
the statistical properties required by open addressing; to cope with this,
we implement a post-mixing stage:</p>
</div>
<div class="paragraph">
<p>&#160;&#160;&#160;&#160; <em>a</em> &#8592; <em>h</em> <strong>mulx</strong> <em>C</em>,<br>
&#160;&#160;&#160;&#160; <em>h</em> &#8592; <strong>high</strong>(<em>a</em>) <strong>xor</strong> <strong>low</strong>(<em>a</em>),</p>
</div>
<div class="paragraph">
<p>where <strong>mulx</strong> is an <em>extended multiplication</em> (128 bits in 64-bit architectures, 64 bits in 32-bit environments),
and <strong>high</strong> and <strong>low</strong> are the upper and lower halves of an extended word, respectively.
In 64-bit architectures, <em>C</em> is the integer part of 2<sup>64</sup>&#8725;<a href="https://en.wikipedia.org/wiki/Golden_ratio"><em>&phi;</em></a>,
whereas in 32 bits <em>C</em> = 0xE817FB2Du has been obtained from <a href="https://arxiv.org/abs/2001.05304" target="_blank" rel="noopener">Steele and Vigna (2021)</a>.</p>
</div>
<div class="paragraph">
<p>When using a hash function directly suitable for open addressing, post-mixing can be opted out by via a dedicated <a href="#hash_traits_hash_is_avalanching"><code>hash_is_avalanching</code></a>trait.
<code>boost::hash</code> specializations for string types are marked as avalanching.</p>
</div>
</div>
<div class="sect3">
<h4 id="rationale_platform_interoperability"><a class="link" href="#rationale_platform_interoperability">Platform interoperability</a></h4>
<div class="paragraph">
<p>The observable behavior of <code>boost::unordered_flat_set</code>/<code>unordered_node_set</code> and <code>boost::unordered_flat_map</code>/<code>unordered_node_map</code> is deterministically
identical across different compilers as long as their <code>std::size_type</code>s are the same size and the user-provided
hash function and equality predicate are also interoperable
&#8212;this includes elements being ordered in exactly the same way for the same sequence of
operations.</p>
</div>
<div class="paragraph">
<p>Although the implementation internally uses SIMD technologies, such as <a href="https://en.wikipedia.org/wiki/SSE2" target="_blank" rel="noopener">SSE2</a>
and <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(NEON)" target="_blank" rel="noopener">Neon</a>, when available,
this does not affect interoperatility. For instance, the behavior is the same
for Visual Studio on an x64-mode Intel CPU with SSE2 and for GCC on an IBM s390x without any supported SIMD technology.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference"><a class="link" href="#reference">Reference</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="unordered_map"><a class="link" href="#unordered_map">Class template unordered_map</a></h3>
<div class="paragraph">
<p><code>boost::unordered_map</code> — An unordered associative container that associates unique keys with another value.</p>
</div>
<div class="sect3">
<h4 id="unordered_map_synopsis"><a class="link" href="#unordered_map_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_map_default_constructor">unordered_map</a>();
    explicit <a href="#unordered_map_bucket_count_constructor">unordered_map</a>(size_type n,
                           const hasher&amp; hf = hasher(),
                           const key_equal&amp; eql = key_equal(),
                           const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor">unordered_map</a>(InputIterator f, InputIterator l,
                    size_type n = <em>implementation-defined</em>,
                    const hasher&amp; hf = hasher(),
                    const key_equal&amp; eql = key_equal(),
                    const allocator_type&amp; a = allocator_type());
    <a href="#unordered_map_copy_constructor">unordered_map</a>(const unordered_map&amp; other);
    <a href="#unordered_map_move_constructor">unordered_map</a>(unordered_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_allocator">unordered_map</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_map_allocator_constructor">unordered_map</a>(const Allocator&amp; a);
    <a href="#unordered_map_copy_constructor_with_allocator">unordered_map</a>(const unordered_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_map_move_constructor_with_allocator">unordered_map</a>(unordered_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_map_initializer_list_constructor">unordered_map</a>(std::initializer_list&lt;value_type&gt; il,
                  size_type n = <em>implementation-defined</em>
                  const hasher&amp; hf = hasher(),
                  const key_equal&amp; eql = key_equal(),
                  const allocator_type&amp; a = allocator_type());
    <a href="#unordered_map_bucket_count_constructor_with_allocator">unordered_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_map_bucket_count_constructor_with_hasher_and_allocator">unordered_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                    const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);
    <a href="#unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                  const allocator_type&amp; a);
    <a href="#unordered_map_destructor">~unordered_map</a>();
    unordered_map&amp; <a href="#unordered_map_copy_assignment">operator=</a>(const unordered_map&amp; other);
    unordered_map&amp; <a href="#unordered_map_move_assignment">operator=</a>(unordered_map&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_map&amp; <a href="#unordered_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class P&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_map_emplace_insert">insert</a>(P&amp;&amp; obj);
    iterator       <a href="#unordered_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_map_emplace_insert_with_hint">insert</a>(const_iterator hint, P&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      iterator <a href="#unordered_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      iterator <a href="#unordered_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);

    node_type <a href="#unordered_map_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_map_extract_by_key">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_map_extract_by_key">extract</a>(K&amp;&amp; k);
    insert_return_type <a href="#unordered_map_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator           <a href="#unordered_map_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_map_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_map_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_map_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_map_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_map_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_map_swap">swap</a>(unordered_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_map_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_map_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_map_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_map_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(key_type&amp;&amp; k);
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_map_operator">operator[]</a>(K&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_map_at">at</a>(const key_type&amp; k) const;
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_map_at">at</a>(const K&amp; k);
    template&lt;class K&gt; const mapped_type&amp; <a href="#unordered_map_at">at</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_map_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_map_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_map_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_map_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_map_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_map_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_map_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_map_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_map_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_map_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_map_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_map_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_map(InputIterator, InputIterator, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_map_deduction_guides"><em>see below</em></a>,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash, Pred,
                       Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                  typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                  Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_map(InputIterator, InputIterator, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_map(InputIterator, InputIterator, Allocator)
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_map(InputIterator, InputIterator, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_map&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                       std::equal_to&lt;<a href="#unordered_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type,
                  Allocator)
      -&gt; unordered_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                  Allocator)
      -&gt; unordered_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_map_operator_2">operator==</a>(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_map_operator_3">operator!=</a>(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_map_swap_2">swap</a>(unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_map_erase_if">erase_if</a>(unordered_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_description"><a class="link" href="#unordered_map_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_typedefs"><a class="link" href="#unordered_map_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">pointer</span> <span class="n">pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">const_pointer</span> <span class="n">const_pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">size_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">difference_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_map for details.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Structure returned by inserting node_type.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_constructors"><a class="link" href="#unordered_map_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_map_default_constructor"><a class="link" href="#unordered_map_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_count_constructor"><a class="link" href="#unordered_map_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor"><a class="link" href="#unordered_map_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_constructor"><a class="link" href="#unordered_map_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_constructor"><a class="link" href="#unordered_map_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_map_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_allocator_constructor"><a class="link" href="#unordered_map_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_map</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_constructor_with_allocator"><a class="link" href="#unordered_map_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_constructor_with_allocator"><a class="link" href="#unordered_map_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor"><a class="link" href="#unordered_map_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_map_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_map_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_map_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_map_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_map_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_map_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_destructor"><a class="link" href="#unordered_map_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_assignment"><a class="link" href="#unordered_map_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_map_copy_assignment"><a class="link" href="#unordered_map_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_assignment"><a class="link" href="#unordered_map_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_initializer_list_assignment"><a class="link" href="#unordered_map_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_iterators"><a class="link" href="#unordered_map_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_map_begin"><a class="link" href="#unordered_map_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_end"><a class="link" href="#unordered_map_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cbegin"><a class="link" href="#unordered_map_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cend"><a class="link" href="#unordered_map_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_size_and_capacity"><a class="link" href="#unordered_map_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_map_empty"><a class="link" href="#unordered_map_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_size"><a class="link" href="#unordered_map_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_max_size"><a class="link" href="#unordered_map_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_modifiers"><a class="link" href="#unordered_map_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_map_emplace"><a class="link" href="#unordered_map_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_emplace_hint"><a class="link" href="#unordered_map_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_insert"><a class="link" href="#unordered_map_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_insert"><a class="link" href="#unordered_map_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_emplace_insert"><a class="link" href="#unordered_map_emplace_insert">Emplace Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace(std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_copy_insert_with_hint"><a class="link" href="#unordered_map_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_move_insert_with_hint"><a class="link" href="#unordered_map_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_emplace_insert_with_hint"><a class="link" href="#unordered_map_emplace_insert_with_hint">Emplace Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_iterator_range"><a class="link" href="#unordered_map_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_initializer_list"><a class="link" href="#unordered_map_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_try_emplace"><a class="link" href="#unordered_map_try_emplace">try_emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_map_emplace">emplace</a> except the <code>value_type</code> is constructed using:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>instead of <a href="#unordered_map_emplace">emplace</a> which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.</p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_try_emplace_with_hint"><a class="link" href="#unordered_map_try_emplace_with_hint">try_emplace with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_map_emplace_hint">emplace_hint</a> except the <code>value_type</code> is constructed using:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>instead of <a href="#unordered_map_emplace_hint">emplace_hint</a> which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.</p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.</p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_or_assign"><a class="link" href="#unordered_map_insert_or_assign">insert_or_assign</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_or_assign_with_hint"><a class="link" href="#unordered_map_insert_or_assign_with_hint">insert_or_assign with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_extract_by_iterator"><a class="link" href="#unordered_map_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_multimap</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_extract_by_key"><a class="link" href="#unordered_map_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_multimap</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code>  overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_with_node_handle"><a class="link" href="#unordered_map_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> equal to <code>end()</code> and <code>node</code> empty.<br></p>
<div class="paragraph">
<p>Otherwise if there was already an element with an equivalent key, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> pointing to a matching element and <code>node</code> contains the node from <code>nh</code>.<br></p>
</div>
<div class="paragraph">
<p>Otherwise if the insertion succeeded, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>true</code>, <code>position</code> pointing to the newly inserted element and <code>node</code> empty.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multimap</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_insert_with_hint_and_node_handle"><a class="link" href="#unordered_map_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p>If there is already an element in the container with an equivalent key has no effect on <code>nh</code> (i.e. <code>nh</code> still contains the node.)</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>If there was already an element in the container with an equivalent key returns an iterator pointing to that.<br></p>
</div>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multimap</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_by_position"><a class="link" href="#unordered_map_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_by_key"><a class="link" href="#unordered_map_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_range"><a class="link" href="#unordered_map_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_quick_erase"><a class="link" href="#unordered_map_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_erase_return_void"><a class="link" href="#unordered_map_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_swap"><a class="link" href="#unordered_map_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_clear"><a class="link" href="#unordered_map_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">clear</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_merge"><a class="link" href="#unordered_map_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting any node in <code>source</code> that is not contained
in <code>*this</code> and then inserting it into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_observers"><a class="link" href="#unordered_map_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_map_get_allocator"><a class="link" href="#unordered_map_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_hash_function"><a class="link" href="#unordered_map_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_key_eq"><a class="link" href="#unordered_map_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_lookup"><a class="link" href="#unordered_map_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_map_find"><a class="link" href="#unordered_map_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_count"><a class="link" href="#unordered_map_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_contains"><a class="link" href="#unordered_map_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_equal_range"><a class="link" href="#unordered_map_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_operator"><a class="link" href="#unordered_map_operator">operator[]</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an elements with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_at"><a class="link" href="#unordered_map_at">at</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_bucket_interface"><a class="link" href="#unordered_map_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_map_bucket_count"><a class="link" href="#unordered_map_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_max_bucket_count"><a class="link" href="#unordered_map_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket_size"><a class="link" href="#unordered_map_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_bucket"><a class="link" href="#unordered_map_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_begin_2"><a class="link" href="#unordered_map_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_end_2"><a class="link" href="#unordered_map_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cbegin_2"><a class="link" href="#unordered_map_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_cend_2"><a class="link" href="#unordered_map_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_hash_policy"><a class="link" href="#unordered_map_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_map_load_factor"><a class="link" href="#unordered_map_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_max_load_factor"><a class="link" href="#unordered_map_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_set_max_load_factor"><a class="link" href="#unordered_map_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_rehash"><a class="link" href="#unordered_map_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_reserve"><a class="link" href="#unordered_map_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_deduction_guides"><a class="link" href="#unordered_map_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_­type</code> parameter type in a deduction guide refers to the <code>size_­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_map_iter_value_type"><a class="link" href="#unordered_map_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_map_iter_key_type"><a class="link" href="#unordered_map_iter_key_type"><em>iter-key-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_map_iter_mapped_type"><a class="link" href="#unordered_map_iter_mapped_type"><em>iter-mapped-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_map_iter_to_alloc_type"><a class="link" href="#unordered_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_equality_comparisons"><a class="link" href="#unordered_map_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_map_operator_2"><a class="link" href="#unordered_map_operator_2">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_map_operator_3"><a class="link" href="#unordered_map_operator_3">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_map_swap_2"><a class="link" href="#unordered_map_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_map_erase_if"><a class="link" href="#unordered_map_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multimap"><a class="link" href="#unordered_multimap">Class template unordered_multimap</a></h3>
<div class="paragraph">
<p><code>boost::unordered_multimap</code> — An unordered associative container that associates keys with another value. The same key can be stored multiple times.</p>
</div>
<div class="sect3">
<h4 id="unordered_multimap_synopsis"><a class="link" href="#unordered_multimap_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_multimap {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_multimap_default_constructor">unordered_multimap</a>();
    explicit <a href="#unordered_multimap_bucket_count_constructor">unordered_multimap</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor">unordered_multimap</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multimap_copy_constructor">unordered_multimap</a>(const unordered_multimap&amp; other);
    <a href="#unordered_multimap_move_constructor">unordered_multimap</a>(unordered_multimap&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_allocator">unordered_multimap</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_multimap_allocator_constructor">unordered_multimap</a>(const Allocator&amp; a);
    <a href="#unordered_multimap_copy_constructor_with_allocator">unordered_multimap</a>(const unordered_multimap&amp; other, const Allocator&amp; a);
    <a href="#unordered_multimap_move_constructor_with_allocator">unordered_multimap</a>(unordered_multimap&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multimap_bucket_count_constructor_with_allocator">unordered_multimap</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_multimap_bucket_count_constructor_with_hasher_and_allocator">unordered_multimap</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator">unordered_multimap</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher">unordered_multimap</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_multimap</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_multimap_destructor">~unordered_multimap</a>();
    unordered_multimap&amp; <a href="#unordered_multimap_copy_assignment">operator=</a>(const unordered_multimap&amp; other);
    unordered_multimap&amp; <a href="#unordered_multimap_move_assignment">operator=</a>(unordered_multimap&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_multimap&amp; <a href="#unordered_multimap_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_multimap_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_multimap_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_multimap_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_multimap_end">end</a>() noexcept;
    const_iterator <a href="#unordered_multimap_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_multimap_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_multimap_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_multimap_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_multimap_size">size</a>() const noexcept;
    size_type <a href="#unordered_multimap_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; iterator <a href="#unordered_multimap_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_multimap_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    iterator <a href="#unordered_multimap_copy_insert">insert</a>(const value_type&amp; obj);
    iterator <a href="#unordered_multimap_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_multimap_emplace_insert">insert</a>(P&amp;&amp; obj);
    iterator <a href="#unordered_multimap_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_multimap_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class P&gt; iterator <a href="#unordered_multimap_emplace_insert_with_hint">insert</a>(const_iterator hint, P&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_multimap_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_multimap_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    node_type <a href="#unordered_multimap_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_multimap_extract_by_key">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_multimap_extract_by_key">extract</a>(K&amp;&amp; k);
    iterator <a href="#unordered_multimap_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_multimap_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_multimap_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_multimap_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_multimap_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_multimap_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_multimap_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_multimap_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_multimap_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_multimap_swap">swap</a>(unordered_multimap&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_multimap_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multimap_merge">merge</a>(unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_multimap_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_multimap_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_multimap_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_multimap_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_multimap_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_multimap_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_multimap_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_multimap_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_multimap_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_multimap_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_multimap_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_multimap_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_multimap_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_multimap_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_multimap_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_multimap_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_multimap_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multimap_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multimap_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_multimap_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_multimap_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_multimap_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_multimap_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_multimap_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_multimap_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multimap_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multimap_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_multimap_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_multimap_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_multimap_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_multimap_rehash">rehash</a>(size_type n);
    void <a href="#unordered_multimap_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_multimap_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_multimap(InputIterator, InputIterator, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                       typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multimap&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multimap(InputIterator, InputIterator, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multimap(InputIterator, InputIterator, Allocator)
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_multimap(InputIterator, InputIterator, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_multimap&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type,
                       Allocator)
      -&gt; unordered_multimap&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_multimap&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_multimap(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_multimap_deduction_guides"><em>see below</em></a>::size_type,
                       Hash, Allocator)
      -&gt; unordered_multimap&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multimap_operator">operator==</a>(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multimap_operator_2">operator!=</a>(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_multimap_swap_2">swap</a>(unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_multimap&lt;K, T, H, P, A&gt;::size_type
      <a href="#unordered_multimap_erase_if">erase_if</a>(unordered_multimap&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_description"><a class="link" href="#unordered_multimap_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_typedefs"><a class="link" href="#unordered_multimap_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">pointer</span> <span class="n">pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">const_pointer</span> <span class="n">const_pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">size_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">difference_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_map for details.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_constructors"><a class="link" href="#unordered_multimap_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_default_constructor"><a class="link" href="#unordered_multimap_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count_constructor"><a class="link" href="#unordered_multimap_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multimap</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor"><a class="link" href="#unordered_multimap_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
<span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                   <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_constructor"><a class="link" href="#unordered_multimap_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_constructor"><a class="link" href="#unordered_multimap_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_multimap_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_allocator_constructor"><a class="link" href="#unordered_multimap_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multimap</span><span class="p">(</span><span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_constructor_with_allocator"><a class="link" href="#unordered_multimap_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_constructor_with_allocator"><a class="link" href="#unordered_multimap_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor"><a class="link" href="#unordered_multimap_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
                   <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_multimap_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_multimap_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_multimap_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multimap</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_multimap_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_multimap_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_destructor"><a class="link" href="#unordered_multimap_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_multimap</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_assignment"><a class="link" href="#unordered_multimap_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_copy_assignment"><a class="link" href="#unordered_multimap_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_assignment"><a class="link" href="#unordered_multimap_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_initializer_list_assignment"><a class="link" href="#unordered_multimap_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_iterators"><a class="link" href="#unordered_multimap_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_begin"><a class="link" href="#unordered_multimap_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_end"><a class="link" href="#unordered_multimap_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cbegin"><a class="link" href="#unordered_multimap_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cend"><a class="link" href="#unordered_multimap_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_size_and_capacity"><a class="link" href="#unordered_multimap_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_empty"><a class="link" href="#unordered_multimap_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_size"><a class="link" href="#unordered_multimap_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_max_size"><a class="link" href="#unordered_multimap_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_modifiers"><a class="link" href="#unordered_multimap_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_emplace"><a class="link" href="#unordered_multimap_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_emplace_hint"><a class="link" href="#unordered_multimap_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_insert"><a class="link" href="#unordered_multimap_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_insert"><a class="link" href="#unordered_multimap_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_emplace_insert"><a class="link" href="#unordered_multimap_emplace_insert">Emplace Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace(std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_copy_insert_with_hint"><a class="link" href="#unordered_multimap_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_move_insert_with_hint"><a class="link" href="#unordered_multimap_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_emplace_insert_with_hint"><a class="link" href="#unordered_multimap_emplace_insert_with_hint">Emplace Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">P</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element into the container by performing <code>emplace_hint(hint, std::forward&lt;P&gt;(value))</code>.</p>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_iterator_range"><a class="link" href="#unordered_multimap_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_initializer_list"><a class="link" href="#unordered_multimap_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_extract_by_iterator"><a class="link" href="#unordered_multimap_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_extract_by_key"><a class="link" href="#unordered_multimap_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_map</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_with_node_handle"><a class="link" href="#unordered_multimap_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_map</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_insert_with_hint_and_node_handle"><a class="link" href="#unordered_multimap_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_map</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_by_position"><a class="link" href="#unordered_multimap_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_by_key"><a class="link" href="#unordered_multimap_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_range"><a class="link" href="#unordered_multimap_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_quick_erase"><a class="link" href="#unordered_multimap_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_erase_return_void"><a class="link" href="#unordered_multimap_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_swap"><a class="link" href="#unordered_multimap_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_clear"><a class="link" href="#unordered_multimap_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_merge"><a class="link" href="#unordered_multimap_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting all nodes in <code>source</code> and inserting them into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_observers"><a class="link" href="#unordered_multimap_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_get_allocator"><a class="link" href="#unordered_multimap_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_hash_function"><a class="link" href="#unordered_multimap_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_key_eq"><a class="link" href="#unordered_multimap_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_lookup"><a class="link" href="#unordered_multimap_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_find"><a class="link" href="#unordered_multimap_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_count"><a class="link" href="#unordered_multimap_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_contains"><a class="link" href="#unordered_multimap_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_equal_range"><a class="link" href="#unordered_multimap_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_bucket_interface"><a class="link" href="#unordered_multimap_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_bucket_count"><a class="link" href="#unordered_multimap_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_max_bucket_count"><a class="link" href="#unordered_multimap_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket_size"><a class="link" href="#unordered_multimap_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_bucket"><a class="link" href="#unordered_multimap_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_begin_2"><a class="link" href="#unordered_multimap_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_end_2"><a class="link" href="#unordered_multimap_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cbegin_2"><a class="link" href="#unordered_multimap_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_cend_2"><a class="link" href="#unordered_multimap_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_hash_policy"><a class="link" href="#unordered_multimap_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_load_factor"><a class="link" href="#unordered_multimap_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_max_load_factor"><a class="link" href="#unordered_multimap_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_set_max_load_factor"><a class="link" href="#unordered_multimap_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_rehash"><a class="link" href="#unordered_multimap_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_reserve"><a class="link" href="#unordered_multimap_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_deduction_guides"><a class="link" href="#unordered_multimap_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_­type</code> parameter type in a deduction guide refers to the <code>size_­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iter_value_type"><a class="link" href="#unordered_multimap_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iter_key_type"><a class="link" href="#unordered_multimap_iter_key_type"><em>iter-key-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iter_mapped_type"><a class="link" href="#unordered_multimap_iter_mapped_type"><em>iter-mapped-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_multimap_iter_to_alloc_type"><a class="link" href="#unordered_multimap_iter_to_alloc_type"><em>iter-to-alloc-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_equality_comparisons"><a class="link" href="#unordered_multimap_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_multimap_operator"><a class="link" href="#unordered_multimap_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every equivalent key group in <code>x</code>, there is a group in <code>y</code> for the same key, which is a permutation (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multimap_operator_2"><a class="link" href="#unordered_multimap_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every equivalent key group in <code>x</code>, there is a group in <code>y</code> for the same key, which is a permutation (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multimap_swap_2"><a class="link" href="#unordered_multimap_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multimap_erase_if"><a class="link" href="#unordered_multimap_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_multimap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_set"><a class="link" href="#unordered_set">Class template unordered_set</a></h3>
<div class="paragraph">
<p><code>boost::unordered_set</code> — An unordered associative container that stores unique values.</p>
</div>
<div class="sect3">
<h4 id="unordered_set_synopsis"><a class="link" href="#unordered_set_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_set_default_constructor">unordered_set</a>();
    explicit <a href="#unordered_set_bucket_count_constructor">unordered_set</a>(size_type n,
                           const hasher&amp; hf = hasher(),
                           const key_equal&amp; eql = key_equal(),
                           const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor">unordered_set</a>(InputIterator f, InputIterator l,
                    size_type n = <em>implementation-defined</em>,
                    const hasher&amp; hf = hasher(),
                    const key_equal&amp; eql = key_equal(),
                    const allocator_type&amp; a = allocator_type());
    <a href="#unordered_set_copy_constructor">unordered_set</a>(const unordered_set&amp; other);
    <a href="#unordered_set_move_constructor">unordered_set</a>(unordered_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_allocator">unordered_set</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_set_allocator_constructor">unordered_set</a>(const Allocator&amp; a);
    <a href="#unordered_set_copy_constructor_with_allocator">unordered_set</a>(const unordered_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_set_move_constructor_with_allocator">unordered_set</a>(unordered_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_set_initializer_list_constructor">unordered_set</a>(std::initializer_list&lt;value_type&gt; il,
                  size_type n = <em>implementation-defined</em>,
                  const hasher&amp; hf = hasher(),
                  const key_equal&amp; eql = key_equal(),
                  const allocator_type&amp; a = allocator_type());
    <a href="#unordered_set_bucket_count_constructor_with_allocator">unordered_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_set_bucket_count_constructor_with_hasher_and_allocator">unordered_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                    const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const allocator_type&amp; a);
    <a href="#unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                  const allocator_type&amp; a);
    <a href="#unordered_set_destructor">~unordered_set</a>();
    unordered_set&amp; <a href="#unordered_set_copy_assignment">operator=</a>(const unordered_set&amp; other);
    unordered_set&amp; <a href="#unordered_set_move_assignment">operator=</a>(unordered_set&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_set&amp; <a href="#unordered_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_set_transparent_insert">insert</a>(K&amp;&amp; k);
    iterator <a href="#unordered_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class K&gt; iterator <a href="#unordered_set_transparent_insert_with_hint">insert</a>(const_iterator hint, K&amp;&amp; k);
    template&lt;class InputIterator&gt; void <a href="#unordered_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    node_type <a href="#unordered_set_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_set_extract_by_value">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_set_extract_by_value">extract</a>(K&amp;&amp; k);
    insert_return_type <a href="#unordered_set_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator           <a href="#unordered_set_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_set_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_set_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_set_erase_by_value">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_set_erase_by_value">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_set_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_set_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_set_swap">swap</a>(unordered_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_set_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_set_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_set_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator <a href="#unordered_set_find">find</a>(CompatibleKey const&amp; k, CompatibleHash const&amp; hash,
                          CompatiblePredicate const&amp; eq) const;
    size_type        <a href="#unordered_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_set_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_set_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_set_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_set_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_set_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_set_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_set_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_set_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_set_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_set_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_set_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_set_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_set(InputIterator, InputIterator, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_set_deduction_guides"><em>see below</em></a>,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_set_deduction_guides"><em>see below</em></a>,
                  Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                       boost::hash&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                       std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_set(InputIterator, InputIterator, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_set&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                       std::equal_to&lt;<a href="#unordered_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_set_operator">operator==</a>(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_set_operator_2">operator!=</a>(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_set_swap_2">swap</a>(unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
              unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class H, class P, class A, class Predicate&gt;
    typename unordered_set&lt;K, H, P, A&gt;::size_type
      <a href="#unordered_set_erase_if">erase_if</a>(unordered_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_description"><a class="link" href="#unordered_set_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_typedefs"><a class="link" href="#unordered_set_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">pointer</span> <span class="n">pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">const_pointer</span> <span class="n">const_pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">size_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">difference_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_set for details.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Structure returned by inserting node_type.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_constructors"><a class="link" href="#unordered_set_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_set_default_constructor"><a class="link" href="#unordered_set_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_count_constructor"><a class="link" href="#unordered_set_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                       <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor"><a class="link" href="#unordered_set_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_constructor"><a class="link" href="#unordered_set_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_constructor"><a class="link" href="#unordered_set_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_set_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_allocator_constructor"><a class="link" href="#unordered_set_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_set</span><span class="p">(</span><span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_constructor_with_allocator"><a class="link" href="#unordered_set_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_constructor_with_allocator"><a class="link" href="#unordered_set_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor"><a class="link" href="#unordered_set_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_set_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_set_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_set_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_set_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_set_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_set_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_destructor"><a class="link" href="#unordered_set_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_assignment"><a class="link" href="#unordered_set_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_set_copy_assignment"><a class="link" href="#unordered_set_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_assignment"><a class="link" href="#unordered_set_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_initializer_list_assignment"><a class="link" href="#unordered_set_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_iterators"><a class="link" href="#unordered_set_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_set_begin"><a class="link" href="#unordered_set_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_end"><a class="link" href="#unordered_set_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cbegin"><a class="link" href="#unordered_set_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cend"><a class="link" href="#unordered_set_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_size_and_capacity"><a class="link" href="#unordered_set_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_set_empty"><a class="link" href="#unordered_set_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_size"><a class="link" href="#unordered_set_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_max_size"><a class="link" href="#unordered_set_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_modifiers"><a class="link" href="#unordered_set_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_set_emplace"><a class="link" href="#unordered_set_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent value.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_emplace_hint"><a class="link" href="#unordered_set_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent value.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_insert"><a class="link" href="#unordered_set_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_insert"><a class="link" href="#unordered_set_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_transparent_insert"><a class="link" href="#unordered_set_transparent_insert">Transparent Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_copy_insert_with_hint"><a class="link" href="#unordered_set_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_move_insert_with_hint"><a class="link" href="#unordered_set_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_transparent_insert_with_hint"><a class="link" href="#unordered_set_transparent_insert_with_hint">Transparent Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_iterator_range"><a class="link" href="#unordered_set_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_initializer_list"><a class="link" href="#unordered_set_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_extract_by_iterator"><a class="link" href="#unordered_set_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In C++17 a node extracted using this method can be inserted into a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_extract_by_value"><a class="link" href="#unordered_set_extract_by_value">Extract by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In C++17 a node extracted using this method can be inserted into a compatible <code>unordered_multiset</code>, but that is not supported yet.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_with_node_handle"><a class="link" href="#unordered_set_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> equal to <code>end()</code> and <code>node</code> empty.<br></p>
<div class="paragraph">
<p>Otherwise if there was already an element with an equivalent key, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>false</code>, <code>position</code> pointing to a matching element and <code>node</code> contains the node from <code>nh</code>.<br></p>
</div>
<div class="paragraph">
<p>Otherwise if the insertion succeeded, returns an <code>insert_return_type</code> with: <code>inserted</code> equal to <code>true</code>, <code>position</code> pointing to the newly inserted element and <code>node</code> empty.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>In C++17 this can be used to insert a node extracted from a compatible <code>unordered_multiset</code>, but that is not supported yet.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_insert_with_hint_and_node_handle"><a class="link" href="#unordered_set_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code> if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p>If there is already an element in the container with an equivalent key has no effect on <code>nh</code> (i.e. <code>nh</code> still contains the node.)</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>If there was already an element in the container with an equivalent key returns an iterator pointing to that.<br></p>
</div>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_multiset</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_by_position"><a class="link" href="#unordered_set_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_by_value"><a class="link" href="#unordered_set_erase_by_value">Erase by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_range"><a class="link" href="#unordered_set_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_quick_erase"><a class="link" href="#unordered_set_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_erase_return_void"><a class="link" href="#unordered_set_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_swap"><a class="link" href="#unordered_set_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_clear"><a class="link" href="#unordered_set_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_merge"><a class="link" href="#unordered_set_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting any node in <code>source</code> that is not contained
in <code>*this</code> and then inserting it into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_observers"><a class="link" href="#unordered_set_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_set_get_allocator"><a class="link" href="#unordered_set_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_hash_function"><a class="link" href="#unordered_set_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_key_eq"><a class="link" href="#unordered_set_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_lookup"><a class="link" href="#unordered_set_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_set_find"><a class="link" href="#unordered_set_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hash</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">eq</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_count"><a class="link" href="#unordered_set_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_contains"><a class="link" href="#unordered_set_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_equal_range"><a class="link" href="#unordered_set_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_bucket_interface"><a class="link" href="#unordered_set_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_set_bucket_count"><a class="link" href="#unordered_set_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_max_bucket_count"><a class="link" href="#unordered_set_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket_size"><a class="link" href="#unordered_set_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_bucket"><a class="link" href="#unordered_set_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_begin_2"><a class="link" href="#unordered_set_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_end_2"><a class="link" href="#unordered_set_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cbegin_2"><a class="link" href="#unordered_set_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_cend_2"><a class="link" href="#unordered_set_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_hash_policy"><a class="link" href="#unordered_set_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_set_load_factor"><a class="link" href="#unordered_set_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_max_load_factor"><a class="link" href="#unordered_set_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_set_max_load_factor"><a class="link" href="#unordered_set_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_rehash"><a class="link" href="#unordered_set_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_reserve"><a class="link" href="#unordered_set_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_deduction_guides"><a class="link" href="#unordered_set_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_­type</code> parameter type in a deduction guide refers to the <code>size_­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_set_iter_value_type"><a class="link" href="#unordered_set_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_equality_comparisons"><a class="link" href="#unordered_set_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_set_operator"><a class="link" href="#unordered_set_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_set_operator_2"><a class="link" href="#unordered_set_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_set_swap_2"><a class="link" href="#unordered_set_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_set_erase_if"><a class="link" href="#unordered_set_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_multiset"><a class="link" href="#unordered_multiset">Class template unordered_multiset</a></h3>
<div class="paragraph">
<p><code>boost::unordered_multiset</code> — An unordered associative container that stores values. The same key can be stored multiple times.</p>
</div>
<div class="sect3">
<h4 id="unordered_multiset_synopsis"><a class="link" href="#unordered_multiset_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_multiset {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename boost::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename boost::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = <em>implementation-defined</em>;
    using difference_type      = <em>implementation-defined</em>;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;
    using local_iterator       = <em>implementation-defined</em>;
    using const_local_iterator = <em>implementation-defined</em>;
    using node_type            = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_multiset_default_constructor">unordered_multiset</a>();
    explicit <a href="#unordered_multiset_bucket_count_constructor">unordered_multiset</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor">unordered_multiset</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multiset_copy_constructor">unordered_multiset</a>(const unordered_multiset&amp; other);
    <a href="#unordered_multiset_move_constructor">unordered_multiset</a>(unordered_multiset&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_allocator">unordered_multiset</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_multiset_allocator_constructor">unordered_multiset</a>(const Allocator&amp; a);
    <a href="#unordered_multiset_copy_constructor_with_allocator">unordered_multiset</a>(const unordered_multiset&amp; other, const Allocator&amp; a);
    <a href="#unordered_multiset_move_constructor_with_allocator">unordered_multiset</a>(unordered_multiset&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_multiset_bucket_count_constructor_with_allocator">unordered_multiset</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_multiset_bucket_count_constructor_with_hasher_and_allocator">unordered_multiset</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator">unordered_multiset</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher">unordered_multiset</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor_with_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a)
    <a href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_multiset</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_multiset_destructor">~unordered_multiset()</a>;
    unordered_multiset&amp; <a href="#unordered_multiset_copy_assignment">operator=</a>(const unordered_multiset&amp; other);
    unordered_multiset&amp; <a href="#unordered_multiset_move_assignment">operator=</a>(unordered_multiset&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_move_assignable_v&lt;Pred&gt;);
    unordered_multiset&amp; <a href="#unordered_multiset_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt; il);
    allocator_type <a href="#unordered_multiset_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_multiset_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_multiset_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_multiset_end">end</a>() noexcept;
    const_iterator <a href="#unordered_multiset_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_multiset_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_multiset_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_multiset_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_multiset_size">size</a>() const noexcept;
    size_type <a href="#unordered_multiset_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; iterator <a href="#unordered_multiset_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_multiset_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    iterator <a href="#unordered_multiset_copy_insert">insert</a>(const value_type&amp; obj);
    iterator <a href="#unordered_multiset_move_insert">insert</a>(value_type&amp;&amp; obj);
    iterator <a href="#unordered_multiset_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_multiset_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_multiset_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_multiset_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt; il);

    node_type <a href="#unordered_multiset_extract_by_iterator">extract</a>(const_iterator position);
    node_type <a href="#unordered_multiset_extract_by_value">extract</a>(const key_type&amp; k);
    template&lt;class K&gt; node_type <a href="#unordered_multiset_extract_by_value">extract</a>(K&amp;&amp; k);
    iterator <a href="#unordered_multiset_insert_with_node_handle">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_multiset_insert_with_hint_and_node_handle">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    iterator  <a href="#unordered_multiset_erase_by_position">erase</a>(iterator position);
    iterator  <a href="#unordered_multiset_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_multiset_erase_by_value">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_multiset_erase_by_value">erase</a>(K&amp;&amp; x);
    iterator  <a href="#unordered_multiset_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_multiset_quick_erase">quick_erase</a>(const_iterator position);
    void      <a href="#unordered_multiset_erase_return_void">erase_return_void</a>(const_iterator position);
    void      <a href="#unordered_multiset_swap">swap</a>(unordered_multiset&amp;)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
               boost::is_nothrow_swappable_v&lt;Pred&gt;);
    void      <a href="#unordered_multiset_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_multiset&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_multiset_merge">merge</a>(unordered_set&lt;Key, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_multiset_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_multiset_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_multiset_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_multiset_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_multiset_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_multiset_find">find</a>(const K&amp; k) const;
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      iterator       <a href="#unordered_multiset_find">find</a>(CompatibleKey const&amp;, CompatibleHash const&amp;,
                          CompatiblePredicate const&amp;);
    template&lt;typename CompatibleKey, typename CompatibleHash, typename CompatiblePredicate&gt;
      const_iterator  <a href="#unordered_multiset_find">find</a>(CompatibleKey const&amp;, CompatibleHash const&amp;,
                           CompatiblePredicate const&amp;) const;
    size_type        <a href="#unordered_multiset_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_multiset_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_multiset_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_multiset_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_multiset_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_multiset_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_multiset_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_multiset_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_multiset_bucket_count">bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multiset_max_bucket_count">max_bucket_count</a>() const noexcept;
    size_type <a href="#unordered_multiset_bucket_size">bucket_size</a>(size_type n) const;
    size_type <a href="#unordered_multiset_bucket">bucket</a>(const key_type&amp; k) const;
    template&lt;class K&gt; size_type <a href="#unordered_multiset_bucket">bucket</a>(const K&amp; k) const;
    local_iterator <a href="#unordered_multiset_begin_2">begin</a>(size_type n);
    const_local_iterator <a href="#unordered_multiset_begin_2">begin</a>(size_type n) const;
    local_iterator <a href="#unordered_multiset_end_2">end</a>(size_type n);
    const_local_iterator <a href="#unordered_multiset_end_2">end</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multiset_cbegin_2">cbegin</a>(size_type n) const;
    const_local_iterator <a href="#unordered_multiset_cend_2">cend</a>(size_type n) const;

    // hash policy
    float <a href="#unordered_multiset_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_multiset_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_multiset_set_max_load_factor">max_load_factor</a>(float z);
    void <a href="#unordered_multiset_rehash">rehash</a>(size_type n);
    void <a href="#unordered_multiset_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_multiset(InputIterator, InputIterator, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_multiset&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, Allocator)
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_multiset(InputIterator, InputIterator, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_multiset&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_multiset&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_multiset&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_multiset(std::initializer_list&lt;T&gt;, typename <a href="#unordered_multiset_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_multiset&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multiset_operator">operator==</a>(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_multiset_operator_2">operator!=</a>(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_multiset_swap_2">swap</a>(unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; x,
              unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class H, class P, class A, class Predicate&gt;
    typename unordered_multiset&lt;K, H, P, A&gt;::size_type
      <a href="#unordered_multiset_erase_if">erase_if</a>(unordered_multiset&lt;K, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_description"><a class="link" href="#unordered_multiset_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container (i.e. <code>allocator_traits</code> can destroy it).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that implements an equivalence relation on values of type <code>Key</code>. A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type bool.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements are organized into buckets. Keys with the same hash code are stored in the same bucket and elements with equivalent keys are stored next to each other.</p>
</div>
<div class="paragraph">
<p>The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_typedefs"><a class="link" href="#unordered_multiset_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">pointer</span> <span class="n">pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value_type*</code> if <code>allocator_type::pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">typename</span> <span class="n">allocator_type</span><span class="o">::</span><span class="n">const_pointer</span> <span class="n">const_pointer</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>boost::pointer_to_other&lt;pointer, value_type&gt;::type</code> if <code>allocator_type::const_pointer</code> is not defined.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">size_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An unsigned integral type.</p>
</div>
<div class="paragraph">
<p><code>size_type</code> can represent any non-negative value of <code>difference_type</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">difference_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A signed integral type.</p>
</div>
<div class="paragraph">
<p>Is identical to the difference type of <code>iterator</code> and <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator with the same value type, difference type and pointer and reference type as iterator.</p>
</div>
<div class="paragraph">
<p>A <code>local_iterator</code> object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_local_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator with the same value type, difference type and pointer and reference type as const_iterator.</p>
</div>
<div class="paragraph">
<p>A const_local_iterator object can be used to iterate through a single bucket.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See node_handle_set for details.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_constructors"><a class="link" href="#unordered_multiset_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_default_constructor"><a class="link" href="#unordered_multiset_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate, <code>allocator_type()</code> as the allocator
and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count_constructor"><a class="link" href="#unordered_multiset_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multiset</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum
load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor"><a class="link" href="#unordered_multiset_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_constructor"><a class="link" href="#unordered_multiset_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate, maximum load factor and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_constructor"><a class="link" href="#unordered_multiset_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move-constructible.<br></p>
<div class="paragraph">
<p>On compilers without rvalue reference support the emulation does not support moving without calling <code>boost::move</code> if <code>value_type</code> is not copyable.
So, for example, you can&#8217;t return the container from a function.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_multiset_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_allocator_constructor"><a class="link" href="#unordered_multiset_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_multiset</span><span class="p">(</span><span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_constructor_with_allocator"><a class="link" href="#unordered_multiset_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an container, copying <code>other</code>'s contained elements, hash function, predicate, maximum load factor, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_constructor_with_allocator"><a class="link" href="#unordered_multiset_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Construct a container moving <code>other</code>'s contained elements, and having the hash function, predicate and maximum load factor, but using allocate <code>a</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This is implemented using Boost.Move.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move insertable.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor"><a class="link" href="#unordered_multiset_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
                   <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code> and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_multiset_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_multiset_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate, <code>a</code> as the allocator and a maximum load factor of <code>1.0</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator, with the default hash function and key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_multiset_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate and a maximum load factor of <code>1.0</code> and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_multiset_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_multiset_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="n">unordered_multiset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and a maximum load factor of 1.0 and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_destructor"><a class="link" href="#unordered_multiset_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_multiset</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_assignment"><a class="link" href="#unordered_multiset_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_copy_assignment"><a class="link" href="#unordered_multiset_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the copied elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_assignment"><a class="link" href="#unordered_multiset_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_move_assignable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator.</p>
</div>
<div class="paragraph">
<p>If <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>, the allocator is overwritten, if not the moved elements are created using the existing allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>On compilers without rvalue references, this is emulated using Boost.Move. Note that on some compilers the copy assignment operator may be used in some circumstances.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is move constructible.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_initializer_list_assignment"><a class="link" href="#unordered_multiset_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_multiset</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All existing elements are either overwritten by the new elements or destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a> into the container and <a href="https://en.cppreference.com/w/cpp/named_req/CopyAssignable" target="_blank" rel="noopener">CopyAssignable</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_iterators"><a class="link" href="#unordered_multiset_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_begin"><a class="link" href="#unordered_multiset_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_end"><a class="link" href="#unordered_multiset_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cbegin"><a class="link" href="#unordered_multiset_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cend"><a class="link" href="#unordered_multiset_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_size_and_capacity"><a class="link" href="#unordered_multiset_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_empty"><a class="link" href="#unordered_multiset_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_size"><a class="link" href="#unordered_multiset_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_max_size"><a class="link" href="#unordered_multiset_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_modifiers"><a class="link" href="#unordered_multiset_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_emplace"><a class="link" href="#unordered_multiset_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to <code>10</code> arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_emplace_hint"><a class="link" href="#unordered_multiset_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments args, in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>If the compiler doesn&#8217;t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics.<br></p>
</div>
<div class="paragraph">
<p>Since existing <code>std::pair</code> implementations don&#8217;t support <code>std::piecewise_construct</code> this emulates it, but using <code>boost::unordered::piecewise_construct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_insert"><a class="link" href="#unordered_multiset_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_insert"><a class="link" href="#unordered_multiset_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_copy_insert_with_hint"><a class="link" href="#unordered_multiset_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_move_insert_with_hint"><a class="link" href="#unordered_multiset_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to the inserted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_iterator_range"><a class="link" href="#unordered_multiset_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_initializer_list"><a class="link" href="#unordered_multiset_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into <code>X</code> from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_extract_by_iterator"><a class="link" href="#unordered_multiset_extract_by_iterator">Extract by Iterator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_extract_by_value"><a class="link" href="#unordered_multiset_extract_by_value">Extract by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Removes an element with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> owning the element if found, otherwise an empty <code>node_type</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>A node extracted using this method can be inserted into a compatible <code>unordered_set</code>.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_with_node_handle"><a class="link" href="#unordered_multiset_insert_with_node_handle">Insert with <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_set</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_insert_with_hint_and_node_handle"><a class="link" href="#unordered_multiset_insert_with_hint_and_node_handle">Insert with Hint and <code>node_handle</code></a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is empty, has no effect.</p>
</div>
<div class="paragraph">
<p>Otherwise inserts the element owned by <code>nh</code>.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>nh</code> is empty or <code>nh.get_allocator()</code> is equal to the container&#8217;s allocator.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If <code>nh</code> was empty, returns <code>end()</code>.<br></p>
<div class="paragraph">
<p>Otherwise returns an iterator pointing to the newly inserted element.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to hasher the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The standard is fairly vague on the meaning of the hint. But the only practical way to use it, and the only way that Boost.Unordered supports is to point to an existing element with the same key.<br></p>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor.<br></p>
</div>
<div class="paragraph">
<p>Pointers and references to elements are never invalidated.<br></p>
</div>
<div class="paragraph">
<p>This can be used to insert a node extracted from a compatible <code>unordered_set</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_by_position"><a class="link" href="#unordered_multiset_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following <code>position</code> before the erasure.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_by_value"><a class="link" href="#unordered_multiset_erase_by_value">Erase by Value</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_range"><a class="link" href="#unordered_multiset_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_quick_erase"><a class="link" href="#unordered_multiset_quick_erase">quick_erase</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">quick_erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_erase_return_void"><a class="link" href="#unordered_multiset_erase_return_void">erase_return_void</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase_return_void</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.<br></p>
<div class="paragraph">
<p>In this implementation, this overload doesn&#8217;t call either function object&#8217;s methods so it is no throw, but this might not be true in other implementations.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This method was implemented because returning an iterator to the next element from erase was expensive, but the container has been redesigned so that is no longer the case. So this method is now deprecated.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_swap"><a class="link" href="#unordered_multiset_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&amp;</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Hash</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">is_nothrow_swappable_v</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_clear"><a class="link" href="#unordered_multiset_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Never throws an exception.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_merge"><a class="link" href="#unordered_multiset_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Attempt to "merge" two containers by iterating <code>source</code> and extracting all nodes in <code>source</code> and inserting them into <code>*this</code>.</p>
</div>
<div class="paragraph">
<p>Because <code>source</code> can have a different hash function and key equality predicate, the key of each node in
<code>source</code> is rehashed using <code>this-&gt;hash_function()</code> and then, if required, compared using <code>this-&gt;key_eq()</code>.</p>
</div>
<div class="paragraph">
<p>The behavior of this function is undefined if <code>this-&gt;get_allocator() != source.get_allocator()</code>.</p>
</div>
<div class="paragraph">
<p>This function does not copy or move any elements and instead simply relocates the nodes from <code>source</code>
into <code>*this</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Pointers and references to transferred elements remain valid.</p>
</li>
<li>
<p>Invalidates iterators to transferred elements.</p>
</li>
<li>
<p>Invalidates iterators belonging to <code>*this</code>.</p>
</li>
<li>
<p>Iterators to non-transferred elements in <code>source</code> remain valid.</p>
</li>
</ul>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_observers"><a class="link" href="#unordered_multiset_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_get_allocator"><a class="link" href="#unordered_multiset_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_hash_function"><a class="link" href="#unordered_multiset_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_key_eq"><a class="link" href="#unordered_multiset_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_lookup"><a class="link" href="#unordered_multiset_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_find"><a class="link" href="#unordered_multiset_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span>
                      <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CompatibleKey</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatibleHash</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">CompatiblePredicate</span><span class="p">&gt;</span>
  <span class="n">const_iterator</span>  <span class="n">find</span><span class="p">(</span><span class="n">CompatibleKey</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">CompatibleHash</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span>
                       <span class="n">CompatiblePredicate</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>b.end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The templated overloads containing <code>CompatibleKey</code>, <code>CompatibleHash</code> and <code>CompatiblePredicate</code> are non-standard extensions which allow you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast. In general, its use is not encouraged and instead the <code>K</code> member function templates should be used.<br></p>
<div class="paragraph">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_count"><a class="link" href="#unordered_multiset_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_contains"><a class="link" href="#unordered_multiset_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_equal_range"><a class="link" href="#unordered_multiset_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_bucket_interface"><a class="link" href="#unordered_multiset_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_bucket_count"><a class="link" href="#unordered_multiset_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_max_bucket_count"><a class="link" href="#unordered_multiset_max_bucket_count">max_bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An upper bound on the number of buckets.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket_size"><a class="link" href="#unordered_multiset_bucket_size">bucket_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n &lt; bucket_count()</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements in bucket <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_bucket"><a class="link" href="#unordered_multiset_bucket">bucket</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="n">bucket</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The index of the bucket which would contain an element with key <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p>The return value is less than <code>bucket_count()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_begin_2"><a class="link" href="#unordered_multiset_begin_2">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">begin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_end_2"><a class="link" href="#unordered_multiset_end_2">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">local_iterator</span> <span class="nf">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>
<span class="n">const_local_iterator</span> <span class="n">end</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cbegin_2"><a class="link" href="#unordered_multiset_cbegin_2">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cbegin</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the first element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_cend_2"><a class="link" href="#unordered_multiset_cend_2">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_local_iterator</span> <span class="n">cend</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>n</code> shall be in the range <code>[0, bucket_count())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A constant local iterator pointing the 'one past the end' element in the bucket with index <code>n</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_hash_policy"><a class="link" href="#unordered_multiset_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_load_factor"><a class="link" href="#unordered_multiset_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The average number of elements per bucket.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_max_load_factor"><a class="link" href="#unordered_multiset_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the current maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_set_max_load_factor"><a class="link" href="#unordered_multiset_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Changes the container&#8217;s maximum load factor, using <code>z</code> as a hint.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_rehash"><a class="link" href="#unordered_multiset_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the number of buckets so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_reserve"><a class="link" href="#unordered_multiset_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>, or <code>a.rehash(1)</code> if <code>n &gt; 0</code> and <code>a.max_load_factor() == std::numeric_limits&lt;float&gt;::infinity()</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, and changes the order of elements. Pointers and references to elements are not invalidated.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_deduction_guides"><a class="link" href="#unordered_multiset_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_­type</code> parameter type in a deduction guide refers to the <code>size_­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_multiset_iter_value_type"><a class="link" href="#unordered_multiset_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_equality_comparisons"><a class="link" href="#unordered_multiset_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_multiset_operator"><a class="link" href="#unordered_multiset_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_multiset_operator_2"><a class="link" href="#unordered_multiset_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The behavior of this function was changed to match the C++11 standard in Boost 1.48.<br></p>
<div class="paragraph">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_multiset_swap_2"><a class="link" href="#unordered_multiset_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Doesn&#8217;t throw an exception unless it is thrown by the copy constructor or copy assignment operator of <code>key_equal</code> or <code>hasher</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The exception specifications aren&#8217;t quite the same as the C++11 standard, as the equality predicate and hash function are swapped using their copy constructors.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_multiset_erase_if"><a class="link" href="#unordered_multiset_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="hash_traits"><a class="link" href="#hash_traits">Hash traits</a></h3>
<div class="sect3">
<h4 id="hash_traits_synopsis"><a class="link" href="#hash_traits_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/hash_traits.hpp&gt;

namespace boost {
namespace unordered {

template&lt;typename Hash&gt;
struct <a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>;

} // namespace unordered
} // namespace boost</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="hash_traits_hash_is_avalanching"><a class="link" href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Hash</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">hash_is_avalanching</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A hash function is said to have the <em>avalanching property</em> if small changes in the input translate to
large changes in the returned hash code &#8212;ideally, flipping one bit in the representation of
the input value results in each bit of the hash code flipping with probability 50%. Approaching
this property is critical for the proper behavior of open-addressing hash containers.</p>
</div>
<div class="paragraph">
<p><code>hash_is_avalanching&lt;Hash&gt;::value</code> is <code>true</code> if <code>Hash::is_avalanching</code> is a valid type,
and <code>false</code> otherwise.
Users can then declare a hash function <code>Hash</code> as avalanching either by embedding an <code>is_avalanching</code> typedef
into the definition of <code>Hash</code>, or directly by specializing <code>hash_is_avalanching&lt;Hash&gt;</code> to a class with
an embedded compile-time constant <code>value</code> set to <code>true</code>.</p>
</div>
<div class="paragraph">
<p><a href="#unordered_flat_set"><code>boost::unordered_flat_set</code></a> and <a href="#unordered_flat_map"><code>boost::unordered_flat_map</code></a>
use the provided hash function <code>Hash</code> as-is if <code>hash_is_avalanching&lt;Hash&gt;::value</code> is <code>true</code>; otherwise, they
implement a bit-mixing post-processing stage to increase the quality of hashing at the expense of
extra computational cost.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_map"><a class="link" href="#unordered_flat_map">Class template unordered_flat_map</a></h3>
<div class="paragraph">
<p><code>boost::unordered_flat_map</code> — An open-addressing unordered associative container that associates unique keys with another value.</p>
</div>
<div class="paragraph">
<p>The performance of <code>boost::unordered_flat_map</code> is much better than that of <code>boost::unordered_map</code>
or other implementations of <code>std::unordered_map</code>. Unlike standard unordered associative containers,
which are node-based, the elements of a <code>boost::unordered_flat_map</code> are held directly in the bucket
array, and insertions into an already occupied bucket are diverted to available buckets in the
vicinity of the original position. This type of data layout is known as <em>open addressing</em>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_flat_map</code> deviates in
a number of aspects from that of <code>boost::unordered_flat_map</code>/<code>std::unordered_flat_map</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value_type</code> must be move-constructible.</p>
</li>
<li>
<p>Pointer stability is not kept under rehashing.</p>
</li>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> returns <code>void</code>.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>) or node extraction/insertion.</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_flat_map</code> is mostly a drop-in replacement of node-based standard
unordered associative containers.</p>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_synopsis"><a class="link" href="#unordered_flat_map_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_flat_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_flat_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using init_type            = std::pair&lt;
                                   typename std::remove_const&lt;Key&gt;::type,
                                   typename std::remove_const&lt;T&gt;::type
                                 &gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_flat_map_default_constructor">unordered_flat_map</a>();
    explicit <a href="#unordered_flat_map_bucket_count_constructor">unordered_flat_map</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor">unordered_flat_map</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_map_copy_constructor">unordered_flat_map</a>(const unordered_flat_map&amp; other);
    <a href="#unordered_flat_map_move_constructor">unordered_flat_map</a>(unordered_flat_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor_with_allocator">unordered_flat_map</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_flat_map_allocator_constructor">unordered_flat_map</a>(const Allocator&amp; a);
    <a href="#unordered_flat_map_copy_constructor_with_allocator">unordered_flat_map</a>(const unordered_flat_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_map_move_constructor_with_allocator">unordered_flat_map</a>(unordered_flat_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_map_bucket_count_constructor_with_allocator">unordered_flat_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_flat_map_bucket_count_constructor_with_hasher_and_allocator">unordered_flat_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_flat_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_flat_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor_with_allocator">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_flat_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_map_destructor">~unordered_flat_map</a>();
    unordered_flat_map&amp; <a href="#unordered_flat_map_copy_assignment">operator=</a>(const unordered_flat_map&amp; other);
    unordered_flat_map&amp; <a href="#unordered_flat_map_move_assignment">operator=</a>(unordered_flat_map&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
              boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);
    unordered_flat_map&amp; <a href="#unordered_flat_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_flat_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_flat_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_flat_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_flat_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_flat_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_flat_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_flat_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_flat_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_flat_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_flat_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_flat_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_copy_insert">insert</a>(const init_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_move_insert">insert</a>(init_type&amp;&amp; obj);
    iterator       <a href="#unordered_flat_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_flat_map_copy_insert_with_hint">insert</a>(const_iterator hint, const init_type&amp; obj);
    iterator       <a href="#unordered_flat_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    iterator       <a href="#unordered_flat_map_copy_insert_with_hint">insert</a>(const_iterator hint, init_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_flat_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_flat_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_flat_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_flat_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      iterator <a href="#unordered_flat_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      iterator <a href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);

    void      <a href="#unordered_flat_map_erase_by_position">erase</a>(iterator position);
    void      <a href="#unordered_flat_map_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_flat_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_flat_map_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_flat_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_flat_map_swap">swap</a>(unordered_flat_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    void      <a href="#unordered_flat_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_map_merge">merge</a>(unordered_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_map_merge">merge</a>(unordered_flat_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_flat_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_flat_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_flat_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_flat_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_flat_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_flat_map_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_flat_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_flat_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_flat_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_flat_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_flat_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_flat_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_flat_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_flat_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_flat_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_flat_map_operator">operator[]</a>(key_type&amp;&amp; k);
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_flat_map_operator">operator[]</a>(K&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const key_type&amp; k) const;
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const K&amp; k);
    template&lt;class K&gt; const mapped_type&amp; <a href="#unordered_flat_map_at">at</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_flat_map_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_flat_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_flat_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_flat_map_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_flat_map_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_flat_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_flat_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_flat_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_flat_map(InputIterator, InputIterator, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                       typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_map(InputIterator, InputIterator, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_map(InputIterator, InputIterator, Allocator)
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_flat_map(InputIterator, InputIterator, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_flat_map&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type,
                       Allocator)
      -&gt; unordered_flat_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_flat_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_flat_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_flat_map_deduction_guides"><em>see below</em></a>::size_type,
                       Hash, Allocator)
      -&gt; unordered_flat_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_map_operator_2">operator==</a>(const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_map_operator_3">operator!=</a>(const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_flat_map_swap_2">swap</a>(unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_flat_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_flat_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_flat_map_erase_if">erase_if</a>(unordered_flat_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_description"><a class="link" href="#unordered_flat_map_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>Key</code> and <code>T</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible" target="_blank" rel="noopener">MoveConstructible</a>.
<code>std::pair&lt;const Key, T&gt;</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a>
into the container from any <code>std::pair</code> object convertible to it, and it also must be
<a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
<code>std::allocator_traits&lt;Allocator&gt;::pointer</code> and <code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
must be convertible to/from <code>value_type*</code> and <code>const value_type*</code>, respectively.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements of the container are held into an internal <em>bucket array</em>. An element is inserted into a bucket determined by its
hash code, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_typedefs"><a class="link" href="#unordered_flat_map_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_constructors"><a class="link" href="#unordered_flat_map_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_default_constructor"><a class="link" href="#unordered_flat_map_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_bucket_count_constructor"><a class="link" href="#unordered_flat_map_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_flat_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iterator_range_constructor"><a class="link" href="#unordered_flat_map_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_copy_constructor"><a class="link" href="#unordered_flat_map_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">unordered_flat_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_constructor"><a class="link" href="#unordered_flat_map_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_flat_map_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_allocator_constructor"><a class="link" href="#unordered_flat_map_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_flat_map</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_copy_constructor_with_allocator"><a class="link" href="#unordered_flat_map_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">unordered_flat_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_constructor_with_allocator"><a class="link" href="#unordered_flat_map_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the elements of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_constructor"><a class="link" href="#unordered_flat_map_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_flat_map_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_flat_map_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_flat_map_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_flat_map_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_flat_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_destructor"><a class="link" href="#unordered_flat_map_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_flat_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_assignment"><a class="link" href="#unordered_flat_map_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_copy_assignment"><a class="link" href="#unordered_flat_map_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_flat_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_assignment"><a class="link" href="#unordered_flat_map_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_initializer_list_assignment"><a class="link" href="#unordered_flat_map_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_iterators"><a class="link" href="#unordered_flat_map_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_begin"><a class="link" href="#unordered_flat_map_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_end"><a class="link" href="#unordered_flat_map_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_cbegin"><a class="link" href="#unordered_flat_map_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_cend"><a class="link" href="#unordered_flat_map_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_size_and_capacity"><a class="link" href="#unordered_flat_map_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_empty"><a class="link" href="#unordered_flat_map_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_size"><a class="link" href="#unordered_flat_map_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_max_size"><a class="link" href="#unordered_flat_map_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_modifiers"><a class="link" href="#unordered_flat_map_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_emplace"><a class="link" href="#unordered_flat_map_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_emplace_hint"><a class="link" href="#unordered_flat_map_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_copy_insert"><a class="link" href="#unordered_flat_map_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_insert"><a class="link" href="#unordered_flat_map_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_copy_insert_with_hint"><a class="link" href="#unordered_flat_map_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_move_insert_with_hint"><a class="link" href="#unordered_flat_map_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_insert_iterator_range"><a class="link" href="#unordered_flat_map_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_insert_initializer_list"><a class="link" href="#unordered_flat_map_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_try_emplace"><a class="link" href="#unordered_flat_map_try_emplace">try_emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_flat_map_emplace">emplace</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_flat_map_emplace">emplace</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_try_emplace_with_hint"><a class="link" href="#unordered_flat_map_try_emplace_with_hint">try_emplace with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.  This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_flat_map_emplace_hint">emplace_hint</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_flat_map_emplace_hint">emplace_hint</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_insert_or_assign"><a class="link" href="#unordered_flat_map_insert_or_assign">insert_or_assign</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators pointers and references, but only if the insert causes the load to be greater than the maximum load. <br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_insert_or_assign_with_hint"><a class="link" href="#unordered_flat_map_insert_or_assign_with_hint">insert_or_assign with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_erase_by_position"><a class="link" href="#unordered_flat_map_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_erase_by_key"><a class="link" href="#unordered_flat_map_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_erase_range"><a class="link" href="#unordered_flat_map_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_swap"><a class="link" href="#unordered_flat_map_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_clear"><a class="link" href="#unordered_flat_map_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_merge"><a class="link" href="#unordered_flat_map_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move-inserts all the elements from <code>source</code> whose key is not already present in <code>*this</code>, and erases them from <code>source</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_observers"><a class="link" href="#unordered_flat_map_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_get_allocator"><a class="link" href="#unordered_flat_map_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_hash_function"><a class="link" href="#unordered_flat_map_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_key_eq"><a class="link" href="#unordered_flat_map_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_lookup"><a class="link" href="#unordered_flat_map_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_find"><a class="link" href="#unordered_flat_map_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_count"><a class="link" href="#unordered_flat_map_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_contains"><a class="link" href="#unordered_flat_map_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_equal_range"><a class="link" href="#unordered_flat_map_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_operator"><a class="link" href="#unordered_flat_map_operator">operator[]</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an element with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_at"><a class="link" href="#unordered_flat_map_at">at</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_bucket_interface"><a class="link" href="#unordered_flat_map_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_bucket_count"><a class="link" href="#unordered_flat_map_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_hash_policy"><a class="link" href="#unordered_flat_map_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_load_factor"><a class="link" href="#unordered_flat_map_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_max_load_factor"><a class="link" href="#unordered_flat_map_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_set_max_load_factor"><a class="link" href="#unordered_flat_map_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_max_load"><a class="link" href="#unordered_flat_map_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_rehash"><a class="link" href="#unordered_flat_map_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_reserve"><a class="link" href="#unordered_flat_map_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_deduction_guides"><a class="link" href="#unordered_flat_map_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_­type</code> parameter type in a deduction guide refers to the <code>size_­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iter_value_type"><a class="link" href="#unordered_flat_map_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iter_key_type"><a class="link" href="#unordered_flat_map_iter_key_type"><em>iter-key-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iter_mapped_type"><a class="link" href="#unordered_flat_map_iter_mapped_type"><em>iter-mapped-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_iter_to_alloc_type"><a class="link" href="#unordered_flat_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_equality_comparisons"><a class="link" href="#unordered_flat_map_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_flat_map_operator_2"><a class="link" href="#unordered_flat_map_operator_2">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_map_operator_3"><a class="link" href="#unordered_flat_map_operator_3">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_swap_2"><a class="link" href="#unordered_flat_map_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_map_erase_if"><a class="link" href="#unordered_flat_map_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_flat_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_flat_set"><a class="link" href="#unordered_flat_set">Class template unordered_flat_set</a></h3>
<div class="paragraph">
<p><code>boost::unordered_flat_set</code> — An open-addressing unordered associative container that stores unique values.</p>
</div>
<div class="paragraph">
<p>The performance of <code>boost::unordered_flat_set</code> is much better than that of <code>boost::unordered_set</code>
or other implementations of <code>std::unordered_set</code>. Unlike standard unordered associative containers,
which are node-based, the elements of a <code>boost::unordered_flat_set</code> are held directly in the bucket
array, and insertions into an already occupied bucket are diverted to available buckets in the
vicinity of the original position. This type of data layout is known as <em>open addressing</em>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_flat_set</code> deviates in
a number of aspects from that of <code>boost::unordered_flat_set</code>/<code>std::unordered_flat_set</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>value_type</code> must be move-constructible.</p>
</li>
<li>
<p>Pointer stability is not kept under rehashing.</p>
</li>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> returns <code>void</code>.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>) or node extraction/insertion.</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_flat_set</code> is mostly a drop-in replacement of node-based standard
unordered associative containers.</p>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_synopsis"><a class="link" href="#unordered_flat_set_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_flat_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_flat_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using init_type            = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_flat_set_default_constructor">unordered_flat_set</a>();
    explicit <a href="#unordered_flat_set_bucket_count_constructor">unordered_flat_set</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor">unordered_flat_set</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_set_copy_constructor">unordered_flat_set</a>(const unordered_flat_set&amp; other);
    <a href="#unordered_flat_set_move_constructor">unordered_flat_set</a>(unordered_flat_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor_with_allocator">unordered_flat_set</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_flat_set_allocator_constructor">unordered_flat_set</a>(const Allocator&amp; a);
    <a href="#unordered_flat_set_copy_constructor_with_allocator">unordered_flat_set</a>(const unordered_flat_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_set_move_constructor_with_allocator">unordered_flat_set</a>(unordered_flat_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_flat_set_bucket_count_constructor_with_allocator">unordered_flat_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_flat_set_bucket_count_constructor_with_hasher_and_allocator">unordered_flat_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_flat_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_flat_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor_with_allocator">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_flat_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_flat_set_destructor">~unordered_flat_set</a>();
    unordered_flat_set&amp; <a href="#unordered_flat_set_copy_assignment">operator=</a>(const unordered_flat_set&amp; other);
    unordered_flat_set&amp; <a href="#unordered_flat_set_move_assignment">operator=</a>(unordered_flat_set&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);
    unordered_flat_set&amp; <a href="#unordered_flat_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_flat_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_flat_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_flat_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_flat_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_flat_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_flat_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_flat_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_flat_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_flat_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_flat_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_flat_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_flat_set_transparent_insert">insert</a>(K&amp;&amp; k);
    iterator <a href="#unordered_flat_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_flat_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class K&gt; iterator <a href="#unordered_flat_set_transparent_insert_with_hint">insert</a>(const_iterator hint, K&amp;&amp; k);
    template&lt;class InputIterator&gt; void <a href="#unordered_flat_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_flat_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);

    void      <a href="#unordered_flat_set_erase_by_position">erase</a>(iterator position);
    void      <a href="#unordered_flat_set_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_flat_set_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_flat_set_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_flat_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_flat_set_swap">swap</a>(unordered_flat_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    void      <a href="#unordered_flat_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_set_merge">merge</a>(unordered_flat_set&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_flat_set_merge">merge</a>(unordered_flat_set&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_flat_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_flat_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_flat_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_flat_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_flat_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_flat_set_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_flat_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_flat_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_flat_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_flat_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_flat_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_flat_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_flat_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_flat_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_flat_set_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_flat_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_flat_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_flat_set_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_flat_set_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_flat_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_flat_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_flat_set(InputIterator, InputIterator, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_flat_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_set(InputIterator, InputIterator, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_flat_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_flat_set(InputIterator, InputIterator, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_flat_set&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_flat_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_flat_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_flat_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_flat_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_flat_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_set_operator_2">operator!=</a>(const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_flat_set_operator_3">operator!=</a>(const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_flat_set_swap_2">swap</a>(unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_flat_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_flat_set&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_flat_set_erase_if">erase_if</a>(unordered_flat_set&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_description"><a class="link" href="#unordered_flat_set_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a> into the container
and <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
<code>std::allocator_traits&lt;Allocator&gt;::pointer</code> and <code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
must be convertible to/from <code>value_type*</code> and <code>const value_type*</code>, respectively.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The elements of the container are held into an internal <em>bucket array</em>. An element is inserted into a bucket determined by its
hash code, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_typedefs"><a class="link" href="#unordered_flat_set_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_constructors"><a class="link" href="#unordered_flat_set_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_default_constructor"><a class="link" href="#unordered_flat_set_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_bucket_count_constructor"><a class="link" href="#unordered_flat_set_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_flat_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iterator_range_constructor"><a class="link" href="#unordered_flat_set_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_copy_constructor"><a class="link" href="#unordered_flat_set_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">unordered_flat_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_constructor"><a class="link" href="#unordered_flat_set_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_flat_set_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_allocator_constructor"><a class="link" href="#unordered_flat_set_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_flat_set</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_copy_constructor_with_allocator"><a class="link" href="#unordered_flat_set_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">unordered_flat_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_constructor_with_allocator"><a class="link" href="#unordered_flat_set_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the elements of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_constructor"><a class="link" href="#unordered_flat_set_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_flat_set_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_flat_set_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_flat_set_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_flat_set_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_flat_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_destructor"><a class="link" href="#unordered_flat_set_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_flat_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_assignment"><a class="link" href="#unordered_flat_set_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_copy_assignment"><a class="link" href="#unordered_flat_set_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_flat_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_assignment"><a class="link" href="#unordered_flat_set_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_initializer_list_assignment"><a class="link" href="#unordered_flat_set_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_flat_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_iterators"><a class="link" href="#unordered_flat_set_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_begin"><a class="link" href="#unordered_flat_set_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_end"><a class="link" href="#unordered_flat_set_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_cbegin"><a class="link" href="#unordered_flat_set_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_cend"><a class="link" href="#unordered_flat_set_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_size_and_capacity"><a class="link" href="#unordered_flat_set_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_empty"><a class="link" href="#unordered_flat_set_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_size"><a class="link" href="#unordered_flat_set_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_max_size"><a class="link" href="#unordered_flat_set_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_modifiers"><a class="link" href="#unordered_flat_set_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_emplace"><a class="link" href="#unordered_flat_set_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_emplace_hint"><a class="link" href="#unordered_flat_set_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_copy_insert"><a class="link" href="#unordered_flat_set_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_insert"><a class="link" href="#unordered_flat_set_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_transparent_insert"><a class="link" href="#unordered_flat_set_transparent_insert">Transparent Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_copy_insert_with_hint"><a class="link" href="#unordered_flat_set_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_move_insert_with_hint"><a class="link" href="#unordered_flat_set_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_transparent_insert_with_hint"><a class="link" href="#unordered_flat_set_transparent_insert_with_hint">Transparent Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_insert_iterator_range"><a class="link" href="#unordered_flat_set_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_insert_initializer_list"><a class="link" href="#unordered_flat_set_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, pointers and references, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_erase_by_position"><a class="link" href="#unordered_flat_set_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_erase_by_key"><a class="link" href="#unordered_flat_set_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_erase_range"><a class="link" href="#unordered_flat_set_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_swap"><a class="link" href="#unordered_flat_set_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_clear"><a class="link" href="#unordered_flat_set_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_merge"><a class="link" href="#unordered_flat_set_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Move-inserts all the elements from <code>source</code> whose key is not already present in <code>*this</code>, and erases them from <code>source</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_observers"><a class="link" href="#unordered_flat_set_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_get_allocator"><a class="link" href="#unordered_flat_set_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_hash_function"><a class="link" href="#unordered_flat_set_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_key_eq"><a class="link" href="#unordered_flat_set_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_lookup"><a class="link" href="#unordered_flat_set_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_find"><a class="link" href="#unordered_flat_set_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_count"><a class="link" href="#unordered_flat_set_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_contains"><a class="link" href="#unordered_flat_set_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_equal_range"><a class="link" href="#unordered_flat_set_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_bucket_interface"><a class="link" href="#unordered_flat_set_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_bucket_count"><a class="link" href="#unordered_flat_set_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_hash_policy"><a class="link" href="#unordered_flat_set_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_load_factor"><a class="link" href="#unordered_flat_set_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_max_load_factor"><a class="link" href="#unordered_flat_set_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_set_max_load_factor"><a class="link" href="#unordered_flat_set_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_max_load"><a class="link" href="#unordered_flat_set_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_rehash"><a class="link" href="#unordered_flat_set_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_reserve"><a class="link" href="#unordered_flat_set_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators, pointers and references, and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_deduction_guides"><a class="link" href="#unordered_flat_set_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_­type</code> parameter type in a deduction guide refers to the <code>size_­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_iter_value_type"><a class="link" href="#unordered_flat_set_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_equality_comparisons"><a class="link" href="#unordered_flat_set_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_flat_set_operator"><a class="link" href="#unordered_flat_set_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_flat_set_operator_2"><a class="link" href="#unordered_flat_set_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_swap_2"><a class="link" href="#unordered_flat_set_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_flat_set_erase_if"><a class="link" href="#unordered_flat_set_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_flat_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_map"><a class="link" href="#unordered_node_map">Class template unordered_node_map</a></h3>
<div class="paragraph">
<p><code>boost::unordered_node_map</code> — A node-based, open-addressing unordered associative container that associates unique keys with another value.</p>
</div>
<div class="paragraph">
<p><code>boost::unordered_node_map</code> uses an open-addressing layout like <code>boost::unordered_flat_map</code>, but,
being node-based, it provides pointer/iterator stability and node handling functionalities.
Its performance lies between those of <code>boost::unordered_map</code> and <code>boost::unordered_flat_map</code>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_node_map</code> deviates in
a number of aspects from that of <code>boost::unordered_map</code>/<code>std::unordered_map</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> returns <code>void</code>.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>).</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_node_map</code> is mostly a drop-in replacement of standard
unordered associative containers.</p>
</div>
<div class="sect3">
<h4 id="unordered_node_map_synopsis"><a class="link" href="#unordered_node_map_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_node_map.hpp&gt;

namespace boost {
  template&lt;class Key,
           class T,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
  class unordered_node_map {
  public:
    // types
    using key_type             = Key;
    using mapped_type          = T;
    using value_type           = std::pair&lt;const Key, T&gt;;
    using init_type            = std::pair&lt;
                                   typename std::remove_const&lt;Key&gt;::type,
                                   typename std::remove_const&lt;T&gt;::type
                                 &gt;;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_node_map_default_constructor">unordered_node_map</a>();
    explicit <a href="#unordered_node_map_bucket_count_constructor">unordered_node_map</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor">unordered_node_map</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_map_copy_constructor">unordered_node_map</a>(const unordered_node_map&amp; other);
    <a href="#unordered_node_map_move_constructor">unordered_node_map</a>(unordered_node_map&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor_with_allocator">unordered_node_map</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_node_map_allocator_constructor">unordered_node_map</a>(const Allocator&amp; a);
    <a href="#unordered_node_map_copy_constructor_with_allocator">unordered_node_map</a>(const unordered_node_map&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_map_move_constructor_with_allocator">unordered_node_map</a>(unordered_node_map&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_map_bucket_count_constructor_with_allocator">unordered_node_map</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_node_map_bucket_count_constructor_with_hasher_and_allocator">unordered_node_map</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator">unordered_node_map</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher">unordered_node_map</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor_with_allocator">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_node_map</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_node_map_destructor">~unordered_node_map</a>();
    unordered_node_map&amp; <a href="#unordered_node_map_copy_assignment">operator=</a>(const unordered_node_map&amp; other);
    unordered_node_map&amp; <a href="#unordered_node_map_move_assignment">operator=</a>(unordered_node_map&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
              boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);
    unordered_node_map&amp; <a href="#unordered_node_map_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_node_map_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_node_map_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_node_map_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_node_map_end">end</a>() noexcept;
    const_iterator <a href="#unordered_node_map_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_node_map_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_node_map_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_node_map_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_node_map_size">size</a>() const noexcept;
    size_type <a href="#unordered_node_map_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_node_map_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_copy_insert">insert</a>(const init_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_move_insert">insert</a>(value_type&amp;&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_move_insert">insert</a>(init_type&amp;&amp; obj);
    iterator       <a href="#unordered_node_map_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator       <a href="#unordered_node_map_copy_insert_with_hint">insert</a>(const_iterator hint, const init_type&amp; obj);
    iterator       <a href="#unordered_node_map_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    iterator       <a href="#unordered_node_map_copy_insert_with_hint">insert</a>(const_iterator hint, init_type&amp;&amp; obj);
    template&lt;class InputIterator&gt; void <a href="#unordered_node_map_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_node_map_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);
    insert_return_type <a href="#unordered_node_map_insert_node">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_node_map_insert_node_with_hint">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_try_emplace">try_emplace</a>(const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_try_emplace">try_emplace</a>(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_try_emplace">try_emplace</a>(K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_node_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, const key_type&amp; k, Args&amp;&amp;... args);
    template&lt;class... Args&gt;
      iterator <a href="#unordered_node_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, key_type&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class K, class... Args&gt;
      iterator <a href="#unordered_node_map_try_emplace_with_hint">try_emplace</a>(const_iterator hint, K&amp;&amp; k, Args&amp;&amp;... args);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_insert_or_assign">insert_or_assign</a>(const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_insert_or_assign">insert_or_assign</a>(key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      std::pair&lt;iterator, bool&gt; <a href="#unordered_node_map_insert_or_assign">insert_or_assign</a>(K&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, const key_type&amp; k, M&amp;&amp; obj);
    template&lt;class M&gt;
      iterator <a href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, key_type&amp;&amp; k, M&amp;&amp; obj);
    template&lt;class K, class M&gt;
      iterator <a href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign</a>(const_iterator hint, K&amp;&amp; k, M&amp;&amp; obj);

    void      <a href="#unordered_node_map_erase_by_position">erase</a>(iterator position);
    void      <a href="#unordered_node_map_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_node_map_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_node_map_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_node_map_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_node_map_swap">swap</a>(unordered_node_map&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    node_type <a href="#unordered_node_map_extract_by_position">extract</a>(const_iterator position);
    node_type <a href="#unordered_node_map_extract_by_key">extract</a>(const key_type&amp; key);
    template&lt;class K&gt; node_type <a href="#unordered_node_map_extract_by_key">extract</a>(K&amp;&amp; key);
    void      <a href="#unordered_node_map_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_map_merge">merge</a>(unordered_node_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_map_merge">merge</a>(unordered_node_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_node_map_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_node_map_key_eq">key_eq</a>() const;

    // map operations
    iterator         <a href="#unordered_node_map_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_node_map_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_node_map_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_node_map_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_node_map_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_node_map_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_node_map_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_node_map_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_node_map_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_node_map_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_node_map_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_node_map_equal_range">equal_range</a>(const K&amp; k) const;

    // element access
    mapped_type&amp; <a href="#unordered_node_map_operator">operator[]</a>(const key_type&amp; k);
    mapped_type&amp; <a href="#unordered_node_map_operator">operator[]</a>(key_type&amp;&amp; k);
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_node_map_operator">operator[]</a>(K&amp;&amp; k);
    mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const key_type&amp; k);
    const mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const key_type&amp; k) const;
    template&lt;class K&gt; mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const K&amp; k);
    template&lt;class K&gt; const mapped_type&amp; <a href="#unordered_node_map_at">at</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_node_map_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_node_map_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_node_map_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_node_map_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_node_map_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_node_map_rehash">rehash</a>(size_type n);
    void <a href="#unordered_node_map_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_node_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_node_map(InputIterator, InputIterator, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            Pred, Allocator&gt;;

  template&lt;class Key, class T, class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;,
                       typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>, Hash = Hash(),
                       Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_map&lt;Key, T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_map(InputIterator, InputIterator, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_map(InputIterator, InputIterator, Allocator)
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_node_map(InputIterator, InputIterator, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_node_map&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;, <a href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type,
                       Allocator)
      -&gt; unordered_node_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Allocator&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, Allocator)
      -&gt; unordered_node_map&lt;Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, Allocator&gt;;

  template&lt;class Key, class T, class Hash, class Allocator&gt;
    unordered_node_map(std::initializer_list&lt;std::pair&lt;Key, T&gt;&gt;, typename <a href="#unordered_node_map_deduction_guides"><em>see below</em></a>::size_type,
                       Hash, Allocator)
      -&gt; unordered_node_map&lt;Key, T, Hash, std::equal_to&lt;Key&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_map_operator_2">operator==</a>(const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_map_operator_3">operator!=</a>(const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_node_map_swap_2">swap</a>(unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_node_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_node_map&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_node_map_erase_if">erase_if</a>(unordered_node_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_description"><a class="link" href="#unordered_node_map_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><code>std::pair&lt;const Key, T&gt;</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a>
into the container from any <code>std::pair</code> object convertible to it, and it also must be
<a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>T</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
<code>std::allocator_traits&lt;Allocator&gt;::pointer</code> and <code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
must be convertible to/from <code>value_type*</code> and <code>const value_type*</code>, respectively.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The element nodes of the container are held into an internal <em>bucket array</em>. A node is inserted into a bucket determined by the
hash code of its element, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_typedefs"><a class="link" href="#unordered_node_map_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A class for holding extracted container elements, modelling
<a href="https://en.cppreference.com/w/cpp/container/node_handle">NodeHandle</a>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of an internal class template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">NodeType</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc"><em>insert_return_type</em></span> <span class="c1">// name is exposition only</span>
<span class="p">{</span>
  <span class="n">Iterator</span> <span class="n">position</span><span class="p">;</span>
  <span class="kt">bool</span>     <span class="n">inserted</span><span class="p">;</span>
  <span class="n">NodeType</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>with <code>Iterator</code> = <code>iterator</code> and <code>NodeType</code> = <code>node_type</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_constructors"><a class="link" href="#unordered_node_map_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_default_constructor"><a class="link" href="#unordered_node_map_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_bucket_count_constructor"><a class="link" href="#unordered_node_map_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_node_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iterator_range_constructor"><a class="link" href="#unordered_node_map_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_copy_constructor"><a class="link" href="#unordered_node_map_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">unordered_node_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_constructor"><a class="link" href="#unordered_node_map_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_node_map_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_allocator_constructor"><a class="link" href="#unordered_node_map_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_node_map</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_copy_constructor_with_allocator"><a class="link" href="#unordered_node_map_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">unordered_node_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_constructor_with_allocator"><a class="link" href="#unordered_node_map_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the element nodes of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_constructor"><a class="link" href="#unordered_node_map_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_node_map_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_node_map_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_node_map_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_node_map</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_node_map_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_node_map_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_destructor"><a class="link" href="#unordered_node_map_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_node_map</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_assignment"><a class="link" href="#unordered_node_map_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_copy_assignment"><a class="link" href="#unordered_node_map_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_node_map</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_assignment"><a class="link" href="#unordered_node_map_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_initializer_list_assignment"><a class="link" href="#unordered_node_map_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_map</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_iterators"><a class="link" href="#unordered_node_map_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_begin"><a class="link" href="#unordered_node_map_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_end"><a class="link" href="#unordered_node_map_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_cbegin"><a class="link" href="#unordered_node_map_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_cend"><a class="link" href="#unordered_node_map_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_size_and_capacity"><a class="link" href="#unordered_node_map_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_empty"><a class="link" href="#unordered_node_map_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_size"><a class="link" href="#unordered_node_map_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_max_size"><a class="link" href="#unordered_node_map_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_modifiers"><a class="link" href="#unordered_node_map_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_emplace"><a class="link" href="#unordered_node_map_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_emplace_hint"><a class="link" href="#unordered_node_map_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_copy_insert"><a class="link" href="#unordered_node_map_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_insert"><a class="link" href="#unordered_node_map_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_copy_insert_with_hint"><a class="link" href="#unordered_node_map_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">init_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>const value_type&amp;</code> and <code>const init_type&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_move_insert_with_hint"><a class="link" href="#unordered_node_map_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">init_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>A call of the form <code>insert(hint, x)</code>, where <code>x</code> is equally convertible to both <code>value_type&amp;&amp;</code> and <code>init_type&amp;&amp;</code>, is not ambiguous and selects the <code>init_type</code> overload.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_iterator_range"><a class="link" href="#unordered_node_map_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_initializer_list"><a class="link" href="#unordered_node_map_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_node"><a class="link" href="#unordered_node_map_insert_node">Insert Node</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.key()</code>.
<code>nh</code> is empty when the function returns.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An <code>insert_return_type</code> object constructed from <code>position</code>, <code>inserted</code> and <code>node</code>:<br></p>
<div class="ulist">
<ul>
<li>
<p>If <code>nh</code> is empty, <code>inserted</code> is <code>false</code>, <code>position</code> is <code>end()</code>, and <code>node</code> is empty.</p>
</li>
<li>
<p>Otherwise if the insertion took place, <code>inserted</code> is true, <code>position</code> points to the inserted element, and <code>node</code> is empty.</p>
</li>
<li>
<p>If the insertion failed, <code>inserted</code> is false, <code>node</code> has the previous value of <code>nh</code>, and <code>position</code> points to an element with a key equivalent to <code>nh.key()</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_node_with_hint"><a class="link" href="#unordered_node_map_insert_node_with_hint">Insert Node with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.key()</code>.
<code>nh</code> becomes empty if insertion took place, otherwise it is not changed.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator returned is <code>end()</code> if <code>nh</code> is empty.
If insertion took place, then the iterator points to the newly inserted element; otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_try_emplace"><a class="link" href="#unordered_node_map_try_emplace">try_emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">try_emplace</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_node_map_emplace">emplace</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_node_map_emplace">emplace</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_try_emplace_with_hint"><a class="link" href="#unordered_node_map_try_emplace_with_hint">try_emplace with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">try_emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new node into the container if there is no existing element with key <code>k</code> contained within it.</p>
</div>
<div class="paragraph">
<p>If there is an existing element with key <code>k</code> this function does nothing.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted.  This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>This function is similiar to <a href="#unordered_node_map_emplace_hint">emplace_hint</a>, with the difference that no <code>value_type</code> is constructed
if there is an element with an equivalent key; otherwise, the construction is of the form:<br></p>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike <a href="#unordered_node_map_emplace_hint">emplace_hint</a>, which simply forwards all arguments to <code>value_type</code>'s constructor.</p>
</div>
<div class="paragraph">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</div>
<div class="paragraph">
<p>The <code>template &lt;class K, class&#8230;&#8203; Args&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_or_assign"><a class="link" href="#unordered_node_map_insert_or_assign">insert_or_assign</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_or_assign</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load. <br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_insert_or_assign_with_hint"><a class="link" href="#unordered_node_map_insert_or_assign_with_hint">insert_or_assign with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">M</span><span class="p">&gt;</span>
  <span class="n">iterator</span> <span class="nf">insert_or_assign</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">M</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a new element into the container or updates an existing one by assigning to the contained value.</p>
</div>
<div class="paragraph">
<p>If there is an element with key <code>k</code>, then it is updated by assigning <code>boost::forward&lt;M&gt;(obj)</code>.</p>
</div>
<div class="paragraph">
<p>If there is no such element, it is added to the container as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="c1">// first two overloads</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

<span class="c1">// third overload</span>
<span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">)),</span>
           <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K, class M&gt;</code> only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_erase_by_position"><a class="link" href="#unordered_node_map_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_erase_by_key"><a class="link" href="#unordered_node_map_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_erase_range"><a class="link" href="#unordered_node_map_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_swap"><a class="link" href="#unordered_node_map_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_extract_by_position"><a class="link" href="#unordered_node_map_extract_by_position">Extract by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_extract_by_key"><a class="link" href="#unordered_node_map_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element with key equivalent to <code>k</code>, if it exists.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element, or empty if no element was extracted.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_clear"><a class="link" href="#unordered_node_map_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_merge"><a class="link" href="#unordered_node_map_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Transfers all the element nodes from <code>source</code> whose key is not already present in <code>*this</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_observers"><a class="link" href="#unordered_node_map_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_get_allocator"><a class="link" href="#unordered_node_map_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_hash_function"><a class="link" href="#unordered_node_map_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_key_eq"><a class="link" href="#unordered_node_map_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_lookup"><a class="link" href="#unordered_node_map_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_find"><a class="link" href="#unordered_node_map_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_count"><a class="link" href="#unordered_node_map_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_contains"><a class="link" href="#unordered_node_map_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_equal_range"><a class="link" href="#unordered_node_map_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_operator"><a class="link" href="#unordered_node_map_operator">operator[]</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">key_type</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>If the container does not already contain an element with a key equivalent to <code>k</code>, inserts the value <code>std::pair&lt;key_type const, mapped_type&gt;(k, mapped_type())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the element already in the container, or the newly inserted element with a key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_at"><a class="link" href="#unordered_node_map_at">at</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="k">const</span> <span class="n">mapped_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A reference to <code>x.second</code> where <code>x</code> is the (unique) element whose key is equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>An exception object of type <code>std::out_of_range</code> if no such element is present.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_bucket_interface"><a class="link" href="#unordered_node_map_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_bucket_count"><a class="link" href="#unordered_node_map_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_hash_policy"><a class="link" href="#unordered_node_map_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_load_factor"><a class="link" href="#unordered_node_map_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_max_load_factor"><a class="link" href="#unordered_node_map_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_set_max_load_factor"><a class="link" href="#unordered_node_map_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_map</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_max_load"><a class="link" href="#unordered_node_map_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_rehash"><a class="link" href="#unordered_node_map_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_reserve"><a class="link" href="#unordered_node_map_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_deduction_guides"><a class="link" href="#unordered_node_map_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_­type</code> parameter type in a deduction guide refers to the <code>size_­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iter_value_type"><a class="link" href="#unordered_node_map_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iter_key_type"><a class="link" href="#unordered_node_map_iter_key_type"><em>iter-key-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-key-type</em> = std::remove_const_t&lt;
    std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iter_mapped_type"><a class="link" href="#unordered_node_map_iter_mapped_type"><em>iter-mapped-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-mapped-type</em> =
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;;  // exposition only</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="unordered_node_map_iter_to_alloc_type"><a class="link" href="#unordered_node_map_iter_to_alloc_type"><em>iter-to-alloc-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-to-alloc-type</em> = std::pair&lt;
    std::add_const_t&lt;std::tuple_element_t&lt;0, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;,
    std::tuple_element_t&lt;1, <a href="#unordered_map_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_equality_comparisons"><a class="link" href="#unordered_node_map_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_node_map_operator_2"><a class="link" href="#unordered_node_map_operator_2">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_map_operator_3"><a class="link" href="#unordered_node_map_operator_3">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_map_swap_2"><a class="link" href="#unordered_node_map_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_map_erase_if"><a class="link" href="#unordered_node_map_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_node_map</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="unordered_node_set"><a class="link" href="#unordered_node_set">Class template unordered_node_set</a></h3>
<div class="paragraph">
<p><code>boost::unordered_node_set</code> — A node-based, open-addressing unordered associative container that stores unique values.</p>
</div>
<div class="paragraph">
<p><code>boost::unordered_node_set</code> uses an open-addressing layout like <code>boost::unordered_flat_set</code>, but,
being node-based, it provides pointer/iterator stability and node handling functionalities.
Its performance lies between those of <code>boost::unordered_set</code> and <code>boost::unordered_flat_set</code>.</p>
</div>
<div class="paragraph">
<p>As a result of its using open addressing, the interface of <code>boost::unordered_node_set</code> deviates in
a number of aspects from that of <code>boost::unordered_set</code>/<code>std::unordered_set</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>begin()</code> is not constant-time.</p>
</li>
<li>
<p><code>erase(iterator)</code> returns <code>void</code>.</p>
</li>
<li>
<p>There is no API for bucket handling (except <code>bucket_count</code>).</p>
</li>
<li>
<p>The maximum load factor of the container is managed internally and can&#8217;t be set by the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other than this, <code>boost::unordered_node_set</code> is mostly a drop-in replacement of standard
unordered associative containers.</p>
</div>
<div class="sect3">
<h4 id="unordered_node_set_synopsis"><a class="link" href="#unordered_node_set_synopsis">Synopsis</a></h4>
<div class="listingblock">
<div class="content">
<pre>// #include &lt;boost/unordered/unordered_node_set.hpp&gt;

namespace boost {
  template&lt;class Key,
           class Hash = boost::hash&lt;Key&gt;,
           class Pred = std::equal_to&lt;Key&gt;,
           class Allocator = std::allocator&lt;Key&gt;&gt;
  class unordered_node_set {
  public:
    // types
    using key_type             = Key;
    using value_type           = Key;
    using init_type            = Key;
    using hasher               = Hash;
    using key_equal            = Pred;
    using allocator_type       = Allocator;
    using pointer              = typename std::allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer        = typename std::allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference            = value_type&amp;;
    using const_reference      = const value_type&amp;;
    using size_type            = std::size_t;
    using difference_type      = std::ptrdiff_t;

    using iterator             = <em>implementation-defined</em>;
    using const_iterator       = <em>implementation-defined</em>;

    using node_type            = <em>implementation-defined</em>;
    using insert_return_type   = <em>implementation-defined</em>;

    // construct/copy/destroy
    <a href="#unordered_node_set_default_constructor">unordered_node_set</a>();
    explicit <a href="#unordered_node_set_bucket_count_constructor">unordered_node_set</a>(size_type n,
                                const hasher&amp; hf = hasher(),
                                const key_equal&amp; eql = key_equal(),
                                const allocator_type&amp; a = allocator_type());
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor">unordered_node_set</a>(InputIterator f, InputIterator l,
                         size_type n = <em>implementation-defined</em>,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_set_copy_constructor">unordered_node_set</a>(const unordered_node_set&amp; other);
    <a href="#unordered_node_set_move_constructor">unordered_node_set</a>(unordered_node_set&amp;&amp; other);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor_with_allocator">unordered_node_set</a>(InputIterator f, InputIterator l, const allocator_type&amp; a);
    explicit <a href="#unordered_node_set_allocator_constructor">unordered_node_set</a>(const Allocator&amp; a);
    <a href="#unordered_node_set_copy_constructor_with_allocator">unordered_node_set</a>(const unordered_node_set&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_set_move_constructor_with_allocator">unordered_node_set</a>(unordered_node_set&amp;&amp; other, const Allocator&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il,
                       size_type n = <em>implementation-defined</em>
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
    <a href="#unordered_node_set_bucket_count_constructor_with_allocator">unordered_node_set</a>(size_type n, const allocator_type&amp; a);
    <a href="#unordered_node_set_bucket_count_constructor_with_hasher_and_allocator">unordered_node_set</a>(size_type n, const hasher&amp; hf, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_allocator">unordered_node_set</a>(InputIterator f, InputIterator l, size_type n, const allocator_type&amp; a);
    template&lt;class InputIterator&gt;
      <a href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_hasher">unordered_node_set</a>(InputIterator f, InputIterator l, size_type n, const hasher&amp; hf,
                         const allocator_type&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor_with_allocator">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il, const allocator_type&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_allocator">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n,
                       const allocator_type&amp; a);
    <a href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">unordered_node_set</a>(std::initializer_list&lt;value_type&gt; il, size_type n, const hasher&amp; hf,
                       const allocator_type&amp; a);
    <a href="#unordered_node_set_destructor">~unordered_node_set</a>();
    unordered_node_set&amp; <a href="#unordered_node_set_copy_assignment">operator=</a>(const unordered_node_set&amp; other);
    unordered_node_set&amp; <a href="#unordered_node_set_move_assignment">operator=</a>(unordered_node_set&amp;&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
              boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_move_assignment::value);
    unordered_node_set&amp; <a href="#unordered_node_set_initializer_list_assignment">operator=</a>(std::initializer_list&lt;value_type&gt;);
    allocator_type <a href="#unordered_node_set_get_allocator">get_allocator</a>() const noexcept;

    // iterators
    iterator       <a href="#unordered_node_set_begin">begin</a>() noexcept;
    const_iterator <a href="#unordered_node_set_begin">begin</a>() const noexcept;
    iterator       <a href="#unordered_node_set_end">end</a>() noexcept;
    const_iterator <a href="#unordered_node_set_end">end</a>() const noexcept;
    const_iterator <a href="#unordered_node_set_cbegin">cbegin</a>() const noexcept;
    const_iterator <a href="#unordered_node_set_cend">cend</a>() const noexcept;

    // capacity
    [[nodiscard]] bool <a href="#unordered_node_set_empty">empty</a>() const noexcept;
    size_type <a href="#unordered_node_set_size">size</a>() const noexcept;
    size_type <a href="#unordered_node_set_max_size">max_size</a>() const noexcept;

    // modifiers
    template&lt;class... Args&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_emplace">emplace</a>(Args&amp;&amp;... args);
    template&lt;class... Args&gt; iterator <a href="#unordered_node_set_emplace_hint">emplace_hint</a>(const_iterator position, Args&amp;&amp;... args);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_copy_insert">insert</a>(const value_type&amp; obj);
    std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_move_insert">insert</a>(value_type&amp;&amp; obj);
    template&lt;class K&gt; std::pair&lt;iterator, bool&gt; <a href="#unordered_node_set_transparent_insert">insert</a>(K&amp;&amp; k);
    iterator <a href="#unordered_node_set_copy_insert_with_hint">insert</a>(const_iterator hint, const value_type&amp; obj);
    iterator <a href="#unordered_node_set_move_insert_with_hint">insert</a>(const_iterator hint, value_type&amp;&amp; obj);
    template&lt;class K&gt; iterator <a href="#unordered_node_set_transparent_insert_with_hint">insert</a>(const_iterator hint, K&amp;&amp; k);
    template&lt;class InputIterator&gt; void <a href="#unordered_node_set_insert_iterator_range">insert</a>(InputIterator first, InputIterator last);
    void <a href="#unordered_node_set_insert_initializer_list">insert</a>(std::initializer_list&lt;value_type&gt;);
    insert_return_type <a href="#unordered_node_set_insert_node">insert</a>(node_type&amp;&amp; nh);
    iterator <a href="#unordered_node_set_insert_node_with_hint">insert</a>(const_iterator hint, node_type&amp;&amp; nh);

    void      <a href="#unordered_node_set_erase_by_position">erase</a>(iterator position);
    void      <a href="#unordered_node_set_erase_by_position">erase</a>(const_iterator position);
    size_type <a href="#unordered_node_set_erase_by_key">erase</a>(const key_type&amp; k);
    template&lt;class K&gt; size_type <a href="#unordered_node_set_erase_by_key">erase</a>(K&amp;&amp; k);
    iterator  <a href="#unordered_node_set_erase_range">erase</a>(const_iterator first, const_iterator last);
    void      <a href="#unordered_node_set_swap">swap</a>(unordered_node_set&amp; other)
      noexcept(boost::allocator_traits&lt;Allocator&gt;::is_always_equal::value ||
               boost::allocator_traits&lt;Allocator&gt;::propagate_on_container_swap::value);
    node_type <a href="#unordered_node_set_extract_by_position">extract</a>(const_iterator position);
    node_type <a href="#unordered_node_set_extract_by_key">extract</a>(const key_type&amp; key);
    template&lt;class K&gt; node_type <a href="#unordered_node_set_extract_by_key">extract</a>(K&amp;&amp; key);
    void      <a href="#unordered_node_set_clear">clear</a>() noexcept;

    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_set_merge">merge</a>(unordered_node_set&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
      void <a href="#unordered_node_set_merge">merge</a>(unordered_node_set&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers
    hasher <a href="#unordered_node_set_hash_function">hash_function</a>() const;
    key_equal <a href="#unordered_node_set_key_eq">key_eq</a>() const;

    // set operations
    iterator         <a href="#unordered_node_set_find">find</a>(const key_type&amp; k);
    const_iterator   <a href="#unordered_node_set_find">find</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      iterator       <a href="#unordered_node_set_find">find</a>(const K&amp; k);
    template&lt;class K&gt;
      const_iterator <a href="#unordered_node_set_find">find</a>(const K&amp; k) const;
    size_type        <a href="#unordered_node_set_count">count</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      size_type      <a href="#unordered_node_set_count">count</a>(const K&amp; k) const;
    bool             <a href="#unordered_node_set_contains">contains</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      bool           <a href="#unordered_node_set_contains">contains</a>(const K&amp; k) const;
    std::pair&lt;iterator, iterator&gt;               <a href="#unordered_node_set_equal_range">equal_range</a>(const key_type&amp; k);
    std::pair&lt;const_iterator, const_iterator&gt;   <a href="#unordered_node_set_equal_range">equal_range</a>(const key_type&amp; k) const;
    template&lt;class K&gt;
      std::pair&lt;iterator, iterator&gt;             <a href="#unordered_node_set_equal_range">equal_range</a>(const K&amp; k);
    template&lt;class K&gt;
      std::pair&lt;const_iterator, const_iterator&gt; <a href="#unordered_node_set_equal_range">equal_range</a>(const K&amp; k) const;

    // bucket interface
    size_type <a href="#unordered_node_set_bucket_count">bucket_count</a>() const noexcept;

    // hash policy
    float <a href="#unordered_node_set_load_factor">load_factor</a>() const noexcept;
    float <a href="#unordered_node_set_max_load_factor">max_load_factor</a>() const noexcept;
    void <a href="#unordered_node_set_set_max_load_factor">max_load_factor</a>(float z);
    size_type <a href="#unordered_node_set_max_load">max_load</a>() const noexcept;
    void <a href="#unordered_node_set_rehash">rehash</a>(size_type n);
    void <a href="#unordered_node_set_reserve">reserve</a>(size_type n);
  };

  // Deduction Guides
  template&lt;class InputIterator,
           class Hash = boost::hash&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Pred = std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
           class Allocator = std::allocator&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;&gt;
    unordered_node_set(InputIterator, InputIterator, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash, Pred, Allocator&gt;;

  template&lt;class T, class Hash = boost::hash&lt;T&gt;, class Pred = std::equal_to&lt;T&gt;,
           class Allocator = std::allocator&lt;T&gt;&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type = <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>,
                       Hash = Hash(), Pred = Pred(), Allocator = Allocator())
      -&gt; unordered_node_set&lt;T, Hash, Pred, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_set(InputIterator, InputIterator, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Allocator&gt;
    unordered_node_set(InputIterator, InputIterator, Allocator)
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;,
                            boost::hash&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;,
                            std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class InputIterator, class Hash, class Allocator&gt;
    unordered_node_set(InputIterator, InputIterator, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Hash,
                       Allocator)
      -&gt; unordered_node_set&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;, Hash,
                            std::equal_to&lt;<a href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a>&lt;InputIterator&gt;&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Allocator)
      -&gt; unordered_node_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Allocator&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, Allocator)
      -&gt; unordered_node_set&lt;T, boost::hash&lt;T&gt;, std::equal_to&lt;T&gt;, Allocator&gt;;

  template&lt;class T, class Hash, class Allocator&gt;
    unordered_node_set(std::initializer_list&lt;T&gt;, typename <a href="#unordered_node_set_deduction_guides"><em>see below</em></a>::size_type, Hash, Allocator)
      -&gt; unordered_node_set&lt;T, Hash, std::equal_to&lt;T&gt;, Allocator&gt;;

  // Equality Comparisons
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_set_operator_2">operator!=</a>(const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool <a href="#unordered_node_set_operator_3">operator!=</a>(const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

  // swap
  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    void <a href="#unordered_node_set_swap_2">swap</a>(unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
              unordered_node_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y)
      noexcept(noexcept(x.swap(y)));

  template&lt;class K, class T, class H, class P, class A, class Predicate&gt;
    typename unordered_node_set&lt;K, T, H, P, A&gt;::size_type
       <a href="#unordered_node_set_erase_if">erase_if</a>(unordered_node_set&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_description"><a class="link" href="#unordered_node_set_description">Description</a></h4>
<div class="paragraph">
<p><strong>Template Parameters</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Key</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Key</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/Erasable" target="_blank" rel="noopener">Erasable</a> from the container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Hash</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A unary function object type that acts a hash function for a <code>Key</code>. It takes a single argument of type <code>Key</code> and returns a value of type <code>std::size_t</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Pred</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A binary function object that induces an equivalence relation on values of type <code>Key</code>. It takes two arguments of type <code>Key</code> and returns a value of type <code>bool</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Allocator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An allocator whose value type is the same as the container&#8217;s value type.
<code>std::allocator_traits&lt;Allocator&gt;::pointer</code> and <code>std::allocator_traits&lt;Allocator&gt;::const_pointer</code>
must be convertible to/from <code>value_type*</code> and <code>const value_type*</code>, respectively.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The element nodes of the container are held into an internal <em>bucket array</em>. A node is inserted into a bucket determined by
the hash code of its element, but if the bucket is already occupied (a <em>collision</em>), an available one in the vicinity of the
original position is used.</p>
</div>
<div class="paragraph">
<p>The size of the bucket array can be automatically increased by a call to <code>insert</code>/<code>emplace</code>, or as a result of calling
<code>rehash</code>/<code>reserve</code>. The <em>load factor</em> of the container (number of elements divided by number of buckets) is never
greater than <code>max_load_factor()</code>, except possibly for small sizes where the implementation may decide to
allow for higher loads.</p>
</div>
<div class="paragraph">
<p>If <code><a href="#hash_traits_hash_is_avalanching">hash_is_avalanching</a>&lt;Hash&gt;::value</code> is <code>true</code>, the hash function
is used as-is; otherwise, a bit-mixing post-processing stage is added to increase the quality of hashing
at the expense of extra computational cost.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_typedefs"><a class="link" href="#unordered_node_set_typedefs">Typedefs</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<div class="paragraph">
<p>Convertible to <code>const_iterator</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">const_iterator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A constant iterator whose value type is <code>value_type</code>.</p>
</div>
<div class="paragraph">
<p>The iterator category is at least a forward iterator.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">node_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A class for holding extracted container elements, modelling
<a href="https://en.cppreference.com/w/cpp/container/node_handle">NodeHandle</a>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span> <span class="n">insert_return_type</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of an internal class template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">NodeType</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc"><em>insert_return_type</em></span> <span class="c1">// name is exposition only</span>
<span class="p">{</span>
  <span class="n">Iterator</span> <span class="n">position</span><span class="p">;</span>
  <span class="kt">bool</span>     <span class="n">inserted</span><span class="p">;</span>
  <span class="n">NodeType</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>with <code>Iterator</code> = <code>iterator</code> and <code>NodeType</code> = <code>node_type</code>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_constructors"><a class="link" href="#unordered_node_set_constructors">Constructors</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_default_constructor"><a class="link" href="#unordered_node_set_default_constructor">Default Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>hasher()</code> as the hash function,
<code>key_equal()</code> as the key equality predicate and <code>allocator_type()</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_bucket_count_constructor"><a class="link" href="#unordered_node_set_bucket_count_constructor">Bucket Count Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_node_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                            <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash
function, <code>eql</code> as the key equality predicate, and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iterator_range_constructor"><a class="link" href="#unordered_node_set_iterator_range_constructor">Iterator Range Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span>
                     <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
                     <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code> as the allocator, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_copy_constructor"><a class="link" href="#unordered_node_set_copy_constructor">Copy Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">unordered_node_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The copy constructor. Copies the contained elements, hash function, predicate and allocator.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::select_on_container_copy_construction</code> exists and has the right signature, the allocator will be constructed from its result.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is copy constructible</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_constructor"><a class="link" href="#unordered_node_set_move_constructor">Move Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move constructor. The internal bucket array of <code>other</code> is transferred directly to the new container.
The hash function, predicate and allocator are moved-constructed from <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iterator_range_constructor_with_allocator"><a class="link" href="#unordered_node_set_iterator_range_constructor_with_allocator">Iterator Range Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> as the allocator, with the default hash function and key equality predicate and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_allocator_constructor"><a class="link" href="#unordered_node_set_allocator_constructor">Allocator Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">explicit</span> <span class="nf">unordered_node_set</span><span class="p">(</span><span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container, using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_copy_constructor_with_allocator"><a class="link" href="#unordered_node_set_copy_constructor_with_allocator">Copy Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">unordered_node_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a container, copying <code>other</code>'s contained elements, hash function, and predicate, but using allocator <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_constructor_with_allocator"><a class="link" href="#unordered_node_set_move_constructor_with_allocator">Move Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">,</span> <span class="n">Allocator</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>a == other.get_allocator()</code>, the element nodes of <code>other</code> are transferred directly to the new container;
otherwise, elements are moved-constructed from those of <code>other</code>. The hash function and predicate are moved-constructed
from <code>other</code>, and the allocator is copy-constructed from <code>a</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_constructor"><a class="link" href="#unordered_node_set_initializer_list_constructor">Initializer List Constructor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span>
              <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n"><em>implementation</span><span class="o">-</span><span class="n">defined</em></span>
              <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">hasher</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">key_equal</span><span class="o">&amp;</span> <span class="n">eql</span> <span class="o">=</span> <span class="n">key_equal</span><span class="p">(),</span>
              <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">allocator_type</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>eql</code> as the key equality predicate and <code>a</code>, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p>If the defaults are used, <code>hasher</code>, <code>key_equal</code> and <code>allocator_type</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_bucket_count_constructor_with_allocator"><a class="link" href="#unordered_node_set_bucket_count_constructor_with_allocator">Bucket Count Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default hash function and key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_bucket_count_constructor_with_hasher_and_allocator"><a class="link" href="#unordered_node_set_bucket_count_constructor_with_hasher_and_allocator">Bucket Count Constructor with Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">hasher</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span> <span class="n">allocator_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, the default key equality predicate and <code>a</code> as the allocator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iterator_range_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_allocator">Iterator Range Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
  <span class="n">unordered_node_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> as the allocator and default hash function and key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code>, <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iterator_range_constructor_with_bucket_count_and_hasher"><a class="link" href="#unordered_node_set_iterator_range_constructor_with_bucket_count_and_hasher">Iterator Range Constructor with Bucket Count and Hasher</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span>
      <span class="n">unordered_node_set</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">f</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">l</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator, with the default key equality predicate, and inserts the elements from <code>[f, l)</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_constructor_with_allocator"><a class="link" href="#unordered_node_set_initializer_list_constructor_with_allocator">initializer_list Constructor with Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_constructor_with_bucket_count_and_allocator"><a class="link" href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_allocator">initializer_list Constructor with Bucket Count and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>a</code> and default hash function and key equality predicate, and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>hasher</code> and <code>key_equal</code> need to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator"><a class="link" href="#unordered_node_set_initializer_list_constructor_with_bucket_count_and_hasher_and_allocator">initializer_list Constructor with Bucket Count and Hasher and Allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">hasher</span><span class="o">&amp;</span> <span class="n">hf</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">allocator_type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs an empty container with at least <code>n</code> buckets, using <code>hf</code> as the hash function, <code>a</code> as the allocator and default key equality predicate,and inserts the elements from <code>il</code> into it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>key_equal</code> needs to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_blank" rel="noopener">DefaultConstructible</a>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_destructor"><a class="link" href="#unordered_node_set_destructor">Destructor</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="o">~</span><span class="n">unordered_node_set</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>The destructor is applied to every element, and all memory is deallocated</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_assignment"><a class="link" href="#unordered_node_set_assignment">Assignment</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_copy_assignment"><a class="link" href="#unordered_node_set_copy_assignment">Copy Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_node_set</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The assignment operator. Destroys previously existing elements, copy-assigns the hash function and predicate from <code>other</code>,
copy-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_copy_assignment</code> exists and <code>Alloc::propagate_on_container_copy_assignment::value</code> is <code>true</code>,
and finally inserts copies of the elements of <code>other</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_assignment"><a class="link" href="#unordered_node_set_move_assignment">Move Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_move_assignment</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The move assignment operator. Destroys previously existing elements, swaps the hash function and predicate from <code>other</code>,
and move-assigns the allocator from <code>other</code> if <code>Alloc::propagate_on_container_move_assignment</code> exists and <code>Alloc::propagate_on_container_move_assignment::value</code> is <code>true</code>.
If at this point the allocator is equal to <code>other.get_allocator()</code>, the internal bucket array of <code>other</code> is transferred directly to the new container;
otherwise, inserts move-constructed copies of the elements of <code>other</code>.</p>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_initializer_list_assignment"><a class="link" href="#unordered_node_set_initializer_list_assignment">Initializer List Assignment</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">unordered_node_set</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Assign from values in initializer list. All previously existing elements are destroyed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_iterators"><a class="link" href="#unordered_node_set_iterators">Iterators</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_begin"><a class="link" href="#unordered_node_set_begin">begin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_end"><a class="link" href="#unordered_node_set_end">end</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_cbegin"><a class="link" href="#unordered_node_set_cbegin">cbegin</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> referring to the first element of the container, or if the container is empty the past-the-end value for the container.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Complexity:
</td>
<td class="hdlist2">
<p>O(<code>bucket_count()</code>)</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_cend"><a class="link" href="#unordered_node_set_cend">cend</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>const_iterator</code> which refers to the past-the-end value for the container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_size_and_capacity"><a class="link" href="#unordered_node_set_size_and_capacity">Size and Capacity</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_empty"><a class="link" href="#unordered_node_set_empty">empty</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size() == 0</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_size"><a class="link" href="#unordered_node_set_size">size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>std::distance(begin(), end())</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_max_size"><a class="link" href="#unordered_node_set_max_size">max_size</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>size()</code> of the largest possible container.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_modifiers"><a class="link" href="#unordered_node_set_modifiers">Modifiers</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_emplace"><a class="link" href="#unordered_node_set_emplace">emplace</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">emplace</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_emplace_hint"><a class="link" href="#unordered_node_set_emplace_hint">emplace_hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++">    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="n">iterator</span> <span class="nf">emplace_hint</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an object, constructed with the arguments <code>args</code>, in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>position</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is constructible from <code>args</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_copy_insert"><a class="link" href="#unordered_node_set_copy_insert">Copy Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_insert"><a class="link" href="#unordered_node_set_move_insert">Move Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_transparent_insert"><a class="link" href="#unordered_node_set_transparent_insert">Transparent Insert</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_copy_insert_with_hint"><a class="link" href="#unordered_node_set_copy_insert_with_hint">Copy Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyInsertable" target="_blank" rel="noopener">CopyInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_move_insert_with_hint"><a class="link" href="#unordered_node_set_move_insert_with_hint">Move Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts <code>obj</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveInsertable" target="_blank" rel="noopener">MoveInsertable</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The <code>bool</code> component of the return type is <code>true</code> if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_transparent_insert_with_hint"><a class="link" href="#unordered_node_set_transparent_insert_with_hint">Transparent Insert with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts an element constructed from <code>std::forward&lt;K&gt;(k)</code> in the container if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> from <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The bool component of the return type is true if an insert took place.<br></p>
<div class="paragraph">
<p>If an insert took place, then the iterator points to the newly inserted element. Otherwise, it points to the element with equivalent key.</p>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.<br></p>
<div class="paragraph">
<p>This overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_insert_iterator_range"><a class="link" href="#unordered_node_set_insert_iterator_range">Insert Iterator Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_insert_initializer_list"><a class="link" href="#unordered_node_set_insert_initializer_list">Insert Initializer List</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inserts a range of elements into the container. Elements are inserted if and only if there is no element in the container with an equivalent key.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires:
</td>
<td class="hdlist2">
<p><code>value_type</code> is <a href="https://en.cppreference.com/w/cpp/named_req/EmplaceConstructible" target="_blank" rel="noopener">EmplaceConstructible</a> into the container from <code>*first</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>When inserting a single element, if an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Can invalidate iterators, but only if the insert causes the load to be greater than the maximum load.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_insert_node"><a class="link" href="#unordered_node_set_insert_node">Insert Node</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">insert_return_type</span> <span class="nf">insert</span><span class="p">(</span><span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.value()</code>.
<code>nh</code> is empty when the function returns.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An <code>insert_return_type</code> object constructed from <code>position</code>, <code>inserted</code> and <code>node</code>:<br></p>
<div class="ulist">
<ul>
<li>
<p>If <code>nh</code> is empty, <code>inserted</code> is <code>false</code>, <code>position</code> is <code>end()</code>, and <code>node</code> is empty.</p>
</li>
<li>
<p>Otherwise if the insertion took place, <code>inserted</code> is true, <code>position</code> points to the inserted element, and <code>node</code> is empty.</p>
</li>
<li>
<p>If the insertion failed, <code>inserted</code> is false, <code>node</code> has the previous value of <code>nh</code>, and <code>position</code> points to an element with a key equivalent to <code>nh.value()</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_insert_node_with_hint"><a class="link" href="#unordered_node_set_insert_node_with_hint">Insert Node with Hint</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">hint</span><span class="p">,</span> <span class="n">node_type</span><span class="o">&amp;&amp;</span> <span class="n">nh</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>nh</code> is not empty, inserts the associated element in the container if and only if there is no element in the container with a key equivalent to <code>nh.value()</code>.
<code>nh</code> becomes empty if insertion took place, otherwise it is not changed.</p>
</div>
<div class="paragraph">
<p><code>hint</code> is a suggestion to where the element should be inserted. This implementation ignores it.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator returned is <code>end()</code> if <code>nh</code> is empty.
If insertion took place, then the iterator points to the newly inserted element; otherwise, it points to the element with equivalent key.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>If an exception is thrown by an operation other than a call to <code>hasher</code> the function has no effect.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if <code>nh</code> is not empty and the allocators of <code>nh</code> and the container are not equal.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_erase_by_position"><a class="link" href="#unordered_node_set_erase_by_position">Erase by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_erase_by_key"><a class="link" href="#unordered_node_set_erase_by_key">Erase by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erase all elements with key equivalent to <code>k</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_erase_range"><a class="link" href="#unordered_node_set_erase_range">Erase Range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases the elements in the range from <code>first</code> to <code>last</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The iterator following the erased elements - i.e. <code>last</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing in this implementation (neither the <code>hasher</code> nor the <code>key_equal</code> objects are called).</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_swap"><a class="link" href="#unordered_node_set_swap">swap</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
  <span class="k">noexcept</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">is_always_equal</span><span class="o">::</span><span class="n">value</span> <span class="o">||</span>
           <span class="n">boost</span><span class="o">::</span><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;::</span><span class="n">propagate_on_container_swap</span><span class="o">::</span><span class="n">value</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of the container with the parameter.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_extract_by_position"><a class="link" href="#unordered_node_set_extract_by_position">Extract by Position</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">extract</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">position</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element pointed to by <code>position</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_extract_by_key"><a class="link" href="#unordered_node_set_extract_by_key">Extract by Key</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">node_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span> <span class="n">node_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">K</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Extracts the element with key equivalent to <code>k</code>, if it exists.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A <code>node_type</code> object holding the extracted element, or empty if no element was extracted.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Only throws an exception if it is thrown by <code>hasher</code> or <code>key_equal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template&lt;class K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs and neither <code>iterator</code> nor <code>const_iterator</code> are implicitly convertible from <code>K</code>. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_clear"><a class="link" href="#unordered_node_set_clear">clear</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Erases all elements in the container.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions:
</td>
<td class="hdlist2">
<p><code>size() == 0</code>, <code>max_load() &gt;= max_load_factor() * bucket_count()</code></p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_merge"><a class="link" href="#unordered_node_set_merge">merge</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">source</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">H2</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P2</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H2</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">source</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Transfers all the element nodes from <code>source</code> whose key is not already present in <code>*this</code>.</p>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_observers"><a class="link" href="#unordered_node_set_observers">Observers</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_get_allocator"><a class="link" href="#unordered_node_set_get_allocator">get_allocator</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s allocator.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_hash_function"><a class="link" href="#unordered_node_set_hash_function">hash_function</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">hasher</span> <span class="n">hash_function</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s hash function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_key_eq"><a class="link" href="#unordered_node_set_key_eq">key_eq</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">key_equal</span> <span class="n">key_eq</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The container&#8217;s key equality predicate</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_lookup"><a class="link" href="#unordered_node_set_lookup">Lookup</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_find"><a class="link" href="#unordered_node_set_find">find</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">iterator</span>         <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">const_iterator</span>   <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">iterator</span>       <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>An iterator pointing to an element with key equivalent to <code>k</code>, or <code>end()</code> if no such element exists.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_count"><a class="link" href="#unordered_node_set_count">count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span>        <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">size_type</span>      <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of elements with key equivalent to <code>k</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_contains"><a class="link" href="#unordered_node_set_contains">contains</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">bool</span>             <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="kt">bool</span>           <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A boolean indicating whether or not there is an element with key equal to <code>key</code> in the container</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overload only participates in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_equal_range"><a class="link" href="#unordered_node_set_equal_range">equal_range</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>               <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span>   <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span>             <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="p">,</span> <span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">K</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>A range containing all elements with key equivalent to <code>k</code>. If the container doesn&#8217;t contain any such elements, returns <code>std::make_pair(b.end(), b.end())</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>The <code>template &lt;typename K&gt;</code> overloads only participate in overload resolution if <code>Hash::is_transparent</code> and <code>Pred::is_transparent</code> are valid member typedefs. The library assumes that <code>Hash</code> is callable with both <code>K</code> and <code>Key</code> and that <code>Pred</code> is transparent. This enables heterogeneous lookup which avoids the cost of instantiating an instance of the <code>Key</code> type.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_bucket_interface"><a class="link" href="#unordered_node_set_bucket_interface">Bucket Interface</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_bucket_count"><a class="link" href="#unordered_node_set_bucket_count">bucket_count</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The size of the bucket array.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_hash_policy"><a class="link" href="#unordered_node_set_hash_policy">Hash Policy</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_load_factor"><a class="link" href="#unordered_node_set_load_factor">load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p><code>static_cast&lt;float&gt;(size())/static_cast&lt;float&gt;(bucket_count())</code>, or <code>0</code> if <code>bucket_count() == 0</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_max_load_factor"><a class="link" href="#unordered_node_set_max_load_factor">max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">float</span> <span class="n">max_load_factor</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>Returns the container&#8217;s maximum load factor.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_set_max_load_factor"><a class="link" href="#unordered_node_set_set_max_load_factor">Set max_load_factor</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">max_load_factor</span><span class="p">(</span><span class="kt">float</span> <span class="n">z</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p>Does nothing, as the user is not allowed to change this parameter. Kept for compatibility with <code>boost::unordered_set</code>.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_max_load"><a class="link" href="#unordered_node_set_max_load">max_load</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="n">size_type</span> <span class="n">max_load</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The maximum number of elements the container can hold without rehashing, assuming that no further elements will be erased.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note:
</td>
<td class="hdlist2">
<p>After construction, rehash or clearance, the container&#8217;s maximum load is at least <code>max_load_factor() * bucket_count()</code>.
This number may decrease on erasure under high-load conditions.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_rehash"><a class="link" href="#unordered_node_set_rehash">rehash</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">rehash</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes if necessary the size of the bucket array so that there are at least <code>n</code> buckets, and so that the load factor is less than or equal to the maximum load factor. When applicable, this will either grow or shrink the <code>bucket_count()</code> associated with the container.</p>
</div>
<div class="paragraph">
<p>When <code>size() == 0</code>, <code>rehash(0)</code> will deallocate the underlying buckets array.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_reserve"><a class="link" href="#unordered_node_set_reserve">reserve</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>a.rehash(ceil(n / a.max_load_factor()))</code>.</p>
</div>
<div class="paragraph">
<p>Similar to <code>rehash</code>, this function can be used to grow or shrink the number of buckets in the container.</p>
</div>
<div class="paragraph">
<p>Invalidates iterators and changes the order of elements.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>The function has no effect if an exception is thrown, unless it is thrown by the container&#8217;s hash function or comparison function.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_deduction_guides"><a class="link" href="#unordered_node_set_deduction_guides">Deduction Guides</a></h4>
<div class="paragraph">
<p>A deduction guide will not participate in overload resolution if any of the following are true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It has an <code>InputIterator</code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p>
</li>
<li>
<p>It has an <code>Allocator</code> template parameter and a type that does not qualify as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Hash</code> template parameter and an integral type or a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
<li>
<p>It has a <code>Pred</code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>size_­type</code> parameter type in a deduction guide refers to the <code>size_­type</code> member type of the
container type deduced by the deduction guide. Its default value coincides with the default value
of the constructor selected.</p>
</div>
<div class="sect4">
<h5 id="unordered_node_set_iter_value_type"><a class="link" href="#unordered_node_set_iter_value_type"><em>iter-value-type</em></a></h5>
<div class="listingblock">
<div class="content">
<pre>template&lt;class InputIterator&gt;
  using <em>iter-value-type</em> =
    typename std::iterator_traits&lt;InputIterator&gt;::value_type; // exposition only</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_equality_comparisons"><a class="link" href="#unordered_node_set_equality_comparisons">Equality Comparisons</a></h4>
<div class="sect4">
<h5 id="unordered_node_set_operator"><a class="link" href="#unordered_node_set_operator">operator==</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect4">
<h5 id="unordered_node_set_operator_2"><a class="link" href="#unordered_node_set_operator_2">operator!=</a></h5>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>false</code> if <code>x.size() == y.size()</code> and for every element in <code>x</code>, there is an element in <code>y</code> with the same key, with an equal value (using <code>operator==</code> to compare the value types).</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Behavior is undefined if the two containers don&#8217;t have equivalent equality predicates.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unordered_node_set_swap_2"><a class="link" href="#unordered_node_set_swap_2">Swap</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">Pred</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">noexcept</span><span class="p">(</span><span class="k">noexcept</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">y</span><span class="p">)));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Swaps the contents of <code>x</code> and <code>y</code>.</p>
</div>
<div class="paragraph">
<p>If <code>Allocator::propagate_on_container_swap</code> is declared and <code>Allocator::propagate_on_container_swap::value</code> is <code>true</code> then the containers' allocators are swapped. Otherwise, swapping with unequal allocators results in undefined behavior.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effects:
</td>
<td class="hdlist2">
<p><code>x.swap(y)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Throws:
</td>
<td class="hdlist2">
<p>Nothing unless <code>key_equal</code> or <code>hasher</code> throw on swapping.</p>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="unordered_node_set_erase_if"><a class="link" href="#unordered_node_set_erase_if">erase_if</a></h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">K</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">H</span><span class="p">,</span> <span class="k">class</span> <span class="nc">P</span><span class="p">,</span> <span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;::</span><span class="n">size_type</span>
    <span class="nf">erase_if</span><span class="p">(</span><span class="n">unordered_node_set</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Traverses the container <code>c</code> and removes all elements for which the supplied predicate returns <code>true</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns:
</td>
<td class="hdlist2">
<p>The number of erased elements.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Notes:
</td>
<td class="hdlist2">
<p>Equivalent to:<br></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">auto</span> <span class="n">original_size</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">last</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">original_size</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span><span class="p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="changes"><a class="link" href="#changes">Change Log</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="changes_release_1_82_0_major_update"><a class="link" href="#changes_release_1_82_0_major_update">Release 1.82.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>C++03 support is planned for deprecation. Boost 1.84.0 will no longer support
C++03 mode and C++11 will become the new minimum for using the library.</p>
</li>
<li>
<p>Added node-based, open-addressing containers
<code>boost::unordered_node_map</code> and <code>boost::unordered_node_set</code>.</p>
</li>
<li>
<p>Extended heterogeneous lookup to more member functions as specified in
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html">P2363</a>.</p>
</li>
<li>
<p>Replaced the previous post-mixing process for open-addressing containers with
a new algorithm based on extended multiplication by a constant.</p>
</li>
<li>
<p>Fixed bug in internal emplace() impl where stack-local types were not properly
constructed using the Allocator of the container which breaks uses-allocator
construction.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_81_0_major_update"><a class="link" href="#changes_release_1_81_0_major_update">Release 1.81.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>Added fast containers <code>boost::unordered_flat_map</code> and <code>boost::unordered_flat_set</code>
based on open addressing.</p>
</li>
<li>
<p>Added CTAD deduction guides for all containers.</p>
</li>
<li>
<p>Added missing constructors as specified in <a href="https://cplusplus.github.io/LWG/issue2713">LWG issue 2713</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_80_0_major_update"><a class="link" href="#changes_release_1_80_0_major_update">Release 1.80.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>Refactor internal implementation to be dramatically faster</p>
</li>
<li>
<p>Allow <code>final</code> Hasher and KeyEqual objects</p>
</li>
<li>
<p>Update documentation, adding benchmark graphs and notes on the new internal
data structures</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_79_0"><a class="link" href="#changes_release_1_79_0">Release 1.79.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Improved C++20 support:</p>
<div class="ulist">
<ul>
<li>
<p>All containers have been updated to support
heterogeneous <code>count</code>, <code>equal_range</code> and <code>find</code>.</p>
</li>
<li>
<p>All containers now implement the member function <code>contains</code>.</p>
</li>
<li>
<p><code>erase_if</code> has been implemented for all containers.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Improved C++23 support:</p>
<div class="ulist">
<ul>
<li>
<p>All containers have been updated to support
heterogeneous <code>erase</code> and <code>extract</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Changed behavior of <code>reserve</code> to eagerly
allocate (<a href="https://github.com/boostorg/unordered/pull/59" target="_blank" rel="noopener">PR#59</a>).</p>
</li>
<li>
<p>Various warning fixes in the test suite.</p>
</li>
<li>
<p>Update code to internally use <code>boost::allocator_traits</code>.</p>
</li>
<li>
<p>Switch to Fibonacci hashing.</p>
</li>
<li>
<p>Update documentation to be written in AsciiDoc instead of QuickBook.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_67_0"><a class="link" href="#changes_release_1_67_0">Release 1.67.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Improved C++17 support:</p>
<div class="ulist">
<ul>
<li>
<p>Add template deduction guides from the standard.</p>
</li>
<li>
<p>Use a simple implementation of <code>optional</code> in node handles, so
that they&#8217;re closer to the standard.</p>
</li>
<li>
<p>Add missing <code>noexcept</code> specifications to <code>swap</code>, <code>operator=</code>
and node handles, and change the implementation to match.
Using <code>std::allocator_traits::is_always_equal</code>, or our own
implementation when not available, and
<code>boost::is_nothrow_swappable</code> in the implementation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Improved C++20 support:</p>
<div class="ulist">
<ul>
<li>
<p>Use <code>boost::to_address</code>, which has the proposed C++20 semantics,
rather than the old custom implementation.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Add <code>element_type</code> to iterators, so that <code>std::pointer_traits</code>
will work.</p>
</li>
<li>
<p>Use <code>std::piecewise_construct</code> on recent versions of Visual C++,
and other uses of the Dinkumware standard library,
now using Boost.Predef to check compiler and library versions.</p>
</li>
<li>
<p>Use <code>std::iterator_traits</code> rather than the boost iterator traits
in order to remove dependency on Boost.Iterator.</p>
</li>
<li>
<p>Remove iterators' inheritance from <code>std::iterator</code>, which is
deprecated in C++17, thanks to Daniela Engert
(<a href="https://github.com/boostorg/unordered/pull/7" target="_blank" rel="noopener">PR#7</a>).</p>
</li>
<li>
<p>Stop using <code>BOOST_DEDUCED_TYPENAME</code>.</p>
</li>
<li>
<p>Update some Boost include paths.</p>
</li>
<li>
<p>Rename some internal methods, and variables.</p>
</li>
<li>
<p>Various testing improvements.</p>
</li>
<li>
<p>Miscellaneous internal changes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_66_0"><a class="link" href="#changes_release_1_66_0">Release 1.66.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Simpler move construction implementation.</p>
</li>
<li>
<p>Documentation fixes (<a href="https://github.com/boostorg/unordered/pull/6" target="_blank" rel="noopener">GitHub #6</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_65_0"><a class="link" href="#changes_release_1_65_0">Release 1.65.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Add deprecated attributes to <code>quick_erase</code> and <code>erase_return_void</code>.
I really will remove them in a future version this time.</p>
</li>
<li>
<p>Small standards compliance fixes:</p>
<div class="ulist">
<ul>
<li>
<p><code>noexpect</code> specs for <code>swap</code> free functions.</p>
</li>
<li>
<p>Add missing <code>insert(P&amp;&amp;)</code> methods.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_64_0"><a class="link" href="#changes_release_1_64_0">Release 1.64.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Initial support for new C++17 member functions:
<code>insert_or_assign</code> and <code>try_emplace</code> in <code>unordered_map</code>,</p>
</li>
<li>
<p>Initial support for <code>merge</code> and <code>extract</code>.
Does not include transferring nodes between
<code>unordered_map</code> and <code>unordered_multimap</code> or between <code>unordered_set</code> and
<code>unordered_multiset</code> yet. That will hopefully be in the next version of
Boost.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_63_0"><a class="link" href="#changes_release_1_63_0">Release 1.63.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Check hint iterator in <code>insert</code>/<code>emplace_hint</code>.</p>
</li>
<li>
<p>Fix some warnings, mostly in the tests.</p>
</li>
<li>
<p>Manually write out <code>emplace_args</code> for small numbers of arguments -
should make template error messages a little more bearable.</p>
</li>
<li>
<p>Remove superfluous use of <code>boost::forward</code> in emplace arguments,
which fixes emplacing string literals in old versions of Visual C++.</p>
</li>
<li>
<p>Fix an exception safety issue in assignment. If bucket allocation
throws an exception, it can overwrite the hash and equality functions while
leaving the existing elements in place. This would mean that the function
objects wouldn&#8217;t match the container elements, so elements might be in the
wrong bucket and equivalent elements would be incorrectly handled.</p>
</li>
<li>
<p>Various reference documentation improvements.</p>
</li>
<li>
<p>Better allocator support (<a href="https://svn.boost.org/trac/boost/ticket/12459" target="_blank" rel="noopener">#12459</a>).</p>
</li>
<li>
<p>Make the no argument constructors implicit.</p>
</li>
<li>
<p>Implement missing allocator aware constructors.</p>
</li>
<li>
<p>Fix assigning the hash/key equality functions for empty containers.</p>
</li>
<li>
<p>Remove unary/binary_function from the examples in the documentation.
They are removed in C++17.</p>
</li>
<li>
<p>Support 10 constructor arguments in emplace. It was meant to support up to 10
arguments, but an off by one error in the preprocessor code meant it only
supported up to 9.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_62_0"><a class="link" href="#changes_release_1_62_0">Release 1.62.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Remove use of deprecated <code>boost::iterator</code>.</p>
</li>
<li>
<p>Remove <code>BOOST_NO_STD_DISTANCE</code> workaround.</p>
</li>
<li>
<p>Remove <code>BOOST_UNORDERED_DEPRECATED_EQUALITY</code> warning.</p>
</li>
<li>
<p>Simpler implementation of assignment, fixes an exception safety issue
for <code>unordered_multiset</code> and <code>unordered_multimap</code>. Might be a little slower.</p>
</li>
<li>
<p>Stop using return value SFINAE which some older compilers have issues
with.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_58_0"><a class="link" href="#changes_release_1_58_0">Release 1.58.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Remove unnecessary template parameter from const iterators.</p>
</li>
<li>
<p>Rename private <code>iterator</code> typedef in some iterator classes, as it
confuses some traits classes.</p>
</li>
<li>
<p>Fix move assignment with stateful, propagate_on_container_move_assign
allocators (<a href="https://svn.boost.org/trac/boost/ticket/10777" target="_blank" rel="noopener">#10777</a>).</p>
</li>
<li>
<p>Fix rare exception safety issue in move assignment.</p>
</li>
<li>
<p>Fix potential overflow when calculating number of buckets to allocate
(<a href="https://github.com/boostorg/unordered/pull/4" target="_blank" rel="noopener">GitHub #4</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_57_0"><a class="link" href="#changes_release_1_57_0">Release 1.57.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix the <code>pointer</code> typedef in iterators (<a href="https://svn.boost.org/trac/boost/ticket/10672" target="_blank" rel="noopener">#10672</a>).</p>
</li>
<li>
<p>Fix Coverity warning
(<a href="https://github.com/boostorg/unordered/pull/2" target="_blank" rel="noopener">GitHub #2</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_56_0"><a class="link" href="#changes_release_1_56_0">Release 1.56.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix some shadowed variable warnings (<a href="https://svn.boost.org/trac/boost/ticket/9377" target="_blank" rel="noopener">#9377</a>).</p>
</li>
<li>
<p>Fix allocator use in documentation (<a href="https://svn.boost.org/trac/boost/ticket/9719" target="_blank" rel="noopener">#9719</a>).</p>
</li>
<li>
<p>Always use prime number of buckets for integers. Fixes performance
regression when inserting consecutive integers, although makes other
uses slower (<a href="https://svn.boost.org/trac/boost/ticket/9282" target="_blank" rel="noopener">#9282</a>).</p>
</li>
<li>
<p>Only construct elements using allocators, as specified in C++11 standard.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_55_0"><a class="link" href="#changes_release_1_55_0">Release 1.55.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Avoid some warnings (<a href="https://svn.boost.org/trac/boost/ticket/8851" target="_blank" rel="noopener">#8851</a>, <a href="https://svn.boost.org/trac/boost/ticket/8874" target="_blank" rel="noopener">#8874</a>).</p>
</li>
<li>
<p>Avoid exposing some detail functions via. ADL on the iterators.</p>
</li>
<li>
<p>Follow the standard by only using the allocators' construct and destroy
methods to construct and destroy stored elements. Don&#8217;t use them for internal
data like pointers.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_54_0"><a class="link" href="#changes_release_1_54_0">Release 1.54.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Mark methods specified in standard as <code>noexpect</code>. More to come in the next
release.</p>
</li>
<li>
<p>If the hash function and equality predicate are known to both have nothrow
move assignment or construction then use them.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_53_0"><a class="link" href="#changes_release_1_53_0">Release 1.53.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Remove support for the old pre-standard variadic pair constructors, and
equality implementation. Both have been deprecated since Boost 1.48.</p>
</li>
<li>
<p>Remove use of deprecated config macros.</p>
</li>
<li>
<p>More internal implementation changes, including a much simpler
implementation of <code>erase</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_52_0"><a class="link" href="#changes_release_1_52_0">Release 1.52.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Faster assign, which assigns to existing nodes where possible, rather than
creating entirely new nodes and copy constructing.</p>
</li>
<li>
<p>Fixed bug in <code>erase_range</code> (<a href="https://svn.boost.org/trac/boost/ticket/7471" target="_blank" rel="noopener">#7471</a>).</p>
</li>
<li>
<p>Reverted some of the internal changes to how nodes are created, especially
for C++11 compilers. 'construct' and 'destroy' should work a little better
for C++11 allocators.</p>
</li>
<li>
<p>Simplified the implementation a bit. Hopefully more robust.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_51_0"><a class="link" href="#changes_release_1_51_0">Release 1.51.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix construction/destruction issue when using a C++11 compiler with a
C++03 allocator (<a href="https://svn.boost.org/trac/boost/ticket/7100" target="_blank" rel="noopener">#7100</a>).</p>
</li>
<li>
<p>Remove a <code>try..catch</code> to support compiling without exceptions.</p>
</li>
<li>
<p>Adjust SFINAE use to try to support g++ 3.4 (<a href="https://svn.boost.org/trac/boost/ticket/7175" target="_blank" rel="noopener">#7175</a>).</p>
</li>
<li>
<p>Updated to use the new config macros.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_50_0"><a class="link" href="#changes_release_1_50_0">Release 1.50.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix equality for <code>unordered_multiset</code> and <code>unordered_multimap</code>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6857" target="_blank" rel="noopener">Ticket 6857</a>:
Implement <code>reserve</code>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6771" target="_blank" rel="noopener">Ticket 6771</a>:
Avoid gcc&#8217;s <code>-Wfloat-equal</code> warning.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6784" target="_blank" rel="noopener">Ticket 6784</a>:
Fix some Sun specific code.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6190" target="_blank" rel="noopener">Ticket 6190</a>:
Avoid gcc&#8217;s <code>-Wshadow</code> warning.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/6905" target="_blank" rel="noopener">Ticket 6905</a>:
Make namespaces in macros compatible with <code>bcp</code> custom namespaces.
Fixed by Luke Elliott.</p>
</li>
<li>
<p>Remove some of the smaller prime number of buckets, as they may make
collisions quite probable (e.g. multiples of 5 are very common because
we used base 10).</p>
</li>
<li>
<p>On old versions of Visual C++, use the container library&#8217;s implementation
of <code>allocator_traits</code>, as it&#8217;s more likely to work.</p>
</li>
<li>
<p>On machines with 64 bit std::size_t, use power of 2 buckets, with Thomas
Wang&#8217;s hash function to pick which one to use. As modulus is very slow
for 64 bit values.</p>
</li>
<li>
<p>Some internal changes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_49_0"><a class="link" href="#changes_release_1_49_0">Release 1.49.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix warning due to accidental odd assignment.</p>
</li>
<li>
<p>Slightly better error messages.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_48_0_major_update"><a class="link" href="#changes_release_1_48_0_major_update">Release 1.48.0 - Major update</a></h3>
<div class="paragraph">
<p>This is major change which has been converted to use Boost.Move&#8217;s move
emulation, and be more compliant with the C++11 standard. See the
<a href="#compliance">compliance section</a> for details.</p>
</div>
<div class="paragraph">
<p>The container now meets C++11&#8217;s complexity requirements, but to do so
uses a little more memory. This means that <code>quick_erase</code> and
<code>erase_return_void</code> are no longer required, they&#8217;ll be removed in a
future version.</p>
</div>
<div class="paragraph">
<p>C++11 support has resulted in some breaking changes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Equality comparison has been changed to the C++11 specification.
In a container with equivalent keys, elements in a group with equal
keys used to have to be in the same order to be considered equal,
now they can be a permutation of each other. To use the old
behavior define the macro <code>BOOST_UNORDERED_DEPRECATED_EQUALITY</code>.</p>
</li>
<li>
<p>The behaviour of swap is different when the two containers to be
swapped has unequal allocators. It used to allocate new nodes using
the appropriate allocators, it now swaps the allocators if
the allocator has a member structure <code>propagate_on_container_swap</code>,
such that <code>propagate_on_container_swap::value</code> is true.</p>
</li>
<li>
<p>Allocator&#8217;s <code>construct</code> and <code>destroy</code> functions are called with raw
pointers, rather than the allocator&#8217;s <code>pointer</code> type.</p>
</li>
<li>
<p><code>emplace</code> used to emulate the variadic pair constructors that
appeared in early C++0x drafts. Since they were removed it no
longer does so. It does emulate the new <code>piecewise_construct</code>
pair constructors - only you need to use
<code>boost::piecewise_construct</code>. To use the old emulation of
the variadic constructors define
<code>BOOST_UNORDERED_DEPRECATED_PAIR_CONSTRUCT</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_45_0"><a class="link" href="#changes_release_1_45_0">Release 1.45.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Fix a bug when inserting into an <code>unordered_map</code> or <code>unordered_set</code> using
iterators which returns <code>value_type</code> by copy.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_43_0"><a class="link" href="#changes_release_1_43_0">Release 1.43.0</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3966" target="_blank" rel="noopener">Ticket 3966</a>:
<code>erase_return_void</code> is now <code>quick_erase</code>, which is the
<a href="http://home.roadrunner.com/~hinnant/issue_review/lwg-active.html#579" target="_blank" rel="noopener">
current forerunner for resolving the slow erase by iterator</a>, although
there&#8217;s a strong possibility that this may change in the future. The old
method name remains for backwards compatibility but is considered deprecated
and will be removed in a future release.</p>
</li>
<li>
<p>Use Boost.Exception.</p>
</li>
<li>
<p>Stop using deprecated <code>BOOST_HAS_*</code> macros.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_42_0"><a class="link" href="#changes_release_1_42_0">Release 1.42.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Support instantiating the containers with incomplete value types.</p>
</li>
<li>
<p>Reduced the number of warnings (mostly in tests).</p>
</li>
<li>
<p>Improved codegear compatibility.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3693" target="_blank" rel="noopener">Ticket 3693</a>:
Add <code>erase_return_void</code> as a temporary workaround for the current
<code>erase</code> which can be inefficient because it has to find the next
element to return an iterator.</p>
</li>
<li>
<p>Add templated find overload for compatible keys.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3773" target="_blank" rel="noopener">Ticket 3773</a>:
Add missing <code>std</code> qualifier to <code>ptrdiff_t</code>.</p>
</li>
<li>
<p>Some code formatting changes to fit almost all lines into 80 characters.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_41_0_major_update"><a class="link" href="#changes_release_1_41_0_major_update">Release 1.41.0 - Major update</a></h3>
<div class="ulist">
<ul>
<li>
<p>The original version made heavy use of macros to sidestep some of the older
compilers' poor template support. But since I no longer support those
compilers and the macro use was starting to become a maintenance burden it
has been rewritten to use templates instead of macros for the implementation
classes.</p>
</li>
<li>
<p>The container object is now smaller thanks to using <code>boost::compressed_pair</code>
for EBO and a slightly different function buffer - now using a bool instead
of a member pointer.</p>
</li>
<li>
<p>Buckets are allocated lazily which means that constructing an empty container
will not allocate any memory.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_40_0"><a class="link" href="#changes_release_1_40_0">Release 1.40.0</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2975" target="_blank" rel="noopener">Ticket 2975</a>:
Store the prime list as a preprocessor sequence - so that it will always get
the length right if it changes again in the future.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/1978" target="_blank" rel="noopener">Ticket 1978</a>:
Implement <code>emplace</code> for all compilers.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2908" target="_blank" rel="noopener">Ticket 2908</a>,
<a href="https://svn.boost.org/trac/boost/ticket/3096" target="_blank" rel="noopener">Ticket 3096</a>:
Some workarounds for old versions of borland, including adding explicit
destructors to all containers.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/3082" target="_blank" rel="noopener">Ticket 3082</a>:
Disable incorrect Visual C++ warnings.</p>
</li>
<li>
<p>Better configuration for C++0x features when the headers aren&#8217;t available.</p>
</li>
<li>
<p>Create less buckets by default.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_39_0"><a class="link" href="#changes_release_1_39_0">Release 1.39.0</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2756" target="_blank" rel="noopener">Ticket 2756</a>: Avoid a warning
on Visual C++ 2009.</p>
</li>
<li>
<p>Some other minor internal changes to the implementation, tests and
documentation.</p>
</li>
<li>
<p>Avoid an unnecessary copy in <code>operator[]</code>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2975" target="_blank" rel="noopener">Ticket 2975</a>: Fix length of
prime number list.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_38_0"><a class="link" href="#changes_release_1_38_0">Release 1.38.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Use <a href="../../../core/swap.html" target="_blank" rel="noopener"><code>boost::swap</code></a>.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/2237" target="_blank" rel="noopener">Ticket 2237</a>:
Document that the equality and inequality operators are undefined for two
objects if their equality predicates aren&#8217;t equivalent. Thanks to Daniel
Krügler.</p>
</li>
<li>
<p><a href="https://svn.boost.org/trac/boost/ticket/1710" target="_blank" rel="noopener">Ticket 1710</a>:
Use a larger prime number list. Thanks to Thorsten Ottosen and Hervé
Brönnimann.</p>
</li>
<li>
<p>Use
<a href="../../../type_traits/index.html" target="_blank" rel="noopener">aligned storage</a> to store the types.
This changes the way the allocator is used to construct nodes. It used to
construct the node with two calls to the allocator&#8217;s <code>construct</code>
method - once for the pointers and once for the value. It now constructs
the node with a single call to construct and then constructs the value using
in place construction.</p>
</li>
<li>
<p>Add support for C++0x initializer lists where they&#8217;re available (currently
only g++ 4.4 in C++0x mode).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_37_0"><a class="link" href="#changes_release_1_37_0">Release 1.37.0</a></h3>
<div class="ulist">
<ul>
<li>
<p>Rename overload of <code>emplace</code> with hint, to <code>emplace_hint</code> as specified in
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2691.pdf" target="_blank" rel="noopener">n2691</a>.</p>
</li>
<li>
<p>Provide forwarding headers at <code>&lt;boost/unordered/unordered_map_fwd.hpp&gt;</code> and
<code>&lt;boost/unordered/unordered_set_fwd.hpp&gt;</code>.</p>
</li>
<li>
<p>Move all the implementation inside <code>boost/unordered</code>, to assist
modularization and hopefully make it easier to track Release subversion.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_release_1_36_0"><a class="link" href="#changes_release_1_36_0">Release 1.36.0</a></h3>
<div class="paragraph">
<p>First official release.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rearrange the internals.</p>
</li>
<li>
<p>Move semantics - full support when rvalue references are available, emulated
using a cut down version of the Adobe move library when they are not.</p>
</li>
<li>
<p>Emplace support when rvalue references and variadic template are available.</p>
</li>
<li>
<p>More efficient node allocation when rvalue references and variadic template
are available.</p>
</li>
<li>
<p>Added equality operators.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_boost_1_35_0_add_on_31st_march_2008"><a class="link" href="#changes_boost_1_35_0_add_on_31st_march_2008">Boost 1.35.0 Add-on - 31st March 2008</a></h3>
<div class="paragraph">
<p>Unofficial release uploaded to vault, to be used with Boost 1.35.0. Incorporated
many of the suggestions from the review.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Improved portability thanks to Boost regression testing.</p>
</li>
<li>
<p>Fix lots of typos, and clearer text in the documentation.</p>
</li>
<li>
<p>Fix floating point to <code>std::size_t</code> conversion when calculating sizes from
the max load factor, and use <code>double</code> in the calculation for greater accuracy.</p>
</li>
<li>
<p>Fix some errors in the examples.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="changes_review_version"><a class="link" href="#changes_review_version">Review Version</a></h3>
<div class="paragraph">
<p>Initial review version, for the review conducted from 7th December 2007 to
16th December 2007.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bibliography"><a class="link" href="#bibliography">Bibliography</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><em>C/C++ Users Journal</em>. February, 2006. Pete Becker. <a href="http://www.ddj.com/cpp/184402066" target="_blank" rel="noopener">STL and TR1: Part III - Unordered containers</a>.<br>
An introduction to the standard unordered containers.</p>
</li>
<li>
<p><em>Wikipedia</em>. <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">Hash table</a>.<br>
An introduction to hash table implementations. Discusses the differences between closed-addressing and open-addressing approaches.</p>
</li>
<li>
<p>Peter Dimov, 2022. <a href="https://pdimov.github.io/articles/unordered_dev_plan.html" target="_blank" rel="noopener">Development Plan for Boost.Unordered</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright"><a class="link" href="#copyright">Copyright and License</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Daniel James</strong></p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2003, 2004 Jeremy B. Maitin-Shepard</p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2005-2008 Daniel James</p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2022-2023 Christian Mazakas</p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2022-2023 Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz</p>
</div>
<div class="paragraph">
<p>Copyright &#169; 2022-2023 Peter Dimov</p>
</div>
<div class="paragraph">
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" class="bare">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
</div>
</div>
</div>
</div>
</body>
</html>