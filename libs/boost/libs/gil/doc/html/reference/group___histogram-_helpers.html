<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.15"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Generic Image Library: Histogram-Helpers</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-boost.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div class="boost-header">
      <table border="0" cellpadding="7" cellspacing="0" width="100%" summary="header">
	<tr>
	  <td valign="top" width="300">
            <h3><a href="../index.html"><img alt="Boost GIL" src="../_static/gil.png" border="0"></a></h3>
	  </td>
	  <td ><h1 align="center"><a href="../index.html"></a></h1></td>
	  <td></td>
	</tr>
      </table>
    </div>
    <hr/>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Histogram-Helpers</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper implementations supporting the histogram class.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1gil_1_1detail_1_1hash__tuple.html">hash_tuple&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor provided for the hashing of tuples. The following approach makes use hash_combine from boost::container_hash. Although there is a direct hashing available for tuples, this approach will ease adopting in future to a std::hash_combine. In case std::hash extends support to tuples this functor as well as the helper implementation hash_tuple_impl can be removed.  <a href="structboost_1_1gil_1_1detail_1_1hash__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1gil_1_1detail_1_1tuple__limit.html">tuple_limit&lt; Tuple &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides equivalent of std::numeric_limits for type std::tuple <a class="el" href="structboost_1_1gil_1_1detail_1_1tuple__limit.html" title="Provides equivalent of std::numeric_limits for type std::tuple tuple_limit gets called with only tupl...">tuple_limit</a> gets called with only tuples having integral elements.  <a href="structboost_1_1gil_1_1detail_1_1tuple__limit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1gil_1_1detail_1_1filler.html">filler&lt; Dimension &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filler is used to fill the histogram class with all values between a specified range This functor is used when sparsefill is false, since all the keys need to be present in that case. Currently on 1D implementation is available, extend by adding specialization for 2D and higher dimensional cases.  <a href="structboost_1_1gil_1_1detail_1_1filler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1gil_1_1detail_1_1filler_3_011_01_4.html">filler&lt; 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for 1D histogram.  <a href="structboost_1_1gil_1_1detail_1_1filler_3_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae545d7d3106c80376199555b3e611768"><td class="memTemplParams" colspan="2"><a id="gae545d7d3106c80376199555b3e611768"></a>
template&lt;std::size_t Index, typename... T&gt; </td></tr>
<tr class="memitem:gae545d7d3106c80376199555b3e611768"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hash_tuple_impl</b> (std::size_t &amp;, std::tuple&lt; T... &gt; const &amp;) -&gt; typename std::enable_if&lt; Index==sizeof...(T), void &gt;::type</td></tr>
<tr class="separator:gae545d7d3106c80376199555b3e611768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9834216fad8903ba7e79413cf3fc7539"><td class="memTemplParams" colspan="2">template&lt;typename Pixel , std::size_t... I&gt; </td></tr>
<tr class="memitem:ga9834216fad8903ba7e79413cf3fc7539"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___histogram-_helpers.html#ga9834216fad8903ba7e79413cf3fc7539">pixel_to_tuple</a> (Pixel const &amp;p, boost::mp11::index_sequence&lt; I... &gt;) -&gt; decltype(std::make_tuple(p[I]...))</td></tr>
<tr class="separator:ga9834216fad8903ba7e79413cf3fc7539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d189badd7c3aee79694489ce7f2fdaa"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , std::size_t... I&gt; </td></tr>
<tr class="memitem:ga4d189badd7c3aee79694489ce7f2fdaa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___histogram-_helpers.html#ga4d189badd7c3aee79694489ce7f2fdaa">tuple_to_tuple</a> (Tuple const &amp;t, boost::mp11::index_sequence&lt; I... &gt;) -&gt; decltype(std::make_tuple(std::get&lt; I &gt;(t)...))</td></tr>
<tr class="separator:ga4d189badd7c3aee79694489ce7f2fdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf051468fcd157086c137a32414c41353"><td class="memTemplParams" colspan="2"><a id="gaf051468fcd157086c137a32414c41353"></a>
template&lt;typename Tuple , std::size_t... I&gt; </td></tr>
<tr class="memitem:gaf051468fcd157086c137a32414c41353"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuple_compare</b> (Tuple const &amp;t1, Tuple const &amp;t2, boost::mp11::index_sequence&lt; I... &gt;)</td></tr>
<tr class="separator:gaf051468fcd157086c137a32414c41353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf383ec0528e99613ff033eb98f99bd93"><td class="memTemplParams" colspan="2"><a id="gaf383ec0528e99613ff033eb98f99bd93"></a>
template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:gaf383ec0528e99613ff033eb98f99bd93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___histogram-_helpers.html#gaf383ec0528e99613ff033eb98f99bd93">tuple_compare</a> (Tuple const &amp;t1, Tuple const &amp;t2)</td></tr>
<tr class="memdesc:gaf383ec0528e99613ff033eb98f99bd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares 2 tuples and outputs t1 &lt;= t2 Comparison is not in a lexicographic manner but on every element of the tuple hence (2, 2) &gt; (1, 3) evaluates to false. <br /></td></tr>
<tr class="separator:gaf383ec0528e99613ff033eb98f99bd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Helper implementations supporting the histogram class. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9834216fad8903ba7e79413cf3fc7539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9834216fad8903ba7e79413cf3fc7539">&#9670;&nbsp;</a></span>pixel_to_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto boost::gil::detail::pixel_to_tuple </td>
          <td>(</td>
          <td class="paramtype">Pixel const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::mp11::index_sequence&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::make_tuple(p[I]...))
</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>With C++14 and using auto we don't need the decltype anymore </dd></dl>

</div>
</div>
<a id="ga4d189badd7c3aee79694489ce7f2fdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d189badd7c3aee79694489ce7f2fdaa">&#9670;&nbsp;</a></span>tuple_to_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto boost::gil::detail::tuple_to_tuple </td>
          <td>(</td>
          <td class="paramtype">Tuple const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::mp11::index_sequence&lt; I... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(std::make_tuple(std::get&lt;I&gt;(t)...))
</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>With C++14 and using auto we don't need the decltype anymore </dd></dl>

</div>
</div>
</div><!-- contents -->
     <!-- HTML footer for doxygen 1.8.13-->
     <!-- start footer part -->
     <hr class="footer"/>
     <address class="footer">
      <small>
        Generated by &#160;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.15
      </small>
    </address>
  </body>
</html>
