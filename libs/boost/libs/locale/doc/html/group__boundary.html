<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Boost.Locale: Boundary Analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="section-basic.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="boost-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Boost.Locale
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__boundary.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Boundary Analysis</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boost::locale::boundary::boundary_point&lt; IteratorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a boundary point in the text.  <a href="classboost_1_1locale_1_1boundary_1_1boundary__point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1locale_1_1boundary_1_1break__info.html">boost::locale::boundary::break_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used for representing boundary points that follow the offset.  <a href="structboost_1_1locale_1_1boundary_1_1break__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__indexing.html">boost::locale::boundary::boundary_indexing&lt; Char &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This facet generates an index for boundary analysis for a given text.  <a href="classboost_1_1locale_1_1boundary_1_1boundary__indexing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index&lt; BaseIterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds an index of segments in the text range and allows to iterate over them.  <a href="classboost_1_1locale_1_1boundary_1_1segment__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds an index of <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary points</a> and allows iterating over them.  <a href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">boost::locale::boundary::segment&lt; IteratorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a segment object that represents a pair of two iterators that define the range where this segment exits and a rule that defines it.  <a href="classboost_1_1locale_1_1boundary_1_1segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7b4dd7af8fad53fabd77e629da24d466"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="structboost_1_1locale_1_1boundary_1_1break__info.html">break_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga7b4dd7af8fad53fabd77e629da24d466">boost::locale::boundary::index_type</a></td></tr>
<tr class="separator:ga7b4dd7af8fad53fabd77e629da24d466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f2faacb9d196ebc659ad5382ea2ca5"><td class="memItemLeft" align="right" valign="top"><a id="ga06f2faacb9d196ebc659ad5382ea2ca5"></a>
typedef BaseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::base_iterator</a></td></tr>
<tr class="memdesc:ga06f2faacb9d196ebc659ad5382ea2ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the iterator used to iterate over the original text. <br /></td></tr>
<tr class="separator:ga06f2faacb9d196ebc659ad5382ea2ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a775e77dbbca3495e11d646df96fd2"><td class="memItemLeft" align="right" valign="top">typedef unspecified_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::iterator</a></td></tr>
<tr class="separator:gaf7a775e77dbbca3495e11d646df96fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f8e61b5babc3f0fa95f5fb8acae3724"><td class="memItemLeft" align="right" valign="top">typedef unspecified_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga5f8e61b5babc3f0fa95f5fb8acae3724">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::const_iterator</a></td></tr>
<tr class="separator:ga5f8e61b5babc3f0fa95f5fb8acae3724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067c663d18faee08adb3355701ae72ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga067c663d18faee08adb3355701ae72ba">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::value_type</a></td></tr>
<tr class="separator:ga067c663d18faee08adb3355701ae72ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3189e2eaf4386cdf37598e0ba16cfd5"><td class="memItemLeft" align="right" valign="top"><a id="gab3189e2eaf4386cdf37598e0ba16cfd5"></a>
typedef BaseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::base_iterator</a></td></tr>
<tr class="memdesc:gab3189e2eaf4386cdf37598e0ba16cfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the iterator used to iterate over the original text. <br /></td></tr>
<tr class="separator:gab3189e2eaf4386cdf37598e0ba16cfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af6e72b3c384edcebc0cf319fe97efe"><td class="memItemLeft" align="right" valign="top">typedef unspecified_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::iterator</a></td></tr>
<tr class="separator:ga1af6e72b3c384edcebc0cf319fe97efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ce9158eb2fb030c1baf93376203d16"><td class="memItemLeft" align="right" valign="top">typedef unspecified_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gac9ce9158eb2fb030c1baf93376203d16">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::const_iterator</a></td></tr>
<tr class="separator:gac9ce9158eb2fb030c1baf93376203d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7328a860cf485a4bd8f17658c291e1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a>&lt; <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga7f7328a860cf485a4bd8f17658c291e1">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::value_type</a></td></tr>
<tr class="separator:ga7f7328a860cf485a4bd8f17658c291e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4785439a3f03ee455c93830b8f1366c"><td class="memItemLeft" align="right" valign="top"><a id="gad4785439a3f03ee455c93830b8f1366c"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; std::string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad4785439a3f03ee455c93830b8f1366c">boost::locale::boundary::ssegment_index</a></td></tr>
<tr class="memdesc:gad4785439a3f03ee455c93830b8f1366c"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gad4785439a3f03ee455c93830b8f1366c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579cfdfccf9c682ac4dae5fb65d4a843"><td class="memItemLeft" align="right" valign="top"><a id="ga579cfdfccf9c682ac4dae5fb65d4a843"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; std::wstring::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga579cfdfccf9c682ac4dae5fb65d4a843">boost::locale::boundary::wssegment_index</a></td></tr>
<tr class="memdesc:ga579cfdfccf9c682ac4dae5fb65d4a843"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga579cfdfccf9c682ac4dae5fb65d4a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fff9ef7a0971ed3c686f3e8d5c56bf4"><td class="memItemLeft" align="right" valign="top"><a id="ga6fff9ef7a0971ed3c686f3e8d5c56bf4"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; std::u16string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga6fff9ef7a0971ed3c686f3e8d5c56bf4">boost::locale::boundary::u16ssegment_index</a></td></tr>
<tr class="memdesc:ga6fff9ef7a0971ed3c686f3e8d5c56bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga6fff9ef7a0971ed3c686f3e8d5c56bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7b82f5a7e29bd079dd48ca13b79f20"><td class="memItemLeft" align="right" valign="top"><a id="ga3a7b82f5a7e29bd079dd48ca13b79f20"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; std::u32string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga3a7b82f5a7e29bd079dd48ca13b79f20">boost::locale::boundary::u32ssegment_index</a></td></tr>
<tr class="memdesc:ga3a7b82f5a7e29bd079dd48ca13b79f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga3a7b82f5a7e29bd079dd48ca13b79f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75f398321d0d3147b0680ea4447a935e"><td class="memItemLeft" align="right" valign="top"><a id="ga75f398321d0d3147b0680ea4447a935e"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga75f398321d0d3147b0680ea4447a935e">boost::locale::boundary::csegment_index</a></td></tr>
<tr class="memdesc:ga75f398321d0d3147b0680ea4447a935e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga75f398321d0d3147b0680ea4447a935e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069b7d9ea636b0e770843221d73e548e"><td class="memItemLeft" align="right" valign="top"><a id="ga069b7d9ea636b0e770843221d73e548e"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; const wchar_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga069b7d9ea636b0e770843221d73e548e">boost::locale::boundary::wcsegment_index</a></td></tr>
<tr class="memdesc:ga069b7d9ea636b0e770843221d73e548e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga069b7d9ea636b0e770843221d73e548e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ab968e108e4ada70b496b47da81202"><td class="memItemLeft" align="right" valign="top"><a id="gaa7ab968e108e4ada70b496b47da81202"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; const char16_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa7ab968e108e4ada70b496b47da81202">boost::locale::boundary::u16csegment_index</a></td></tr>
<tr class="memdesc:gaa7ab968e108e4ada70b496b47da81202"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gaa7ab968e108e4ada70b496b47da81202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac03e3c9201e38ba979c6425f2fd33abb"><td class="memItemLeft" align="right" valign="top"><a id="gac03e3c9201e38ba979c6425f2fd33abb"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; const char32_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gac03e3c9201e38ba979c6425f2fd33abb">boost::locale::boundary::u32csegment_index</a></td></tr>
<tr class="memdesc:gac03e3c9201e38ba979c6425f2fd33abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gac03e3c9201e38ba979c6425f2fd33abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485e82cdd9debd15dc4fd6f57be10727"><td class="memItemLeft" align="right" valign="top"><a id="ga485e82cdd9debd15dc4fd6f57be10727"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; std::string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga485e82cdd9debd15dc4fd6f57be10727">boost::locale::boundary::sboundary_point_index</a></td></tr>
<tr class="memdesc:ga485e82cdd9debd15dc4fd6f57be10727"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga485e82cdd9debd15dc4fd6f57be10727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad539aad8c788c8e90cdf08aeed5df4a3"><td class="memItemLeft" align="right" valign="top"><a id="gad539aad8c788c8e90cdf08aeed5df4a3"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; std::wstring::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad539aad8c788c8e90cdf08aeed5df4a3">boost::locale::boundary::wsboundary_point_index</a></td></tr>
<tr class="memdesc:gad539aad8c788c8e90cdf08aeed5df4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gad539aad8c788c8e90cdf08aeed5df4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba43501d4ed1922c9446db3bf14a918f"><td class="memItemLeft" align="right" valign="top"><a id="gaba43501d4ed1922c9446db3bf14a918f"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; std::u16string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaba43501d4ed1922c9446db3bf14a918f">boost::locale::boundary::u16sboundary_point_index</a></td></tr>
<tr class="memdesc:gaba43501d4ed1922c9446db3bf14a918f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gaba43501d4ed1922c9446db3bf14a918f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1379f8968dd611be0b59d04218a1aae8"><td class="memItemLeft" align="right" valign="top"><a id="ga1379f8968dd611be0b59d04218a1aae8"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; std::u32string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1379f8968dd611be0b59d04218a1aae8">boost::locale::boundary::u32sboundary_point_index</a></td></tr>
<tr class="memdesc:ga1379f8968dd611be0b59d04218a1aae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga1379f8968dd611be0b59d04218a1aae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa06e850c0b91d7618dc4afe09379ca"><td class="memItemLeft" align="right" valign="top"><a id="ga0fa06e850c0b91d7618dc4afe09379ca"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga0fa06e850c0b91d7618dc4afe09379ca">boost::locale::boundary::cboundary_point_index</a></td></tr>
<tr class="memdesc:ga0fa06e850c0b91d7618dc4afe09379ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga0fa06e850c0b91d7618dc4afe09379ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416501f824c3b5e6f217a97c6bc231a5"><td class="memItemLeft" align="right" valign="top"><a id="ga416501f824c3b5e6f217a97c6bc231a5"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; const wchar_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga416501f824c3b5e6f217a97c6bc231a5">boost::locale::boundary::wcboundary_point_index</a></td></tr>
<tr class="memdesc:ga416501f824c3b5e6f217a97c6bc231a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga416501f824c3b5e6f217a97c6bc231a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04f85fe2bbe5787f4e18403569614f11"><td class="memItemLeft" align="right" valign="top"><a id="ga04f85fe2bbe5787f4e18403569614f11"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; const char16_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga04f85fe2bbe5787f4e18403569614f11">boost::locale::boundary::u16cboundary_point_index</a></td></tr>
<tr class="memdesc:ga04f85fe2bbe5787f4e18403569614f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga04f85fe2bbe5787f4e18403569614f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8597975ed9c77049be816d362fb71a2"><td class="memItemLeft" align="right" valign="top"><a id="gab8597975ed9c77049be816d362fb71a2"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; const char32_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab8597975ed9c77049be816d362fb71a2">boost::locale::boundary::u32cboundary_point_index</a></td></tr>
<tr class="memdesc:gab8597975ed9c77049be816d362fb71a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gab8597975ed9c77049be816d362fb71a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5031c17bd3f7ddc5138546af121064"><td class="memItemLeft" align="right" valign="top"><a id="gaac5031c17bd3f7ddc5138546af121064"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; std::string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaac5031c17bd3f7ddc5138546af121064">boost::locale::boundary::ssegment</a></td></tr>
<tr class="memdesc:gaac5031c17bd3f7ddc5138546af121064"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gaac5031c17bd3f7ddc5138546af121064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0e28d417ee314f3035c7561ed5134a"><td class="memItemLeft" align="right" valign="top"><a id="gaca0e28d417ee314f3035c7561ed5134a"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; std::wstring::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaca0e28d417ee314f3035c7561ed5134a">boost::locale::boundary::wssegment</a></td></tr>
<tr class="memdesc:gaca0e28d417ee314f3035c7561ed5134a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gaca0e28d417ee314f3035c7561ed5134a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5084d9529f752361d18c2196f38df3c0"><td class="memItemLeft" align="right" valign="top"><a id="ga5084d9529f752361d18c2196f38df3c0"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; std::u16string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga5084d9529f752361d18c2196f38df3c0">boost::locale::boundary::u16ssegment</a></td></tr>
<tr class="memdesc:ga5084d9529f752361d18c2196f38df3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga5084d9529f752361d18c2196f38df3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffcc722694a39291a9ea7f68a95e1e27"><td class="memItemLeft" align="right" valign="top"><a id="gaffcc722694a39291a9ea7f68a95e1e27"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; std::u32string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaffcc722694a39291a9ea7f68a95e1e27">boost::locale::boundary::u32ssegment</a></td></tr>
<tr class="memdesc:gaffcc722694a39291a9ea7f68a95e1e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gaffcc722694a39291a9ea7f68a95e1e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57995e2750fa7cfc08e655a668b7cca"><td class="memItemLeft" align="right" valign="top"><a id="gad57995e2750fa7cfc08e655a668b7cca"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad57995e2750fa7cfc08e655a668b7cca">boost::locale::boundary::csegment</a></td></tr>
<tr class="memdesc:gad57995e2750fa7cfc08e655a668b7cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gad57995e2750fa7cfc08e655a668b7cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97ddd9f975d0ab0b8cfe6249363ca1a2"><td class="memItemLeft" align="right" valign="top"><a id="ga97ddd9f975d0ab0b8cfe6249363ca1a2"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; const wchar_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga97ddd9f975d0ab0b8cfe6249363ca1a2">boost::locale::boundary::wcsegment</a></td></tr>
<tr class="memdesc:ga97ddd9f975d0ab0b8cfe6249363ca1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga97ddd9f975d0ab0b8cfe6249363ca1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7cdd9cd0a2e11f7a4d56dad12b8825"><td class="memItemLeft" align="right" valign="top"><a id="gafd7cdd9cd0a2e11f7a4d56dad12b8825"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; const char16_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gafd7cdd9cd0a2e11f7a4d56dad12b8825">boost::locale::boundary::u16csegment</a></td></tr>
<tr class="memdesc:gafd7cdd9cd0a2e11f7a4d56dad12b8825"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:gafd7cdd9cd0a2e11f7a4d56dad12b8825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9b1a5057da8164d03456e9583edd80"><td class="memItemLeft" align="right" valign="top"><a id="ga9b9b1a5057da8164d03456e9583edd80"></a>
typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; const char32_t * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga9b9b1a5057da8164d03456e9583edd80">boost::locale::boundary::u32csegment</a></td></tr>
<tr class="memdesc:ga9b9b1a5057da8164d03456e9583edd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br /></td></tr>
<tr class="separator:ga9b9b1a5057da8164d03456e9583edd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e193c81052ef1795f1b53b46bc2095"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">boost::locale::boundary::rule_type</a></td></tr>
<tr class="memdesc:ga25e193c81052ef1795f1b53b46bc2095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags used with word boundary analysis &ndash; the type of the word, line or sentence boundary found.  <a href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">More...</a><br /></td></tr>
<tr class="separator:ga25e193c81052ef1795f1b53b46bc2095"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga15de9963ce9bb6037c8525901dfbf641"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boost::locale::boundary::boundary_type</a> { <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641ae80c964112541d88af9b875dafb6605d">boost::locale::boundary::character</a>, 
<a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">boost::locale::boundary::word</a>, 
<a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9">boost::locale::boundary::sentence</a>, 
<a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a72895419fdd7219b3695cf0abd602ea4">boost::locale::boundary::line</a>
 }</td></tr>
<tr class="memdesc:ga15de9963ce9bb6037c8525901dfbf641"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type describes a possible boundary analysis alternatives.  <a href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">More...</a><br /></td></tr>
<tr class="separator:ga15de9963ce9bb6037c8525901dfbf641"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9ae9b79530f58d95aebde8a221461130"><td class="memTemplParams" colspan="2"><a id="ga9ae9b79530f58d95aebde8a221461130"></a>
template&lt;typename BaseIterator &gt; </td></tr>
<tr class="memitem:ga9ae9b79530f58d95aebde8a221461130"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga9ae9b79530f58d95aebde8a221461130">boost::locale::boundary::operator==</a> (const BaseIterator &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a>&lt; BaseIterator &gt; &amp;r)</td></tr>
<tr class="memdesc:ga9ae9b79530f58d95aebde8a221461130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the boundary point <em>r</em> points to same location as an iterator <em>l</em>. <br /></td></tr>
<tr class="separator:ga9ae9b79530f58d95aebde8a221461130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c5f3099bc9f79d468b3e9b91d9cb0e"><td class="memTemplParams" colspan="2"><a id="ga64c5f3099bc9f79d468b3e9b91d9cb0e"></a>
template&lt;typename BaseIterator &gt; </td></tr>
<tr class="memitem:ga64c5f3099bc9f79d468b3e9b91d9cb0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga64c5f3099bc9f79d468b3e9b91d9cb0e">boost::locale::boundary::operator!=</a> (const BaseIterator &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a>&lt; BaseIterator &gt; &amp;r)</td></tr>
<tr class="memdesc:ga64c5f3099bc9f79d468b3e9b91d9cb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the boundary point <em>r</em> points to different location from an iterator <em>l</em>. <br /></td></tr>
<tr class="separator:ga64c5f3099bc9f79d468b3e9b91d9cb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c354f4cc03677b58c97038cd84dc465"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga2c354f4cc03677b58c97038cd84dc465">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::segment_index</a> ()</td></tr>
<tr class="separator:ga2c354f4cc03677b58c97038cd84dc465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77241a89e32aa94ef4f21088c3a3db34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga77241a89e32aa94ef4f21088c3a3db34">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::segment_index</a> (<a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a> type, <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> <a class="el" href="group__boundary.html#gae4ac52a6957bbe887f909a3a4827799e">begin</a>, <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> <a class="el" href="group__boundary.html#gab080ea82495551e0aa70abcd54010f8b">end</a>, <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a> mask, const std::locale &amp;loc=std::locale())</td></tr>
<tr class="separator:ga77241a89e32aa94ef4f21088c3a3db34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf7dde1641324683fa717094e5487c41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaaf7dde1641324683fa717094e5487c41">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::segment_index</a> (<a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a> type, <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> <a class="el" href="group__boundary.html#gae4ac52a6957bbe887f909a3a4827799e">begin</a>, <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> <a class="el" href="group__boundary.html#gab080ea82495551e0aa70abcd54010f8b">end</a>, const std::locale &amp;loc=std::locale())</td></tr>
<tr class="separator:gaaf7dde1641324683fa717094e5487c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a7fe0442f3459d76859954bec55010"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga46a7fe0442f3459d76859954bec55010">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::segment_index</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> &gt; &amp;)</td></tr>
<tr class="separator:ga46a7fe0442f3459d76859954bec55010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71d2e73911267180538859d35ee5db2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga71d2e73911267180538859d35ee5db2c">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::operator=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> &gt; &amp;)</td></tr>
<tr class="separator:ga71d2e73911267180538859d35ee5db2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f82ec594bb8f4159352e6111c52fb03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga3f82ec594bb8f4159352e6111c52fb03">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::map</a> (<a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a> type, <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> <a class="el" href="group__boundary.html#gae4ac52a6957bbe887f909a3a4827799e">begin</a>, <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> <a class="el" href="group__boundary.html#gab080ea82495551e0aa70abcd54010f8b">end</a>, const std::locale &amp;loc=std::locale())</td></tr>
<tr class="separator:ga3f82ec594bb8f4159352e6111c52fb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ac52a6957bbe887f909a3a4827799e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gae4ac52a6957bbe887f909a3a4827799e">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::begin</a> () const</td></tr>
<tr class="separator:gae4ac52a6957bbe887f909a3a4827799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab080ea82495551e0aa70abcd54010f8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab080ea82495551e0aa70abcd54010f8b">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::end</a> () const</td></tr>
<tr class="separator:gab080ea82495551e0aa70abcd54010f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacbd8e4789a593a4c02bc3d9bd9a1d68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaacbd8e4789a593a4c02bc3d9bd9a1d68">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::find</a> (<a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> p) const</td></tr>
<tr class="separator:gaacbd8e4789a593a4c02bc3d9bd9a1d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadedc114f14445bbaa91afba14ffb92a0"><td class="memItemLeft" align="right" valign="top"><a id="gadedc114f14445bbaa91afba14ffb92a0"></a>
<a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gadedc114f14445bbaa91afba14ffb92a0">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::rule</a> () const</td></tr>
<tr class="memdesc:gadedc114f14445bbaa91afba14ffb92a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mask of rules that are used. <br /></td></tr>
<tr class="separator:gadedc114f14445bbaa91afba14ffb92a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19735180401edb15acbdbbeb21e5a73"><td class="memItemLeft" align="right" valign="top"><a id="gad19735180401edb15acbdbbeb21e5a73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::rule</a> (<a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a> v)</td></tr>
<tr class="memdesc:gad19735180401edb15acbdbbeb21e5a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mask of rules that are used. <br /></td></tr>
<tr class="separator:gad19735180401edb15acbdbbeb21e5a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1560a05d1db02228ed0f5a16a650915"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa1560a05d1db02228ed0f5a16a650915">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::full_select</a> () const</td></tr>
<tr class="separator:gaa1560a05d1db02228ed0f5a16a650915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205fd51daa439a18527675e663a0802f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::full_select</a> (bool v)</td></tr>
<tr class="separator:ga205fd51daa439a18527675e663a0802f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6993dd50ad8cf2db8921e5cf668a69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaba6993dd50ad8cf2db8921e5cf668a69">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::boundary_point_index</a> ()</td></tr>
<tr class="separator:gaba6993dd50ad8cf2db8921e5cf668a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf9efeab443b1aeefb7fb469ef765b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga6bf9efeab443b1aeefb7fb469ef765b2">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::boundary_point_index</a> (<a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a> type, <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> <a class="el" href="group__boundary.html#ga6e90d12e12b0f701d4b0683ff2920b2c">begin</a>, <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> <a class="el" href="group__boundary.html#ga557ea241d682a34d483951880fd431fc">end</a>, <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a> mask, const std::locale &amp;loc=std::locale())</td></tr>
<tr class="separator:ga6bf9efeab443b1aeefb7fb469ef765b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5306962935baaa400e51d063366f0ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf5306962935baaa400e51d063366f0ab">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::boundary_point_index</a> (<a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a> type, <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> <a class="el" href="group__boundary.html#ga6e90d12e12b0f701d4b0683ff2920b2c">begin</a>, <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> <a class="el" href="group__boundary.html#ga557ea241d682a34d483951880fd431fc">end</a>, const std::locale &amp;loc=std::locale())</td></tr>
<tr class="separator:gaf5306962935baaa400e51d063366f0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72fa62eaacf5b1926146699532d3b25e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga72fa62eaacf5b1926146699532d3b25e">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::boundary_point_index</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> &gt; &amp;other)</td></tr>
<tr class="separator:ga72fa62eaacf5b1926146699532d3b25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac67c5d191f6ddb7e26ddf92386ce4606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gac67c5d191f6ddb7e26ddf92386ce4606">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::operator=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> &gt; &amp;other)</td></tr>
<tr class="separator:gac67c5d191f6ddb7e26ddf92386ce4606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f144a68688caf101e88f6824e1f0130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga0f144a68688caf101e88f6824e1f0130">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::map</a> (<a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a> type, <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> <a class="el" href="group__boundary.html#ga6e90d12e12b0f701d4b0683ff2920b2c">begin</a>, <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> <a class="el" href="group__boundary.html#ga557ea241d682a34d483951880fd431fc">end</a>, const std::locale &amp;loc=std::locale())</td></tr>
<tr class="separator:ga0f144a68688caf101e88f6824e1f0130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e90d12e12b0f701d4b0683ff2920b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga6e90d12e12b0f701d4b0683ff2920b2c">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::begin</a> () const</td></tr>
<tr class="separator:ga6e90d12e12b0f701d4b0683ff2920b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557ea241d682a34d483951880fd431fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga557ea241d682a34d483951880fd431fc">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::end</a> () const</td></tr>
<tr class="separator:ga557ea241d682a34d483951880fd431fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677d119609854886c94000b772f1c41b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga677d119609854886c94000b772f1c41b">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::find</a> (<a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> p) const</td></tr>
<tr class="separator:ga677d119609854886c94000b772f1c41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf19c6313d74a179e11bf3d6674a5d892"><td class="memItemLeft" align="right" valign="top"><a id="gaf19c6313d74a179e11bf3d6674a5d892"></a>
<a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf19c6313d74a179e11bf3d6674a5d892">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::rule</a> () const</td></tr>
<tr class="memdesc:gaf19c6313d74a179e11bf3d6674a5d892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mask of rules that are used. <br /></td></tr>
<tr class="separator:gaf19c6313d74a179e11bf3d6674a5d892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e63913f51109e05a24a7136472a975"><td class="memItemLeft" align="right" valign="top"><a id="ga56e63913f51109e05a24a7136472a975"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga56e63913f51109e05a24a7136472a975">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::rule</a> (<a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a> v)</td></tr>
<tr class="memdesc:ga56e63913f51109e05a24a7136472a975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mask of rules that are used. <br /></td></tr>
<tr class="separator:ga56e63913f51109e05a24a7136472a975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacabc5fb32642922240b9696c02c3b107"><td class="memTemplParams" colspan="2"><a id="gacabc5fb32642922240b9696c02c3b107"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:gacabc5fb32642922240b9696c02c3b107"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gacabc5fb32642922240b9696c02c3b107">boost::locale::boundary::operator==</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorL &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:gacabc5fb32642922240b9696c02c3b107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br /></td></tr>
<tr class="separator:gacabc5fb32642922240b9696c02c3b107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b85dbebb15bd17d87e9451f0aa98275"><td class="memTemplParams" colspan="2"><a id="ga7b85dbebb15bd17d87e9451f0aa98275"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga7b85dbebb15bd17d87e9451f0aa98275"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga7b85dbebb15bd17d87e9451f0aa98275">boost::locale::boundary::operator!=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorL &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga7b85dbebb15bd17d87e9451f0aa98275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br /></td></tr>
<tr class="separator:ga7b85dbebb15bd17d87e9451f0aa98275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1730e6426d9030c42f8d4987f2591aae"><td class="memTemplParams" colspan="2"><a id="ga1730e6426d9030c42f8d4987f2591aae"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga1730e6426d9030c42f8d4987f2591aae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1730e6426d9030c42f8d4987f2591aae">boost::locale::boundary::operator&lt;</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorL &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga1730e6426d9030c42f8d4987f2591aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br /></td></tr>
<tr class="separator:ga1730e6426d9030c42f8d4987f2591aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d3ee374afea084c1bc8efa5fb5aba9"><td class="memTemplParams" colspan="2"><a id="ga07d3ee374afea084c1bc8efa5fb5aba9"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga07d3ee374afea084c1bc8efa5fb5aba9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga07d3ee374afea084c1bc8efa5fb5aba9">boost::locale::boundary::operator&lt;=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorL &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga07d3ee374afea084c1bc8efa5fb5aba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br /></td></tr>
<tr class="separator:ga07d3ee374afea084c1bc8efa5fb5aba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf63b3de94f3146ba8c15f0374a100db"><td class="memTemplParams" colspan="2"><a id="gaaf63b3de94f3146ba8c15f0374a100db"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaaf63b3de94f3146ba8c15f0374a100db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaaf63b3de94f3146ba8c15f0374a100db">boost::locale::boundary::operator&gt;</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorL &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:gaaf63b3de94f3146ba8c15f0374a100db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br /></td></tr>
<tr class="separator:gaaf63b3de94f3146ba8c15f0374a100db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c63976f13515c35b514cd0871a7f32"><td class="memTemplParams" colspan="2"><a id="ga45c63976f13515c35b514cd0871a7f32"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga45c63976f13515c35b514cd0871a7f32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga45c63976f13515c35b514cd0871a7f32">boost::locale::boundary::operator&gt;=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorL &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga45c63976f13515c35b514cd0871a7f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br /></td></tr>
<tr class="separator:ga45c63976f13515c35b514cd0871a7f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b759a2752e6a60eeb35ba2281298aa"><td class="memTemplParams" colspan="2"><a id="ga86b759a2752e6a60eeb35ba2281298aa"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga86b759a2752e6a60eeb35ba2281298aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga86b759a2752e6a60eeb35ba2281298aa">boost::locale::boundary::operator==</a> (const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga86b759a2752e6a60eeb35ba2281298aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:ga86b759a2752e6a60eeb35ba2281298aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec6521b7d0a701497b3a280e861fcaf8"><td class="memTemplParams" colspan="2"><a id="gaec6521b7d0a701497b3a280e861fcaf8"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaec6521b7d0a701497b3a280e861fcaf8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaec6521b7d0a701497b3a280e861fcaf8">boost::locale::boundary::operator!=</a> (const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:gaec6521b7d0a701497b3a280e861fcaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:gaec6521b7d0a701497b3a280e861fcaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e8de7cee507d854789cf060267b00d"><td class="memTemplParams" colspan="2"><a id="ga41e8de7cee507d854789cf060267b00d"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga41e8de7cee507d854789cf060267b00d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga41e8de7cee507d854789cf060267b00d">boost::locale::boundary::operator&lt;</a> (const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga41e8de7cee507d854789cf060267b00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:ga41e8de7cee507d854789cf060267b00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac30366e194fa4d997cd2b9346e63c87"><td class="memTemplParams" colspan="2"><a id="gaac30366e194fa4d997cd2b9346e63c87"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaac30366e194fa4d997cd2b9346e63c87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaac30366e194fa4d997cd2b9346e63c87">boost::locale::boundary::operator&lt;=</a> (const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:gaac30366e194fa4d997cd2b9346e63c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:gaac30366e194fa4d997cd2b9346e63c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5e450b4784b22d5edd9eaef02e17d0"><td class="memTemplParams" colspan="2"><a id="gaae5e450b4784b22d5edd9eaef02e17d0"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaae5e450b4784b22d5edd9eaef02e17d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaae5e450b4784b22d5edd9eaef02e17d0">boost::locale::boundary::operator&gt;</a> (const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:gaae5e450b4784b22d5edd9eaef02e17d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:gaae5e450b4784b22d5edd9eaef02e17d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37967a71fa86cd44fa39b1438bfb6e5"><td class="memTemplParams" colspan="2"><a id="gaa37967a71fa86cd44fa39b1438bfb6e5"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaa37967a71fa86cd44fa39b1438bfb6e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa37967a71fa86cd44fa39b1438bfb6e5">boost::locale::boundary::operator&gt;=</a> (const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:gaa37967a71fa86cd44fa39b1438bfb6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:gaa37967a71fa86cd44fa39b1438bfb6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28397fe92c31d2bf0c9330fc7dff7cf"><td class="memTemplParams" colspan="2"><a id="gae28397fe92c31d2bf0c9330fc7dff7cf"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:gae28397fe92c31d2bf0c9330fc7dff7cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gae28397fe92c31d2bf0c9330fc7dff7cf">boost::locale::boundary::operator==</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;r)</td></tr>
<tr class="memdesc:gae28397fe92c31d2bf0c9330fc7dff7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:gae28397fe92c31d2bf0c9330fc7dff7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097dde150d04bc71adcbd3ca825f00ad"><td class="memTemplParams" colspan="2"><a id="ga097dde150d04bc71adcbd3ca825f00ad"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:ga097dde150d04bc71adcbd3ca825f00ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga097dde150d04bc71adcbd3ca825f00ad">boost::locale::boundary::operator!=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;r)</td></tr>
<tr class="memdesc:ga097dde150d04bc71adcbd3ca825f00ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:ga097dde150d04bc71adcbd3ca825f00ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89da4c90a85c9ac66986a252d9fec49"><td class="memTemplParams" colspan="2"><a id="gaa89da4c90a85c9ac66986a252d9fec49"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:gaa89da4c90a85c9ac66986a252d9fec49"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa89da4c90a85c9ac66986a252d9fec49">boost::locale::boundary::operator&lt;</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;r)</td></tr>
<tr class="memdesc:gaa89da4c90a85c9ac66986a252d9fec49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:gaa89da4c90a85c9ac66986a252d9fec49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363232d255dad62cc163a1dcd8e34144"><td class="memTemplParams" colspan="2"><a id="ga363232d255dad62cc163a1dcd8e34144"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:ga363232d255dad62cc163a1dcd8e34144"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga363232d255dad62cc163a1dcd8e34144">boost::locale::boundary::operator&lt;=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;r)</td></tr>
<tr class="memdesc:ga363232d255dad62cc163a1dcd8e34144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:ga363232d255dad62cc163a1dcd8e34144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f3000b645e5f2774b885daa813e138"><td class="memTemplParams" colspan="2"><a id="ga10f3000b645e5f2774b885daa813e138"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:ga10f3000b645e5f2774b885daa813e138"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga10f3000b645e5f2774b885daa813e138">boost::locale::boundary::operator&gt;</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;r)</td></tr>
<tr class="memdesc:ga10f3000b645e5f2774b885daa813e138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:ga10f3000b645e5f2774b885daa813e138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6d3694ef2c5d7d05d6073fa440b99d"><td class="memTemplParams" colspan="2"><a id="ga3e6d3694ef2c5d7d05d6073fa440b99d"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:ga3e6d3694ef2c5d7d05d6073fa440b99d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga3e6d3694ef2c5d7d05d6073fa440b99d">boost::locale::boundary::operator&gt;=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const std::basic_string&lt; CharType, Traits, Alloc &gt; &amp;r)</td></tr>
<tr class="memdesc:ga3e6d3694ef2c5d7d05d6073fa440b99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br /></td></tr>
<tr class="separator:ga3e6d3694ef2c5d7d05d6073fa440b99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccffa142cbd409c95ae71eaafb312b27"><td class="memTemplParams" colspan="2"><a id="gaccffa142cbd409c95ae71eaafb312b27"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaccffa142cbd409c95ae71eaafb312b27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaccffa142cbd409c95ae71eaafb312b27">boost::locale::boundary::operator==</a> (const CharType *l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:gaccffa142cbd409c95ae71eaafb312b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:gaccffa142cbd409c95ae71eaafb312b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65f80a0c7bd7e5e889332dee4a5388b2"><td class="memTemplParams" colspan="2"><a id="ga65f80a0c7bd7e5e889332dee4a5388b2"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga65f80a0c7bd7e5e889332dee4a5388b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga65f80a0c7bd7e5e889332dee4a5388b2">boost::locale::boundary::operator!=</a> (const CharType *l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga65f80a0c7bd7e5e889332dee4a5388b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:ga65f80a0c7bd7e5e889332dee4a5388b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e9b991d409239e5bcc3f4b97bc62b3"><td class="memTemplParams" colspan="2"><a id="ga95e9b991d409239e5bcc3f4b97bc62b3"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga95e9b991d409239e5bcc3f4b97bc62b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga95e9b991d409239e5bcc3f4b97bc62b3">boost::locale::boundary::operator&lt;</a> (const CharType *l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga95e9b991d409239e5bcc3f4b97bc62b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:ga95e9b991d409239e5bcc3f4b97bc62b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7cbe6f0390624ca457c905b2d8d58e"><td class="memTemplParams" colspan="2"><a id="ga7e7cbe6f0390624ca457c905b2d8d58e"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga7e7cbe6f0390624ca457c905b2d8d58e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga7e7cbe6f0390624ca457c905b2d8d58e">boost::locale::boundary::operator&lt;=</a> (const CharType *l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga7e7cbe6f0390624ca457c905b2d8d58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:ga7e7cbe6f0390624ca457c905b2d8d58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e7ca31343aca75c0aefe1b1ab3b0a4"><td class="memTemplParams" colspan="2"><a id="gaa4e7ca31343aca75c0aefe1b1ab3b0a4"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaa4e7ca31343aca75c0aefe1b1ab3b0a4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa4e7ca31343aca75c0aefe1b1ab3b0a4">boost::locale::boundary::operator&gt;</a> (const CharType *l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:gaa4e7ca31343aca75c0aefe1b1ab3b0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:gaa4e7ca31343aca75c0aefe1b1ab3b0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c68281d1012d60cd0647a0e227397ca"><td class="memTemplParams" colspan="2"><a id="ga3c68281d1012d60cd0647a0e227397ca"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga3c68281d1012d60cd0647a0e227397ca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga3c68281d1012d60cd0647a0e227397ca">boost::locale::boundary::operator&gt;=</a> (const CharType *l, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; IteratorR &gt; &amp;r)</td></tr>
<tr class="memdesc:ga3c68281d1012d60cd0647a0e227397ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:ga3c68281d1012d60cd0647a0e227397ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975581d7bf488b707b840833c72025ae"><td class="memTemplParams" colspan="2"><a id="ga975581d7bf488b707b840833c72025ae"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:ga975581d7bf488b707b840833c72025ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga975581d7bf488b707b840833c72025ae">boost::locale::boundary::operator==</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const CharType *r)</td></tr>
<tr class="memdesc:ga975581d7bf488b707b840833c72025ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:ga975581d7bf488b707b840833c72025ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a62fa027eba3e4dd288ef6ab6ef347"><td class="memTemplParams" colspan="2"><a id="ga85a62fa027eba3e4dd288ef6ab6ef347"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:ga85a62fa027eba3e4dd288ef6ab6ef347"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga85a62fa027eba3e4dd288ef6ab6ef347">boost::locale::boundary::operator!=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const CharType *r)</td></tr>
<tr class="memdesc:ga85a62fa027eba3e4dd288ef6ab6ef347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:ga85a62fa027eba3e4dd288ef6ab6ef347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87c0deed978894e88bd0f443565b535"><td class="memTemplParams" colspan="2"><a id="gad87c0deed978894e88bd0f443565b535"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:gad87c0deed978894e88bd0f443565b535"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad87c0deed978894e88bd0f443565b535">boost::locale::boundary::operator&lt;</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const CharType *r)</td></tr>
<tr class="memdesc:gad87c0deed978894e88bd0f443565b535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:gad87c0deed978894e88bd0f443565b535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689b9a5efee8877d6543f95ffc72e5b1"><td class="memTemplParams" colspan="2"><a id="ga689b9a5efee8877d6543f95ffc72e5b1"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:ga689b9a5efee8877d6543f95ffc72e5b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga689b9a5efee8877d6543f95ffc72e5b1">boost::locale::boundary::operator&lt;=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const CharType *r)</td></tr>
<tr class="memdesc:ga689b9a5efee8877d6543f95ffc72e5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:ga689b9a5efee8877d6543f95ffc72e5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124de6d0bec31bccb7f9496a3ea3bb12"><td class="memTemplParams" colspan="2"><a id="ga124de6d0bec31bccb7f9496a3ea3bb12"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:ga124de6d0bec31bccb7f9496a3ea3bb12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga124de6d0bec31bccb7f9496a3ea3bb12">boost::locale::boundary::operator&gt;</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const CharType *r)</td></tr>
<tr class="memdesc:ga124de6d0bec31bccb7f9496a3ea3bb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:ga124de6d0bec31bccb7f9496a3ea3bb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49252531f8a5160655c375fd10cc49f2"><td class="memTemplParams" colspan="2"><a id="ga49252531f8a5160655c375fd10cc49f2"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:ga49252531f8a5160655c375fd10cc49f2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga49252531f8a5160655c375fd10cc49f2">boost::locale::boundary::operator&gt;=</a> (const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;l, const CharType *r)</td></tr>
<tr class="memdesc:ga49252531f8a5160655c375fd10cc49f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br /></td></tr>
<tr class="separator:ga49252531f8a5160655c375fd10cc49f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181e49683a4c67fa99bc85811b738eb8"><td class="memTemplParams" colspan="2"><a id="ga181e49683a4c67fa99bc85811b738eb8"></a>
template&lt;typename CharType , typename TraitsType , typename Iterator &gt; </td></tr>
<tr class="memitem:ga181e49683a4c67fa99bc85811b738eb8"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharType, TraitsType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga181e49683a4c67fa99bc85811b738eb8">boost::locale::boundary::operator&lt;&lt;</a> (std::basic_ostream&lt; CharType, TraitsType &gt; &amp;out, const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt; Iterator &gt; &amp;tok)</td></tr>
<tr class="memdesc:ga181e49683a4c67fa99bc85811b738eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the segment to the stream character by character. <br /></td></tr>
<tr class="separator:ga181e49683a4c67fa99bc85811b738eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99daacb708289fe81def9f1ce4486515"><td class="memItemLeft" align="right" valign="top"><a id="ga99daacb708289fe81def9f1ce4486515"></a>
<a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga99daacb708289fe81def9f1ce4486515">boost::locale::boundary::boundary_rule</a> (<a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a> t)</td></tr>
<tr class="memdesc:ga99daacb708289fe81def9f1ce4486515"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the mask that covers all variants for specific boundary type. <br /></td></tr>
<tr class="separator:ga99daacb708289fe81def9f1ce4486515"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga960209e8a9453221641eda6bd8c4989b"><td class="memItemLeft" align="right" valign="top"><a id="ga960209e8a9453221641eda6bd8c4989b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::locale::boundary::segment_index&lt; BaseIterator &gt;::boundary_point_index&lt; base_iterator &gt;</b></td></tr>
<tr class="separator:ga960209e8a9453221641eda6bd8c4989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ba2e18ec3780af8f001ba85e40b9e2"><td class="memItemLeft" align="right" valign="top"><a id="gaa8ba2e18ec3780af8f001ba85e40b9e2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::segment_index&lt; base_iterator &gt;</b></td></tr>
<tr class="separator:gaa8ba2e18ec3780af8f001ba85e40b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Flags that describe a type of word selected</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpabac8d1452313f3e83b136f6f21b6d18"></a><a class="anchor" id="bl_boundary_word_rules"></a></p>
</td></tr>
<tr class="memitem:ga71216fe20cf5bf27fad925960e28a0a0"><td class="memItemLeft" align="right" valign="top"><a id="ga71216fe20cf5bf27fad925960e28a0a0"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga71216fe20cf5bf27fad925960e28a0a0">boost::locale::boundary::word_none</a> = 0x0000F</td></tr>
<tr class="memdesc:ga71216fe20cf5bf27fad925960e28a0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not a word, like white space or punctuation mark. <br /></td></tr>
<tr class="separator:ga71216fe20cf5bf27fad925960e28a0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd1e128c2383df79d11fdc9a1032a603"><td class="memItemLeft" align="right" valign="top"><a id="gadd1e128c2383df79d11fdc9a1032a603"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gadd1e128c2383df79d11fdc9a1032a603">boost::locale::boundary::word_number</a> = 0x000F0</td></tr>
<tr class="memdesc:gadd1e128c2383df79d11fdc9a1032a603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that appear to be a number. <br /></td></tr>
<tr class="separator:gadd1e128c2383df79d11fdc9a1032a603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba1dcc8c153336ee597bb8af7ab56f14"><td class="memItemLeft" align="right" valign="top"><a id="gaba1dcc8c153336ee597bb8af7ab56f14"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaba1dcc8c153336ee597bb8af7ab56f14">boost::locale::boundary::word_letter</a> = 0x00F00</td></tr>
<tr class="memdesc:gaba1dcc8c153336ee597bb8af7ab56f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that contains letters, excluding kana and ideographic characters. <br /></td></tr>
<tr class="separator:gaba1dcc8c153336ee597bb8af7ab56f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0521910fc44d2a18ba9e97c350a7c021"><td class="memItemLeft" align="right" valign="top"><a id="ga0521910fc44d2a18ba9e97c350a7c021"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga0521910fc44d2a18ba9e97c350a7c021">boost::locale::boundary::word_kana</a> = 0x0F000</td></tr>
<tr class="memdesc:ga0521910fc44d2a18ba9e97c350a7c021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that contains kana characters. <br /></td></tr>
<tr class="separator:ga0521910fc44d2a18ba9e97c350a7c021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed31c3a214470c202954aa9ff03114a7"><td class="memItemLeft" align="right" valign="top"><a id="gaed31c3a214470c202954aa9ff03114a7"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaed31c3a214470c202954aa9ff03114a7">boost::locale::boundary::word_ideo</a> = 0xF0000</td></tr>
<tr class="memdesc:gaed31c3a214470c202954aa9ff03114a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that contains ideographic characters. <br /></td></tr>
<tr class="separator:gaed31c3a214470c202954aa9ff03114a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f44ab524e3f9c084e8fe5115edbf22b"><td class="memItemLeft" align="right" valign="top"><a id="ga3f44ab524e3f9c084e8fe5115edbf22b"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga3f44ab524e3f9c084e8fe5115edbf22b">boost::locale::boundary::word_any</a> = 0xFFFF0</td></tr>
<tr class="memdesc:ga3f44ab524e3f9c084e8fe5115edbf22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any word including numbers, 0 is special flag, equivalent to 15. <br /></td></tr>
<tr class="separator:ga3f44ab524e3f9c084e8fe5115edbf22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e66dea2e29dee9d31a6f62798ba5ed4"><td class="memItemLeft" align="right" valign="top"><a id="ga1e66dea2e29dee9d31a6f62798ba5ed4"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1e66dea2e29dee9d31a6f62798ba5ed4">boost::locale::boundary::word_letters</a> = 0xFFF00</td></tr>
<tr class="memdesc:ga1e66dea2e29dee9d31a6f62798ba5ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any word, excluding numbers but including letters, kana and ideograms. <br /></td></tr>
<tr class="separator:ga1e66dea2e29dee9d31a6f62798ba5ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c058d8e9e71cbf716b0833f30f5d97"><td class="memItemLeft" align="right" valign="top"><a id="gad1c058d8e9e71cbf716b0833f30f5d97"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad1c058d8e9e71cbf716b0833f30f5d97">boost::locale::boundary::word_kana_ideo</a> = 0xFF000</td></tr>
<tr class="memdesc:gad1c058d8e9e71cbf716b0833f30f5d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that includes kana or ideographic characters. <br /></td></tr>
<tr class="separator:gad1c058d8e9e71cbf716b0833f30f5d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c6471f56a38f96564baab0f28e93c94"><td class="memItemLeft" align="right" valign="top"><a id="ga3c6471f56a38f96564baab0f28e93c94"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga3c6471f56a38f96564baab0f28e93c94">boost::locale::boundary::word_mask</a> = 0xFFFFF</td></tr>
<tr class="memdesc:ga3c6471f56a38f96564baab0f28e93c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full word mask - select all possible variants. <br /></td></tr>
<tr class="separator:ga3c6471f56a38f96564baab0f28e93c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Flags that describe a type of line break</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp99d1c759163f3082dff790a7e8e04eb5"></a><a class="anchor" id="bl_boundary_line_rules"></a></p>
</td></tr>
<tr class="memitem:ga232b789c3de408e5e41e8e7c4da07d5b"><td class="memItemLeft" align="right" valign="top"><a id="ga232b789c3de408e5e41e8e7c4da07d5b"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga232b789c3de408e5e41e8e7c4da07d5b">boost::locale::boundary::line_soft</a> = 0x0F</td></tr>
<tr class="memdesc:ga232b789c3de408e5e41e8e7c4da07d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Soft line break: optional but not required. <br /></td></tr>
<tr class="separator:ga232b789c3de408e5e41e8e7c4da07d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1962236f68e81541315ab9174d4451da"><td class="memItemLeft" align="right" valign="top"><a id="ga1962236f68e81541315ab9174d4451da"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1962236f68e81541315ab9174d4451da">boost::locale::boundary::line_hard</a> = 0xF0</td></tr>
<tr class="memdesc:ga1962236f68e81541315ab9174d4451da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard line break: like break is required (as per CR/LF) <br /></td></tr>
<tr class="separator:ga1962236f68e81541315ab9174d4451da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd8753dbd0e0f0690b6f7051ce157ca"><td class="memItemLeft" align="right" valign="top"><a id="gaddd8753dbd0e0f0690b6f7051ce157ca"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaddd8753dbd0e0f0690b6f7051ce157ca">boost::locale::boundary::line_any</a> = 0xFF</td></tr>
<tr class="memdesc:gaddd8753dbd0e0f0690b6f7051ce157ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Soft or Hard line break. <br /></td></tr>
<tr class="separator:gaddd8753dbd0e0f0690b6f7051ce157ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf210f4f600c54b221b1ff82685709c43"><td class="memItemLeft" align="right" valign="top"><a id="gaf210f4f600c54b221b1ff82685709c43"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf210f4f600c54b221b1ff82685709c43">boost::locale::boundary::line_mask</a> = 0xFF</td></tr>
<tr class="memdesc:gaf210f4f600c54b221b1ff82685709c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select all types of line breaks. <br /></td></tr>
<tr class="separator:gaf210f4f600c54b221b1ff82685709c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Flags that describe a type of sentence break</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfb13ccc6dee7f63c89f426c484168b62"></a><a class="anchor" id="bl_boundary_sentence_rules"></a></p>
</td></tr>
<tr class="memitem:gaf0853266cec994b739d154c01908f112"><td class="memItemLeft" align="right" valign="top"><a id="gaf0853266cec994b739d154c01908f112"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf0853266cec994b739d154c01908f112">boost::locale::boundary::sentence_term</a> = 0x0F</td></tr>
<tr class="memdesc:gaf0853266cec994b739d154c01908f112"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sentence was terminated with a sentence terminator like ".", "!" possible followed by hard separator like CR, LF, PS. <br /></td></tr>
<tr class="separator:gaf0853266cec994b739d154c01908f112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf844b4988627324a59be9438ebb0bd2c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf844b4988627324a59be9438ebb0bd2c">boost::locale::boundary::sentence_sep</a></td></tr>
<tr class="memdesc:gaf844b4988627324a59be9438ebb0bd2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sentence does not contain terminator like ".", "!" but ended with hard separator like CR, LF, PS or end of input.  <a href="group__boundary.html#gaf844b4988627324a59be9438ebb0bd2c">More...</a><br /></td></tr>
<tr class="separator:gaf844b4988627324a59be9438ebb0bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7549d3fcfb42d53943176af742edacd"><td class="memItemLeft" align="right" valign="top"><a id="gac7549d3fcfb42d53943176af742edacd"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gac7549d3fcfb42d53943176af742edacd">boost::locale::boundary::sentence_any</a> = 0xFF</td></tr>
<tr class="memdesc:gac7549d3fcfb42d53943176af742edacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either first or second sentence break type;. <br /></td></tr>
<tr class="separator:gac7549d3fcfb42d53943176af742edacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc1f6762feab094bb7e41f1258ba66c"><td class="memItemLeft" align="right" valign="top"><a id="ga6cc1f6762feab094bb7e41f1258ba66c"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga6cc1f6762feab094bb7e41f1258ba66c">boost::locale::boundary::sentence_mask</a> = 0xFF</td></tr>
<tr class="memdesc:ga6cc1f6762feab094bb7e41f1258ba66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select all sentence breaking points. <br /></td></tr>
<tr class="separator:ga6cc1f6762feab094bb7e41f1258ba66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Flags that describe a type of character break.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3e1d3241fbeb9a60e2aefb02fdc6f34a"></a> At this point break iterator does not distinguish different kinds of characters so it is used for consistency. </p>
</td></tr>
<tr class="memitem:ga97a8618a8869e1b86ae008c1af7337e7"><td class="memItemLeft" align="right" valign="top"><a id="ga97a8618a8869e1b86ae008c1af7337e7"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga97a8618a8869e1b86ae008c1af7337e7">boost::locale::boundary::character_any</a> = 0xF</td></tr>
<tr class="memdesc:ga97a8618a8869e1b86ae008c1af7337e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not in use, just for consistency. <br /></td></tr>
<tr class="separator:ga97a8618a8869e1b86ae008c1af7337e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315e4baac1059256cd9009a765670554"><td class="memItemLeft" align="right" valign="top"><a id="ga315e4baac1059256cd9009a765670554"></a>
constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga315e4baac1059256cd9009a765670554">boost::locale::boundary::character_mask</a> = 0xF</td></tr>
<tr class="memdesc:ga315e4baac1059256cd9009a765670554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select all character breaking points. <br /></td></tr>
<tr class="separator:ga315e4baac1059256cd9009a765670554"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module contains all operations required for boundary analysis of text: character, word, line and sentence boundaries</p>
<p>This module contains all operations required for boundary analysis of text: character, word, like and sentence boundaries </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5f8e61b5babc3f0fa95f5fb8acae3724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f8e61b5babc3f0fa95f5fb8acae3724">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_iterator_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::<a class="el" href="group__boundary.html#ga5f8e61b5babc3f0fa95f5fb8acae3724">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>The bidirectional iterator that iterates over <a class="el" href="group__boundary.html#ga067c663d18faee08adb3355701ae72ba">value_type</a> objects.</p>
<ul>
<li>The iterators may be invalidated by use of any non-const member function including but not limited to <a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">rule(rule_type)</a> and <a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">full_select(bool)</a>.</li>
<li>The returned value_type object is valid as long as iterator points to it. So this following code is wrong as t used after p was updated: <div class="fragment"><div class="line"><a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">segment_index&lt;some_iterator&gt;::iterator</a> p=index.begin();</div><div class="line">segment&lt;some_iterator&gt; &amp;t = *p;</div><div class="line">++p;</div><div class="line">std::cout &lt;&lt; t.str() &lt;&lt; std::endl;</div></div><!-- fragment --> </li>
</ul>

</div>
</div>
<a id="gac9ce9158eb2fb030c1baf93376203d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9ce9158eb2fb030c1baf93376203d16">&#9670;&nbsp;</a></span>const_iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_iterator_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::<a class="el" href="group__boundary.html#gac9ce9158eb2fb030c1baf93376203d16">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>The bidirectional iterator that iterates over <a class="el" href="group__boundary.html#ga7f7328a860cf485a4bd8f17658c291e1">value_type</a> objects.</p>
<ul>
<li>The iterators may be invalidated by use of any non-const member function including but not limited to <a class="el" href="group__boundary.html#ga56e63913f51109e05a24a7136472a975">rule(rule_type)</a> member function.</li>
<li>The returned value_type object is valid as long as iterator points to it. So this following code is wrong as t used after p was updated: <div class="fragment"><div class="line"><a class="code" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">boundary_point_index&lt;some_iterator&gt;::iterator</a> p=index.begin();</div><div class="line">boundary_point&lt;some_iterator&gt; &amp;t = *p;</div><div class="line">++p;</div><div class="line"><a class="code" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a> r = t-&gt;rule();</div></div><!-- fragment --> </li>
</ul>

</div>
</div>
<a id="ga7b4dd7af8fad53fabd77e629da24d466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b4dd7af8fad53fabd77e629da24d466">&#9670;&nbsp;</a></span>index_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structboost_1_1locale_1_1boundary_1_1break__info.html">break_info</a>&gt; <a class="el" href="group__boundary.html#ga7b4dd7af8fad53fabd77e629da24d466">boost::locale::boundary::index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type holds the analysis of the text - all its break points with marks </p>

</div>
</div>
<a id="gaf7a775e77dbbca3495e11d646df96fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7a775e77dbbca3495e11d646df96fd2">&#9670;&nbsp;</a></span>iterator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_iterator_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::<a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The bidirectional iterator that iterates over <a class="el" href="group__boundary.html#ga067c663d18faee08adb3355701ae72ba">value_type</a> objects.</p>
<ul>
<li>The iterators may be invalidated by use of any non-const member function including but not limited to <a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">rule(rule_type)</a> and <a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">full_select(bool)</a>.</li>
<li>The returned value_type object is valid as long as iterator points to it. So this following code is wrong as t used after p was updated: <div class="fragment"><div class="line"><a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">segment_index&lt;some_iterator&gt;::iterator</a> p=index.begin();</div><div class="line">segment&lt;some_iterator&gt; &amp;t = *p;</div><div class="line">++p;</div><div class="line">std::cout &lt;&lt; t.str() &lt;&lt; std::endl;</div></div><!-- fragment --> </li>
</ul>

</div>
</div>
<a id="ga1af6e72b3c384edcebc0cf319fe97efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1af6e72b3c384edcebc0cf319fe97efe">&#9670;&nbsp;</a></span>iterator <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_iterator_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::<a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The bidirectional iterator that iterates over <a class="el" href="group__boundary.html#ga7f7328a860cf485a4bd8f17658c291e1">value_type</a> objects.</p>
<ul>
<li>The iterators may be invalidated by use of any non-const member function including but not limited to <a class="el" href="group__boundary.html#ga56e63913f51109e05a24a7136472a975">rule(rule_type)</a> member function.</li>
<li>The returned value_type object is valid as long as iterator points to it. So this following code is wrong as t used after p was updated: <div class="fragment"><div class="line"><a class="code" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">boundary_point_index&lt;some_iterator&gt;::iterator</a> p=index.begin();</div><div class="line">boundary_point&lt;some_iterator&gt; &amp;t = *p;</div><div class="line">++p;</div><div class="line"><a class="code" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a> r = t-&gt;rule();</div></div><!-- fragment --> </li>
</ul>

</div>
</div>
<a id="ga25e193c81052ef1795f1b53b46bc2095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25e193c81052ef1795f1b53b46bc2095">&#9670;&nbsp;</a></span>rule_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">boost::locale::boundary::rule_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags used with word boundary analysis &ndash; the type of the word, line or sentence boundary found. </p>
<p>It is a bit-mask that represents various combinations of rules used to select this specific boundary. </p>

</div>
</div>
<a id="ga067c663d18faee08adb3355701ae72ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga067c663d18faee08adb3355701ae72ba">&#9670;&nbsp;</a></span>value_type <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>&lt;<a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&gt; <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::<a class="el" href="group__boundary.html#ga067c663d18faee08adb3355701ae72ba">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type dereferenced by the <a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a> and <a class="el" href="group__boundary.html#ga5f8e61b5babc3f0fa95f5fb8acae3724">const_iterator</a>. It is an object that represents selected segment. </p>

</div>
</div>
<a id="ga7f7328a860cf485a4bd8f17658c291e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7328a860cf485a4bd8f17658c291e1">&#9670;&nbsp;</a></span>value_type <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a>&lt;<a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&gt; <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::<a class="el" href="group__boundary.html#ga7f7328a860cf485a4bd8f17658c291e1">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type dereferenced by the <a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a> and <a class="el" href="group__boundary.html#gac9ce9158eb2fb030c1baf93376203d16">const_iterator</a>. It is an object that represents the selected <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary point</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga15de9963ce9bb6037c8525901dfbf641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15de9963ce9bb6037c8525901dfbf641">&#9670;&nbsp;</a></span>boundary_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boost::locale::boundary::boundary_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This type describes a possible boundary analysis alternatives. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga15de9963ce9bb6037c8525901dfbf641ae80c964112541d88af9b875dafb6605d"></a>character&#160;</td><td class="fielddoc"><p>Analyse the text for character boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6"></a>word&#160;</td><td class="fielddoc"><p>Analyse the text for word boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9"></a>sentence&#160;</td><td class="fielddoc"><p>Analyse the text for Find sentence boundaries. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga15de9963ce9bb6037c8525901dfbf641a72895419fdd7219b3695cf0abd602ea4"></a>line&#160;</td><td class="fielddoc"><p>Analyse the text for positions suitable for line breaks. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae4ac52a6957bbe887f909a3a4827799e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ac52a6957bbe887f909a3a4827799e">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a> <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a> on the beginning of the segments range.</p>
<p>Preconditions: the <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> should have a mapping</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a id="ga6e90d12e12b0f701d4b0683ff2920b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e90d12e12b0f701d4b0683ff2920b2c">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a> <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a> on the beginning of the boundary points range.</p>
<p>Preconditions: this <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">boundary_point_index</a> should have a mapping</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a id="gaba6993dd50ad8cf2db8921e5cf668a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba6993dd50ad8cf2db8921e5cf668a69">&#9670;&nbsp;</a></span>boundary_point_index() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::<a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>When this object is constructed by default it does not include a valid index, thus calling <a class="el" href="group__boundary.html#ga6e90d12e12b0f701d4b0683ff2920b2c">begin()</a>, <a class="el" href="group__boundary.html#ga557ea241d682a34d483951880fd431fc">end()</a> or <a class="el" href="group__boundary.html#ga677d119609854886c94000b772f1c41b">find()</a> member functions would lead to undefined behavior </p>

</div>
</div>
<a id="ga6bf9efeab443b1aeefb7fb469ef765b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bf9efeab443b1aeefb7fb469ef765b2">&#9670;&nbsp;</a></span>boundary_point_index() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::<a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) using a rule <em>mask</em> for locale <em>loc</em>. </p>

</div>
</div>
<a id="gaf5306962935baaa400e51d063366f0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5306962935baaa400e51d063366f0ab">&#9670;&nbsp;</a></span>boundary_point_index() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::<a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) selecting all possible boundary points (full mask) for locale <em>loc</em>. </p>

</div>
</div>
<a id="ga72fa62eaacf5b1926146699532d3b25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72fa62eaacf5b1926146699532d3b25e">&#9670;&nbsp;</a></span>boundary_point_index() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::<a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">boundary_point_index</a> from a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>. It copies all indexing information and uses the default rule (all possible boundary points)</p>
<p>This operation is very cheap, so if you use <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">boundary_point_index</a> and <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> on the same text range it is much better to create one from another rather then indexing the same range twice.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#gaf19c6313d74a179e11bf3d6674a5d892">rule()</a> flags are not copied </dd></dl>

</div>
</div>
<a id="gab080ea82495551e0aa70abcd54010f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab080ea82495551e0aa70abcd54010f8b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a> <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a> on the ending of the segments range.</p>
<p>Preconditions: the <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> should have a mapping</p>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a id="ga557ea241d682a34d483951880fd431fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga557ea241d682a34d483951880fd431fc">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a> <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a> on the ending of the boundary points range.</p>
<p>Preconditions: this <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">boundary_point_index</a> should have a mapping</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a id="gaacbd8e4789a593a4c02bc3d9bd9a1d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacbd8e4789a593a4c02bc3d9bd9a1d68">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a> <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a first valid segment following a position <em>p</em>.</p>
<p>If <em>p</em> is inside a valid segment this segment is selected:</p>
<p>For example: For <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a> boundary analysis with <a class="el" href="group__boundary.html#ga3f44ab524e3f9c084e8fe5115edbf22b">word_any</a> <a class="el" href="group__boundary.html#gadedc114f14445bbaa91afba14ffb92a0" title="Get the mask of rules that are used.">rule()</a>:</p>
<ul>
<li>"to| be or ", would point to "be",</li>
<li>"t|o be or ", would point to "to",</li>
<li>"to be or| ", would point to end.</li>
</ul>
<p>Preconditions: the <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> should have a mapping and <em>p</em> should be valid iterator to the text in the mapped range.</p>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a id="ga677d119609854886c94000b772f1c41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga677d119609854886c94000b772f1c41b">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a> <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a first valid boundary point on a position <em>p</em> or following it.</p>
<p>For example: For <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a> boundary analysis of the text "to be or"</p>
<ul>
<li>"|to be", would return boundary point at "|to be",</li>
<li>"t|o be", would point to "to| be"</li>
</ul>
<p>Preconditions: the <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">boundary_point_index</a> should have a mapping and <em>p</em> should be valid iterator to the text in the mapped range.</p>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a id="gaa1560a05d1db02228ed0f5a16a650915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1560a05d1db02228ed0f5a16a650915">&#9670;&nbsp;</a></span>full_select() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::full_select </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the full_select property value - should segment include in the range values that not belong to specific <a class="el" href="group__boundary.html#gadedc114f14445bbaa91afba14ffb92a0">rule()</a> or not.</p>
<p>The default value is false.</p>
<p>For example for <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9">sentence</a> boundary with rule <a class="el" href="group__boundary.html#gaf0853266cec994b739d154c01908f112">sentence_term</a> the segments of text "Hello! How\nare you?" are "Hello!\", "are you?" when <a class="el" href="group__boundary.html#gaa1560a05d1db02228ed0f5a16a650915">full_select()</a> is false because "How\n" is selected as sentence by a rule spits the text by line feed. If <a class="el" href="group__boundary.html#gaa1560a05d1db02228ed0f5a16a650915">full_select()</a> is true the returned segments are "Hello! ", "How\nare you?" where "How\n" is joined with the following part "are you?" </p>

</div>
</div>
<a id="ga205fd51daa439a18527675e663a0802f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga205fd51daa439a18527675e663a0802f">&#9670;&nbsp;</a></span>full_select() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::full_select </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the full_select property value - should segment include in the range values that not belong to specific <a class="el" href="group__boundary.html#gadedc114f14445bbaa91afba14ffb92a0">rule()</a> or not.</p>
<p>The default value is false.</p>
<p>For example for <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9">sentence</a> boundary with rule <a class="el" href="group__boundary.html#gaf0853266cec994b739d154c01908f112">sentence_term</a> the segments of text "Hello! How\nare you?" are "Hello!\", "are you?" when <a class="el" href="group__boundary.html#gaa1560a05d1db02228ed0f5a16a650915">full_select()</a> is false because "How\n" is selected as sentence by a rule spits the text by line feed. If <a class="el" href="group__boundary.html#gaa1560a05d1db02228ed0f5a16a650915">full_select()</a> is true the returned segments are "Hello! ", "How\nare you?" where "How\n" is joined with the following part "are you?" </p>

</div>
</div>
<a id="ga3f82ec594bb8f4159352e6111c52fb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f82ec594bb8f4159352e6111c52fb03">&#9670;&nbsp;</a></span>map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new index for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) for locale <em>loc</em>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#gadedc114f14445bbaa91afba14ffb92a0">rule()</a> and <a class="el" href="group__boundary.html#gaa1560a05d1db02228ed0f5a16a650915">full_select()</a> remain unchanged. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="boundary_8cpp-example.html#a9">boundary.cpp</a>, and <a class="el" href="wboundary_8cpp-example.html#a9">wboundary.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga0f144a68688caf101e88f6824e1f0130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f144a68688caf101e88f6824e1f0130">&#9670;&nbsp;</a></span>map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new index for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) for locale <em>loc</em>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#gaf19c6313d74a179e11bf3d6674a5d892">rule()</a> remains unchanged. </dd></dl>

</div>
</div>
<a id="ga71d2e73911267180538859d35ee5db2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71d2e73911267180538859d35ee5db2c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&amp; <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy an index from a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>. It copies all indexing information and uses the default rule (all possible segments)</p>
<p>This operation is very cheap, so if you use <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">boundary_point_index</a> and <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> on same text range it is much better to create one from another rather then indexing the same range twice.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#gadedc114f14445bbaa91afba14ffb92a0">rule()</a> flags are not copied </dd></dl>

</div>
</div>
<a id="gac67c5d191f6ddb7e26ddf92386ce4606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac67c5d191f6ddb7e26ddf92386ce4606">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&amp; <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">boundary_point_index</a> from a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>. It copies all indexing information and keeps the current <a class="el" href="group__boundary.html#gaf19c6313d74a179e11bf3d6674a5d892">rule()</a> unchanged</p>
<p>This operation is very cheap, so if you use <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">boundary_point_index</a> and <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> on the same text range it is much better to create one from another rather then indexing the same range twice.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#gaf19c6313d74a179e11bf3d6674a5d892">rule()</a> flags are not copied </dd></dl>

</div>
</div>
<a id="ga2c354f4cc03677b58c97038cd84dc465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c354f4cc03677b58c97038cd84dc465">&#9670;&nbsp;</a></span>segment_index() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::<a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>When this object is constructed by default it does not include a valid index, thus calling <a class="el" href="group__boundary.html#gae4ac52a6957bbe887f909a3a4827799e">begin()</a>, <a class="el" href="group__boundary.html#gab080ea82495551e0aa70abcd54010f8b">end()</a> or <a class="el" href="group__boundary.html#gaacbd8e4789a593a4c02bc3d9bd9a1d68">find()</a> member functions would lead to undefined behavior </p>

</div>
</div>
<a id="ga77241a89e32aa94ef4f21088c3a3db34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77241a89e32aa94ef4f21088c3a3db34">&#9670;&nbsp;</a></span>segment_index() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::<a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) using a rule <em>mask</em> for locale <em>loc</em>. </p>

</div>
</div>
<a id="gaaf7dde1641324683fa717094e5487c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf7dde1641324683fa717094e5487c41">&#9670;&nbsp;</a></span>segment_index() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::<a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::locale &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) selecting all possible segments (full mask) for locale <em>loc</em>. </p>

</div>
</div>
<a id="ga46a7fe0442f3459d76859954bec55010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46a7fe0442f3459d76859954bec55010">&#9670;&nbsp;</a></span>segment_index() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::<a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> from a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>. It copies all indexing information and used default rule (all possible segments)</p>
<p>This operation is very cheap, so if you use <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them.">boundary_point_index</a> and <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them.">segment_index</a> on same text range it is much better to create one from another rather then indexing the same range twice.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#gadedc114f14445bbaa91afba14ffb92a0">rule()</a> flags are not copied </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaf844b4988627324a59be9438ebb0bd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf844b4988627324a59be9438ebb0bd2c">&#9670;&nbsp;</a></span>sentence_sep</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a> boost::locale::boundary::sentence_sep</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">            0xF0</div></div><!-- fragment -->
<p>The sentence does not contain terminator like ".", "!" but ended with hard separator like CR, LF, PS or end of input. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    <li class="footer">
&copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the <a href="https://www.boost.org/LICENSE_1_0.txt">Boost Software License</a>, Version 1.0.
    </li>
   </ul>
 </div>
</body>
</html>
