<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Boost.Locale: Boundary analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="section-basic.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="boost-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Boost.Locale
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('boundary_analysys.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Boundary analysis </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_basics">Basics</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_segments">Iterating Over Segments</a><ul>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_segments_basics">Basic Iteration</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_segments_rules">Using Rules</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_segments_search">Locating Segments</a></li>
</ul>
</li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_break">Iterating Over Boundary Points</a><ul>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_break_basics">Basic Iteration</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_break_rules">Using Rules</a></li>
<li><a class="el" href="boundary_analysys.html#boundary_analysys_break_search">Locating Boundary Points</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="boundary_analysys_basics"></a>
Basics</h1>
<p>Boost.Locale provides a boundary analysis tool, allowing you to split text into characters, words, or sentences. It is commonly used to find appropriate places for line breaks.</p>
<dl class="section note"><dt>Note</dt><dd>This is not a trivial task! </dd></dl>
<dl class="section user"><dt></dt><dd>A Unicode code point and a character are not equivalent. For example, the Hebrew word Shalom - "שָלוֹם" - consists of 4 characters and 6 code points (4 base letters and 2 diacritical marks). </dd></dl>
<dl class="section user"><dt></dt><dd>Words may not be separated by space characters in some languages like in Japanese or Chinese.</dd></dl>
<p>Boost.Locale provides 2 major classes for boundary analysis:</p>
<ul>
<li><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a> - an object that holds the index of segments in text (like words, characters, sentences). It provides access to <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a> objects via iterators.</li>
<li><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a> - an object that holds the index of boundary points in text. It can iterate over the <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a> objects.</li>
</ul>
<p>Each of the classes above use an iterator type as template parameter. Both of these classes accept in their constructors:</p>
<ul>
<li>A flag that defines boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>.</li>
<li>The pair of iterators that define the text range to be analysed</li>
<li>A locale parameter (if not given, the global one is used)</li>
</ul>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>ba=<a class="code" href="namespaceboost_1_1locale_1_1boundary.html">boost::locale::boundary</a>;</div><div class="line">std::string text= ... ;</div><div class="line">std::locale loc = ... ;</div><div class="line">ba::segment_index&lt;std::string::const_iterator&gt; map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">ba::word</a>,text.begin(),text.end(),loc);</div></div><!-- fragment --><p>Each class implements members <code>begin()</code>, <code>end()</code> and <code>find()</code> making it possible to iterate over the selected segments or boundaries in the text or find a location of a segment or boundary for a given iterator.</p>
<p>Convenience typedefs like <a class="el" href="group__boundary.html#gad4785439a3f03ee455c93830b8f1366c">ssegment_index</a> or <a class="el" href="group__boundary.html#ga416501f824c3b5e6f217a97c6bc231a5">wcboundary_point_index</a> are provided as well, where "w", "u16" and "u32" prefixes define a character type <code>wchar_t</code>, <code>char16_t</code> and <code>char32_t</code> and "c" and "s" prefixes define whether <code>std::basic_string&lt;CharType&gt;::const_iterator</code> or <code>CharType const *</code> are used.</p>
<h1><a class="anchor" id="boundary_analysys_segments"></a>
Iterating Over Segments</h1>
<h1><a class="anchor" id="boundary_analysys_segments_basics"></a>
Basic Iteration</h1>
<p>The text segments analysis is done using <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> class.</p>
<p>It provides a bidirectional iterator that returns <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a> object. The segment object represents a pair of iterators that define this segment and a rule according to which it was selected. It can be automatically converted to <code>std::basic_string</code> object.</p>
<p>To perform boundary analysis, we first create an index object and then iterate over it:</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1locale_1_1boundary.html">boost::locale::boundary</a>;</div><div class="line"><a class="code" href="classboost_1_1locale_1_1generator.html">boost::locale::generator</a> gen;</div><div class="line">std::string text=<span class="stringliteral">&quot;To be or not to be, that is the question.&quot;</span></div><div class="line"><span class="comment">// Create mapping of text for token iterator using the global locale.</span></div><div class="line"><a class="code" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));</div><div class="line"><span class="comment">// Print all &quot;words&quot; -- chunks of word boundary</span></div><div class="line"><span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">ssegment_index::iterator</a> it=map.begin(),e=map.end();it!=e;++it)</div><div class="line">    std::cout  &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>&lt;&lt; * it &lt;&lt; <span class="stringliteral">&quot;\&quot;, &quot;</span>;</div><div class="line">std::cout &lt;&lt; std::endl;</div></div><!-- fragment --><p>Would print:</p>
<pre class="fragment">"To", " ", "be", " ", "or", " ", "not", " ", "to", " ", "be", ",", " ", "that", " ", "is", " ", "the", " ", "question", ".",
</pre><p>This sentence "生きるか死ぬか、それが問題だ。" (<a href="http://tatoeba.org/eng/sentences/show/868189">from Tatoeba database</a>) would be split into following segments in the <code>ja_JP.UTF-8</code> (Japanese) locale:</p>
<pre class="fragment">"生", "きるか", "死", "ぬか", "、", "それが", "問題", "だ", "。",
</pre><p>The boundary analysis that is done by Boost.Locale is much more complicated than just splitting the text according to white space characters, although it is not always perfect.</p>
<h1><a class="anchor" id="boundary_analysys_segments_rules"></a>
Using Rules</h1>
<p>The segments selection can be customized using <a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">rule()</a> and <a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">full_select()</a> member functions.</p>
<p>By default, segment_index's iterator returns each text segment defined by two boundary points regardless the way they were selected. Thus in the example above we could see text segments like "." or " " that were selected as words.</p>
<p>Using a <code>rule()</code> member function we can specify a binary mask of rules we want to use for selection of boundary points using <a class="el" href="group__boundary.html#bl_boundary_word_rules">word</a>, <a class="el" href="group__boundary.html#bl_boundary_line_rules">line</a> and <a class="el" href="group__boundary.html#bl_boundary_sentence_rules">sentence</a> boundary rules.</p>
<p>For example, by calling</p>
<div class="fragment"><div class="line">map.rule(<a class="code" href="group__boundary.html#ga3f44ab524e3f9c084e8fe5115edbf22b">word_any</a>);</div></div><!-- fragment --><p>Before starting the iteration process, specify a selection mask that fetches: numbers, letter, Kana letters and ideographic characters ignoring all non-word related characters like white space or punctuation marks.</p>
<p>So the code:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1locale_1_1boundary.html">boost::locale::boundary</a>;</div><div class="line">std::string text=<span class="stringliteral">&quot;To be or not to be, that is the question.&quot;</span></div><div class="line"><span class="comment">// Create mapping of text for token iterator using the global locale.</span></div><div class="line"><a class="code" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a>,text.begin(),text.end());</div><div class="line"><span class="comment">// Define a rule</span></div><div class="line">map.<a class="code" href="group__boundary.html#gadedc114f14445bbaa91afba14ffb92a0">rule</a>(<a class="code" href="group__boundary.html#ga3f44ab524e3f9c084e8fe5115edbf22b">word_any</a>);</div><div class="line"><span class="comment">// Print all &quot;words&quot; -- chunks of word boundary</span></div><div class="line"><span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">ssegment_index::iterator</a> it=map.begin(),e=map.end();it!=e;++it)</div><div class="line">    std::cout &lt;&lt;<span class="stringliteral">&quot;\&quot;&quot;</span>&lt;&lt; * it &lt;&lt; <span class="stringliteral">&quot;\&quot;, &quot;</span>;</div><div class="line">std::cout &lt;&lt; std::endl;</div></div><!-- fragment --><p>Would print:</p>
<pre class="fragment">"To", "be", "or", "not", "to", "be", "that", "is", "the", "question",
</pre><p>And the for given text="生きるか死ぬか、それが問題だ。" and rule(<a class="el" href="group__boundary.html#gaed31c3a214470c202954aa9ff03114a7">word_ideo</a>), the example above would print:</p>
<pre class="fragment">"生", "死", "問題",
</pre><p>You can determine why a segment was selected by using the <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html#af3b5ea6d9b607692bfea9f692ecde825">segment::rule()</a> member function. The return value is a bit-mask of rules.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classboost_1_1locale_1_1generator.html">boost::locale::generator</a> gen;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1locale_1_1boundary.html">boost::locale::boundary</a>;</div><div class="line">std::string text=<span class="stringliteral">&quot;生きるか死ぬか、それが問題だ。&quot;</span>;</div><div class="line"><a class="code" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;ja_JP.UTF-8&quot;</span>));</div><div class="line"><span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">ssegment_index::iterator</a> it=map.begin(),e=map.end();it!=e;++it) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Segment &quot;</span> &lt;&lt; *it &lt;&lt; <span class="stringliteral">&quot; contains: &quot;</span>;</div><div class="line">    <span class="keywordflow">if</span>(it-&gt;rule() &amp; <a class="code" href="group__boundary.html#ga71216fe20cf5bf27fad925960e28a0a0">word_none</a>)</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;white space or punctuation marks &quot;</span>;</div><div class="line">    <span class="keywordflow">if</span>(it-&gt;rule() &amp; <a class="code" href="group__boundary.html#ga0521910fc44d2a18ba9e97c350a7c021">word_kana</a>)</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;kana characters &quot;</span>;</div><div class="line">    <span class="keywordflow">if</span>(it-&gt;rule() &amp; <a class="code" href="group__boundary.html#gaed31c3a214470c202954aa9ff03114a7">word_ideo</a>)</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ideographic characters&quot;</span>;</div><div class="line">    std::cout&lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Would print:</p>
<pre class="fragment">Segment 生 contains: ideographic characters
Segment きるか contains: kana characters
Segment 死 contains: ideographic characters
Segment ぬか contains: kana characters
Segment 、 contains: white space or punctuation marks
Segment それが contains: kana characters
Segment 問題 contains: ideographic characters
Segment だ contains: kana characters
Segment 。 contains: white space or punctuation marks
</pre><p>Note that rules are applied to the end boundary of a segment when deciding whether to include a segment. In some cases this can cause unexpected behavior.</p>
<p>For example, consider the text:</p>
<pre class="fragment">Hello! How
are you?
</pre><p>Suppose we want to fetch all sentences from the text.</p>
<p>The <a class="el" href="group__boundary.html#bl_boundary_sentence_rules">sentence rules</a> have two options:</p>
<ul>
<li>Split the text where sentence terminator like ".!?" are detected: <a class="el" href="group__boundary.html#gaf0853266cec994b739d154c01908f112">sentence_term</a></li>
<li>Split the text where sentence separators such as "line feed" are detected: <a class="el" href="group__boundary.html#gaf844b4988627324a59be9438ebb0bd2c">sentence_sep</a></li>
</ul>
<p>Naturally to ignore sentence separators we would call <a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">segment_index::rule(rule_type v)</a> with sentence_term parameter and then run the iterator.</p>
<div class="fragment"><div class="line"><a class="code" href="classboost_1_1locale_1_1generator.html">boost::locale::generator</a> gen;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1locale_1_1boundary.html">boost::locale::boundary</a>;</div><div class="line">std::string text=   <span class="stringliteral">&quot;Hello! How\n&quot;</span></div><div class="line">                    <span class="stringliteral">&quot;are you?\n&quot;</span>;</div><div class="line"><a class="code" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9">sentence</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));</div><div class="line">map.<a class="code" href="group__boundary.html#gadedc114f14445bbaa91afba14ffb92a0">rule</a>(<a class="code" href="group__boundary.html#gaf0853266cec994b739d154c01908f112">sentence_term</a>);</div><div class="line"><span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">ssegment_index::iterator</a> it=map.begin(),e=map.end();it!=e;++it)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Sentence [&quot;</span> &lt;&lt; *it &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>Would result in: </p><pre class="fragment">Sentence [Hello! ]
Sentence [are you?
]
</pre><p>These (potentially unexpected) results occur because "How\n" is still considered a sentence but is selected by a different rule.</p>
<p>This behavior can be changed by setting <a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">segment_index::full_select(bool)</a> to <code>true</code>. It will force the iterator to join the current segment with all previous segments even if they do not fit the required rule.</p>
<p>So we add this line:</p>
<div class="fragment"><div class="line">map.full_select(<span class="keyword">true</span>);</div></div><!-- fragment --><p>Right after "map.rule(sentence_term);" and get expected output:</p>
<pre class="fragment">Sentence [Hello! ]
Sentence [How
are you?
]
</pre><h2><a class="anchor" id="boundary_analysys_segments_search"></a>
Locating Segments</h2>
<p>Sometimes it is useful to find a segment that some specific iterator is pointing to.</p>
<p>For example, suppose we want to find the word a user clicked on.</p>
<p><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> provides <a class="el" href="group__boundary.html#gaacbd8e4789a593a4c02bc3d9bd9a1d68">find(base_iterator p)</a> member function for this purpose.</p>
<p>This function returns an iterator to the segment that includes <em>p</em>.</p>
<p>For example:</p>
<div class="fragment"><div class="line">text=<span class="stringliteral">&quot;to be or &quot;</span>;</div><div class="line"><a class="code" href="group__boundary.html#gad4785439a3f03ee455c93830b8f1366c">ssegment_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));</div><div class="line">ssegment_index::iterator  p = map.find(text.begin() + 4);</div><div class="line"><span class="keywordflow">if</span>(p!=map.end())</div><div class="line">    std::cout &lt;&lt; *p &lt;&lt; std::endl;</div></div><!-- fragment --><p>Would print:</p>
<pre class="fragment">be
</pre><dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>If the iterator is inside a segment, that segment is returned. If the segment does not fit the selection rules, then the next segment following the requested position that does fit the rules will be returned.</p>
<p>For example: For <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a> boundary analysis with <a class="el" href="group__boundary.html#ga3f44ab524e3f9c084e8fe5115edbf22b">word_any</a> rule:</p>
<ul>
<li>"t|o be or ", would point to "to" - the iterator in the middle of segment "to".</li>
<li>"to |be or ", would point to "be" - the iterator at the beginning of the segment "be".</li>
<li>"to| be or ", would point to "be" - the iterator is not pointing to a segment fitting the required rule, so next valid segment selected is "be".</li>
<li>"to be or| ", would point to end as no valid segment can be found.</li>
</ul>
<h1><a class="anchor" id="boundary_analysys_break"></a>
Iterating Over Boundary Points</h1>
<h1><a class="anchor" id="boundary_analysys_break_basics"></a>
Basic Iteration</h1>
<p>The <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> is similar to <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> in its interface but has a different role. Instead of returning text chunks (<a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">segment</a>s, it returns a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a> object that represents a position in text - a base iterator that is used for iteration of the source text C++ characters. The <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary_point</a> object also provides a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html#a757b28e11c66f9871d3f51fe93a51bdb">rule()</a> member function that returns why this boundary was selected, i.e. the matched rule.</p>
<dl class="section note"><dt>Note</dt><dd>The beginning and the ending of the text are considered boundary points, so even an empty text consists of at least one boundary point.</dd></dl>
<p>Lets see an example of selecting the first two sentences from a text:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1locale_1_1boundary.html">boost::locale::boundary</a>;</div><div class="line"><a class="code" href="classboost_1_1locale_1_1generator.html">boost::locale::generator</a> gen;</div><div class="line"></div><div class="line"><span class="comment">// Our text sample</span></div><div class="line">std::string <span class="keyword">const</span> text=<span class="stringliteral">&quot;First sentence. Second sentence! Third one?&quot;</span>;</div><div class="line"><span class="comment">// Create an index</span></div><div class="line"><a class="code" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">sboundary_point_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9">sentence</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));</div><div class="line"></div><div class="line"><span class="comment">// Count two boundary points</span></div><div class="line"><a class="code" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">sboundary_point_index::iterator</a> p = map.<a class="code" href="group__boundary.html#ga6e90d12e12b0f701d4b0683ff2920b2c">begin</a>(),e=map.end();</div><div class="line"><span class="keywordtype">int</span> count = 0;</div><div class="line"><span class="keywordflow">while</span>(p!=e &amp;&amp; count &lt; 2) {</div><div class="line">    ++count;</div><div class="line">    ++p;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">if</span>(p!=e) {</div><div class="line">    std::cout   &lt;&lt; <span class="stringliteral">&quot;First two sentences are: &quot;</span></div><div class="line">                &lt;&lt; std::string(text.begin(),p-&gt;iterator())</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">    std::cout   &lt;&lt;<span class="stringliteral">&quot;There are less than two sentences in this &quot;</span></div><div class="line">                &lt;&lt;<span class="stringliteral">&quot;text: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Would print:</p>
<pre class="fragment">First two sentences are: First sentence. Second sentence!
</pre><h1><a class="anchor" id="boundary_analysys_break_rules"></a>
Using Rules</h1>
<p>Just like <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a> the <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> provides a <a class="el" href="group__boundary.html#ga56e63913f51109e05a24a7136472a975">rule(rule_type mask)</a> member function to filter boundary points that interest us.</p>
<p>It allows to set <a class="el" href="group__boundary.html#bl_boundary_word_rules">word</a>, <a class="el" href="group__boundary.html#bl_boundary_line_rules">line</a> and <a class="el" href="group__boundary.html#bl_boundary_sentence_rules">sentence</a> rules for filtering boundary points.</p>
<p>Lets change the example above a bit:</p>
<div class="fragment"><div class="line"><span class="comment">// our text sample</span></div><div class="line">std::string <span class="keyword">const</span> text= <span class="stringliteral">&quot;First sentence. Second\n&quot;</span></div><div class="line">                        <span class="stringliteral">&quot;sentence! Third one?&quot;</span>;</div></div><!-- fragment --><p>If we run our program as is on the sample above we would get: </p><pre class="fragment">First two sentences are: First sentence. Second
</pre><p>Which is not really what we expected, because the "Second\n" is considered an independent sentence that was separated by a line separator "Line Feed".</p>
<p>However, we can set set the rule <a class="el" href="group__boundary.html#gaf0853266cec994b739d154c01908f112">sentence_term</a> and the iterator would use only boundary points that are created by a sentence terminators like ".!?".</p>
<p>So by adding: </p><div class="fragment"><div class="line">map.rule(<a class="code" href="group__boundary.html#gaf0853266cec994b739d154c01908f112">sentence_term</a>);</div></div><!-- fragment --><p>Right after the generation of the index we would get the desired output:</p>
<pre class="fragment">First two sentences are: First sentence. Second
sentence!
</pre><p>You can also use the <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html#a757b28e11c66f9871d3f51fe93a51bdb">boundary_point::rule()</a> member function to learn about the reason why this boundary point was created by comparing it with an appropriate mask.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1locale_1_1boundary.html">boost::locale::boundary</a>;</div><div class="line"><a class="code" href="classboost_1_1locale_1_1generator.html">boost::locale::generator</a> gen;</div><div class="line"><span class="comment">// our text sample</span></div><div class="line">std::string <span class="keyword">const</span> text= <span class="stringliteral">&quot;First sentence. Second\n&quot;</span></div><div class="line">                        <span class="stringliteral">&quot;sentence! Third one?&quot;</span>;</div><div class="line"><a class="code" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">sboundary_point_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9">sentence</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<a class="code" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">sboundary_point_index::iterator</a> p = map.begin(),e=map.end();p!=e;++p) {</div><div class="line">    <span class="keywordflow">if</span>(p-&gt;rule() &amp; <a class="code" href="group__boundary.html#gaf0853266cec994b739d154c01908f112">sentence_term</a>)</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;There is a sentence terminator: &quot;</span>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>(p-&gt;rule() &amp; <a class="code" href="group__boundary.html#gaf844b4988627324a59be9438ebb0bd2c">sentence_sep</a>)</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;There is a sentence separator: &quot;</span>;</div><div class="line">    <span class="keywordflow">if</span>(p-&gt;rule()!=0) <span class="comment">// print if some rule exists</span></div><div class="line">        std::cout   &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; std::string(text.begin(),p-&gt;iterator())</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot;|&quot;</span> &lt;&lt; std::string(p-&gt;iterator(),text.end())</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p>Would give the following output: </p><pre class="fragment">There is a sentence terminator: [First sentence. |Second
sentence! Third one?]
There is a sentence separator: [First sentence. Second
|sentence! Third one?]
There is a sentence terminator: [First sentence. Second
sentence! |Third one?]
There is a sentence terminator: [First sentence. Second
sentence! Third one?|]
</pre><h2><a class="anchor" id="boundary_analysys_break_search"></a>
Locating Boundary Points</h2>
<p>Sometimes it is useful to find a specific boundary point according to a given iterator.</p>
<p><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a> provides a <a class="el" href="group__boundary.html#ga677d119609854886c94000b772f1c41b">iterator find(base_iterator p)</a> member function.</p>
<p>It returns a boundary point on <em>p</em> or at the location following <em>p</em> if <em>p</em> does not point to an appropriate position.</p>
<p>For example, for word boundary analysis:</p>
<ul>
<li>If a base iterator points to "to |be", then the returned boundary point would be "to |be" (same position)</li>
<li>If a base iterator points to "t|o be", then the returned boundary point would be "to| be" (next valid position)</li>
</ul>
<p>For example, if we want to select 6 words around a specific boundary point we can use following code:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceboost_1_1locale_1_1boundary.html">boost::locale::boundary</a>;</div><div class="line"><a class="code" href="classboost_1_1locale_1_1generator.html">boost::locale::generator</a> gen;</div><div class="line"><span class="comment">// Our text sample</span></div><div class="line">std::string <span class="keyword">const</span> text= <span class="stringliteral">&quot;To be or not to be, that is the question.&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">// Create a mapping</span></div><div class="line"><a class="code" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">sboundary_point_index</a> map(<a class="code" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a>,text.begin(),text.end(),gen(<span class="stringliteral">&quot;en_US.UTF-8&quot;</span>));</div><div class="line"><span class="comment">// Ignore wite space</span></div><div class="line">map.<a class="code" href="group__boundary.html#gaf19c6313d74a179e11bf3d6674a5d892">rule</a>(<a class="code" href="group__boundary.html#ga3f44ab524e3f9c084e8fe5115edbf22b">word_any</a>);</div><div class="line"></div><div class="line"><span class="comment">// Define our arbitrary point</span></div><div class="line">std::string::const_iterator pos = text.begin() + 12; <span class="comment">// &quot;no|t&quot;;</span></div><div class="line"></div><div class="line"><span class="comment">// Get the search range</span></div><div class="line"><a class="code" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">sboundary_point_index::iterator</a></div><div class="line">    begin = map.begin(),</div><div class="line">    end = map.end(),</div><div class="line">    it = map.find(pos); <span class="comment">// find a boundary</span></div><div class="line"></div><div class="line"><span class="comment">// Go 3 words backward</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> count = 0;count &lt;3 &amp;&amp; it!=begin; count ++)</div><div class="line">    --it;</div><div class="line"></div><div class="line"><span class="comment">// Save the start</span></div><div class="line">std::string::const_iterator start = *it;</div><div class="line"></div><div class="line"><span class="comment">// Go 6 words forward</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> count = 0;count &lt; 6 &amp;&amp; it!=end; count ++)</div><div class="line">    ++it;</div><div class="line"></div><div class="line"><span class="comment">// Make sure we are at a valid position</span></div><div class="line"><span class="keywordflow">if</span>(it==end)</div><div class="line">    --it;</div><div class="line"></div><div class="line"><span class="comment">// Print the text</span></div><div class="line">std::cout &lt;&lt; std::string(start,it-&gt;iterator()) &lt;&lt; std::endl;</div></div><!-- fragment --><p>This would print:</p>
<pre class="fragment"> be or not to be, that
</pre> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->

    <li class="footer">
&copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the <a href="https://www.boost.org/LICENSE_1_0.txt">Boost Software License</a>, Version 1.0.
    </li>
   </ul>
 </div>
</body>
</html>
