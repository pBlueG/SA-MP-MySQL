<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/process/v2.hpp">
</header>
<header name="boost/process/v2/bind_launcher.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<struct name="bound_launcher"><template>
      <template-type-parameter name="Launcher"><purpose><para>The inner launcher to be used </para></purpose></template-type-parameter>
      <template-nontype-parameter name="Init"><type>typename ...</type></template-nontype-parameter>
    </template><purpose>Utility class to bind initializers to a launcher. </purpose><description><para>
This can be used when multiple processes shared some settings, e.g. </para></description><method-group name="public member functions">
<method name="operator()"><type>auto</type><template>
          <template-type-parameter name="ExecutionContext"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="executable"><paramtype>const typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, filesystem::path &gt;::type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter></method>
<method name="operator()"><type>auto</type><template>
          <template-type-parameter name="ExecutionContext"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><parameter name="executable"><paramtype>const typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, filesystem::path &gt;::type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter></method>
<method name="operator()"><type>auto</type><template>
          <template-type-parameter name="Executor"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="exec"><paramtype>Executor</paramtype></parameter><parameter name="executable"><paramtype>const typename std::enable_if&lt; boost::asio::execution::is_executor&lt; Executor &gt;::value||boost::asio::is_executor&lt; Executor &gt;::value, filesystem::path &gt;::type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter></method>
<method name="operator()"><type>auto</type><template>
          <template-type-parameter name="Executor"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="exec"><paramtype>Executor</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><parameter name="executable"><paramtype>const typename std::enable_if&lt; boost::asio::execution::is_executor&lt; Executor &gt;::value||boost::asio::is_executor&lt; Executor &gt;::value, filesystem::path &gt;::type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter></method>
</method-group>
<constructor><template>
          <template-type-parameter name="Launcher_"/>
          <template-nontype-parameter name="Init_"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="l"><paramtype>Launcher_ &amp;&amp;</paramtype></parameter><parameter name="init"><paramtype>Init_ &amp;&amp;...</paramtype></parameter></constructor>
<method-group name="private member functions">
<method name="invoke"><type>auto</type><template>
          <template-nontype-parameter name="Idx"><type>std::size_t ...</type></template-nontype-parameter>
          <template-type-parameter name="ExecutionContext"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="executable"><paramtype>const typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, filesystem::path &gt;::type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter></method>
<method name="invoke"><type>auto</type><template>
          <template-nontype-parameter name="Idx"><type>std::size_t ...</type></template-nontype-parameter>
          <template-type-parameter name="ExecutionContext"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><parameter name="executable"><paramtype>const typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, filesystem::path &gt;::type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter></method>
<method name="invoke"><type>auto</type><template>
          <template-nontype-parameter name="Idx"><type>std::size_t ...</type></template-nontype-parameter>
          <template-type-parameter name="Executor"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="exec"><paramtype>Executor</paramtype></parameter><parameter name="executable"><paramtype>const typename std::enable_if&lt; boost::asio::execution::is_executor&lt; Executor &gt;::value||boost::asio::is_executor&lt; Executor &gt;::value, filesystem::path &gt;::type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter></method>
<method name="invoke"><type>auto</type><template>
          <template-nontype-parameter name="Idx"><type>std::size_t ...</type></template-nontype-parameter>
          <template-type-parameter name="Executor"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="exec"><paramtype>Executor</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><parameter name="executable"><paramtype>const typename std::enable_if&lt; boost::asio::execution::is_executor&lt; Executor &gt;::value||boost::asio::is_executor&lt; Executor &gt;::value, filesystem::path &gt;::type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter></method>
</method-group>
</struct>















<function name="bind_launcher"><type>auto</type><template>
          <template-type-parameter name="Launcher"/>
          <template-nontype-parameter name="Init"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="launcher"><paramtype>Launcher &amp;&amp;</paramtype></parameter><parameter name="init"><paramtype>Init &amp;&amp;...</paramtype></parameter></function>
<function name="bind_default_launcher"><type>auto</type><template>
          <template-nontype-parameter name="Init"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="init"><paramtype>Init &amp;&amp;...</paramtype></parameter></function>
</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/cstring_ref.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<struct name="basic_cstring_ref"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
    </template><purpose>Small wrapper for a null-terminated string that can be directly passed to C APIS. </purpose><description><para>This ref can only be modified by moving the front pointer. It does not store the size, but can detect values that can directly be passed to system APIs.</para><para>It can be constructed from a <computeroutput>char*</computeroutput> pointer or any class that has a <computeroutput>c_str()</computeroutput> member function, e.g. std::string or boost::static_string. </para></description><typedef name="value_type"><type>CharT</type></typedef>
<typedef name="traits_type"><type>Traits</type></typedef>
<typedef name="string_view_type"><type>basic_string_view&lt; value_type, Traits &gt;</type></typedef>
<typedef name="pointer"><type>CharT *</type></typedef>
<typedef name="const_pointer"><type>const CharT *</type></typedef>
<typedef name="reference"><type>CharT &amp;</type></typedef>
<typedef name="const_reference"><type>const CharT &amp;</type></typedef>
<typedef name="const_iterator"><type>const_pointer</type></typedef>
<typedef name="iterator"><type>const_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>typename std::reverse_iterator&lt; const_iterator &gt;</type></typedef>
<typedef name="reverse_iterator"><type>typename std::reverse_iterator&lt; iterator &gt;</type></typedef>
<typedef name="size_type"><type>std::size_t</type></typedef>
<typedef name="difference_type"><type>std::ptrdiff_t</type></typedef>
<data-member name="npos" specifiers="static"><type>constexpr size_type</type></data-member>
<method-group name="public member functions">
<method name="c_str" cv="const noexcept"><type>constexpr basic_string_view&lt; value_type, Traits &gt;::const_pointer</type></method>
<method name="operator string_view_type" cv="const"><type>constexpr</type></method>
<method name="begin" cv="const noexcept"><type>constexpr const_iterator</type></method>
<method name="end" cv="const noexcept"><type>constexpr const_iterator</type></method>
<method name="cbegin" cv="const noexcept"><type>constexpr const_iterator</type></method>
<method name="cend" cv="const noexcept"><type>constexpr const_iterator</type></method>
<method name="rbegin" cv="const noexcept"><type>constexpr const_reverse_iterator</type></method>
<method name="rend" cv="const noexcept"><type>constexpr const_reverse_iterator</type></method>
<method name="crbegin" cv="const noexcept"><type>constexpr const_reverse_iterator</type></method>
<method name="crend" cv="const noexcept"><type>constexpr const_reverse_iterator</type></method>
<method name="size" cv="const noexcept"><type>constexpr size_type</type></method>
<method name="length" cv="const noexcept"><type>constexpr size_type</type></method>
<method name="max_size" cv="const noexcept"><type>constexpr size_type</type></method>
<method name="empty" cv="const noexcept"><type>constexpr bool</type></method>
<method name="operator[]" cv="const"><type>constexpr const_reference</type><parameter name="pos"><paramtype>size_type</paramtype></parameter></method>
<method name="at" cv="const"><type>constexpr const_reference</type><parameter name="pos"><paramtype>size_type</paramtype></parameter></method>
<method name="front" cv="const"><type>constexpr const_reference</type></method>
<method name="back" cv="const"><type>constexpr const_reference</type></method>
<method name="data" cv="const noexcept"><type>constexpr const_pointer</type></method>
<method name="remove_prefix"><type>constexpr void</type><parameter name="n"><paramtype>size_type</paramtype></parameter></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="s"><paramtype><classname>basic_cstring_ref</classname> &amp;</paramtype></parameter></method>
<method name="copy" cv="const"><type>size_type</type><parameter name="s"><paramtype>value_type *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter></method>
<method name="substr" cv="const"><type>constexpr <classname>basic_cstring_ref</classname></type><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter></method>
<method name="substr" cv="const"><type>constexpr string_view_type</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="length"><paramtype>size_type</paramtype></parameter></method>
<method name="compare" cv="const noexcept"><type>constexpr int</type><parameter name="x"><paramtype><classname>basic_cstring_ref</classname></paramtype></parameter></method>
<method name="starts_with" cv="const noexcept"><type>constexpr bool</type><parameter name="x"><paramtype>string_view_type</paramtype></parameter></method>
<method name="starts_with" cv="const noexcept"><type>constexpr bool</type><parameter name="x"><paramtype>value_type</paramtype></parameter></method>
<method name="find" cv="const noexcept"><type>constexpr size_type</type><parameter name="ch"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter></method>
<method name="clear" cv="noexcept"><type>void</type></method>
<method name="to_string" cv="const"><type>std::basic_string&lt; value_type, traits_type &gt;</type></method>
<method name="to_string" cv="const"><type>std::basic_string&lt; value_type, traits_type, Allocator &gt;</type><template>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="a"><paramtype>const Allocator &amp;</paramtype></parameter></method>
</method-group>
<constructor cv="noexcept"/>
<constructor cv="= delete"><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter></constructor>
<constructor><parameter name="s"><paramtype>const value_type *</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="Source"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;                    std::is_same&lt;const value_type,                            typename std::remove_pointer&lt;decltype(std::declval&lt;Source&gt;().c_str())&gt;::type                    &gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="src"><paramtype>Source &amp;&amp;</paramtype></parameter></constructor>
<method-group name="private static functions">
<method name="null_char_" specifiers="static"><type>constexpr const_pointer</type></method>
</method-group>
</struct><typedef name="cstring_ref"><type><classname>basic_cstring_ref</classname>&lt; char &gt;</type></typedef>
<typedef name="wcstring_ref"><type><classname>basic_cstring_ref</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="u16cstring_ref"><type><classname>basic_cstring_ref</classname>&lt; char16_t &gt;</type></typedef>
<typedef name="u32cstring_ref"><type><classname>basic_cstring_ref</classname>&lt; char32_t &gt;</type></typedef>














<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; charT, traits &gt; &amp;</type><template>
          <template-type-parameter name="charT"/>
          <template-type-parameter name="traits"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; charT, traits &gt; &amp;</paramtype></parameter><parameter name="str"><paramtype>const <classname>basic_cstring_ref</classname>&lt; charT, traits &gt; &amp;</paramtype></parameter></function>
<function name="hash_value"><type>std::size_t</type><template>
          <template-type-parameter name="charT"/>
          <template-type-parameter name="traits"/>
        </template><parameter name="s"><paramtype>basic_string_view&lt; charT, traits &gt;</paramtype></parameter></function>


</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/default_launcher.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<typedef name="default_process_launcher"><purpose>The default launcher for processes. </purpose><description><para>This launcher will be used by process if a process is launched through the constructor:</para><para><programlisting language="c++">process proc("test", {});
// equivalent to
process prod = default_launcher()("test", {});
</programlisting> </para></description><type>implementation_defined</type></typedef>


















</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/environment.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<struct name="process_environment"><purpose>Initializer for the environment of sub process. </purpose><description><para>This will set the environment in a subprocess:</para><para><programlisting language="c++">process proc{executor, find_executable("printenv"), {"foo"}, process_environment{"foo=bar"}};
</programlisting></para><para>The environment initializer will persist it's state, so that it can be used multiple times. Do however note the the Operating System is allowed to modify the internal state.</para><para><programlisting language="c++">auto exe = find_executable("printenv");
process_environment env = {"FOO=BAR", "BAR=FOO"};

process proc1(executor, exe, {"FOO"}, env);
process proc2(executor, exe, {"BAR"}, env);
</programlisting> </para></description><data-member name="env_buffer"><type>std::vector&lt; <classname>environment::key_value_pair</classname> &gt;</type></data-member>
<data-member name="env"><type>std::vector&lt; const char * &gt;</type></data-member>
<method-group name="public static functions">
<method name="build_env" specifiers="static"><type>std::vector&lt; const char * &gt;</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; std::is_convertible&lt; decltype(*std::begin(std::declval&lt; Args &gt;())), <classname>cstring_ref</classname> &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter></method>
</method-group>
<method-group name="public member functions">
<method name="build_env"><type>std::vector&lt; const char * &gt;</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; !std::is_convertible&lt; decltype(*std::begin(std::declval&lt; Args &gt;())), <classname>cstring_ref</classname> &gt;::value &gt;::type *</paramtype><default>nullptr</default></parameter></method>
<method name="on_setup"><type>error_code</type><parameter name="launcher"><paramtype>posix::default_launcher &amp;</paramtype></parameter><parameter name=""><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name=""><paramtype>const char *const *</paramtype></parameter></method>
</method-group>
<constructor><parameter name="sv"><paramtype>std::initializer_list&lt; string_view &gt;</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter></constructor>
</struct><namespace name="environment">
<struct name="current_view"><purpose>A view object for the current environment of this process. </purpose><description><para>The view might (windows) or might not (posix) be owning; if it owns it will deallocate the on destruction, like a unique_ptr.</para><para>Note that accessing the environment in this way is not thread-safe.</para><para><programlisting language="c++">void dump_my_env(current_view env = current())
{
   for (auto  &amp; [k, v] : env)
       std::cout &lt;&lt; k.string() &lt;&lt; " = "  &lt;&lt; v.string() &lt;&lt; std::endl;
}
</programlisting> </para></description><struct name="iterator"><typedef name="value_type"><type><classname>key_value_pair_view</classname></type></typedef>
<typedef name="difference_type"><type>int</type></typedef>
<typedef name="reference"><type><classname>key_value_pair_view</classname></type></typedef>
<typedef name="pointer"><type><classname>key_value_pair_view</classname></type></typedef>
<typedef name="iterator_category"><type>std::forward_iterator_tag</type></typedef>
<method-group name="public member functions">
<method name="operator++"><type><classname>iterator</classname> &amp;</type></method>
<method name="operator++"><type><classname>iterator</classname></type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method name="operator *" cv="const"><type><classname>key_value_pair_view</classname></type></method>
</method-group>
<constructor cv="= default"/>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>iterator</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="native_handle"><paramtype>const native_iterator &amp;</paramtype></parameter></constructor>
</struct><typedef name="native_handle_type"><type>environment::native_handle_type</type></typedef>
<typedef name="value_type"><type><classname>key_value_pair_view</classname></type></typedef>
<method-group name="public member functions">
<method name="native_handle"><type>native_handle_type</type></method>
<method name="begin" cv="const"><type><classname>iterator</classname></type></method>
<method name="end" cv="const"><type><classname>iterator</classname></type></method>
</method-group>
<constructor cv="= default"/>
<constructor cv="= default"><parameter name="nt"><paramtype><classname>current_view</classname> &amp;&amp;</paramtype></parameter></constructor>
</struct><struct name="key"><purpose>A class representing a key within an environment. </purpose><typedef name="value_type"><type>char_type</type></typedef>
<typedef name="traits_type"><type>key_char_traits&lt; char_type &gt;</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; char_type, traits_type &gt;</type></typedef>
<typedef name="string_view_type"><type>basic_string_view&lt; char_type, traits_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="assign"><type><classname>key</classname> &amp;</type><parameter name="source"><paramtype>string_type &amp;&amp;</paramtype></parameter></method>
<method name="assign"><type><classname>key</classname> &amp;</type><template>
          <template-type-parameter name="Source"/>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter></method>
<method name="assign"><type><classname>key</classname> &amp;</type><template>
          <template-type-parameter name="InputIt"/>
        </template><parameter name="first"><paramtype>InputIt</paramtype></parameter><parameter name="last"><paramtype>InputIt</paramtype></parameter></method>
<method name="clear"><type>void</type></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>key</classname> &amp;</paramtype></parameter></method>
<method name="c_str" cv="const noexcept"><type>const value_type *</type></method>
<method name="native" cv="const noexcept"><type>const string_type &amp;</type></method>
<method name="native_view" cv="const noexcept"><type>string_view_type</type></method>
<method name="conversion-operator" cv="const"><type>string_type</type></method>
<method name="conversion-operator" cv="const"><type>string_view_type</type></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="p"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>const string_type &amp;</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>string_view_type</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="s"><paramtype>const value_type *</paramtype></parameter></method>
<method name="basic_string" cv="const"><type>std::basic_string&lt; CharT, Traits, Alloc &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
          <template-type-parameter name="Alloc"><default>std::allocator&lt;CharT&gt;</default></template-type-parameter>
        </template><parameter name="alloc"><paramtype>const Alloc &amp;</paramtype><default>Alloc()</default></parameter></method>
<method name="string" cv="const"><type>std::string</type></method>
<method name="wstring" cv="const"><type>std::wstring</type></method>
<method name="native_string" cv="const"><type>const string_type &amp;</type></method>
<method name="empty" cv="const"><type>bool</type></method>
<method name="data" cv="const"><type>const value_type *</type></method>
<method name="size" cv="const"><type>std::size_t</type></method>
</method-group>
<constructor/>
<constructor cv="= default"><parameter name="p"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype><classname>key</classname> &amp;&amp;</paramtype></parameter></constructor>
<constructor><parameter name="source"><paramtype>const string_type &amp;</paramtype></parameter></constructor>
<constructor><parameter name="source"><paramtype>string_type &amp;&amp;</paramtype></parameter></constructor>
<constructor><parameter name="raw"><paramtype>const value_type *</paramtype></parameter></constructor>
<constructor><parameter name="raw"><paramtype>value_type *</paramtype></parameter></constructor>
<constructor specifiers="explicit"><parameter name="kv"><paramtype><classname>key_view</classname></paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="Source"/>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter><parameter name=""><paramtype>decltype(source.data())</paramtype><default>nullptr</default></parameter><parameter name=""><paramtype>decltype(source.size())</paramtype><default>0u</default></parameter></constructor>
<constructor><parameter name="raw"><paramtype>const typename conditional&lt; is_same&lt; value_type, char &gt;::<classname>value</classname>, wchar_t, char &gt;::type *</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="InputIt"/>
        </template><parameter name="first"><paramtype>InputIt</paramtype></parameter><parameter name="last"><paramtype>InputIt</paramtype></parameter></constructor>
<destructor/>
<copy-assignment cv="= default"><type><classname>key</classname> &amp;</type><parameter name="p"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>key</classname> &amp;</type><parameter name="p"><paramtype><classname>key</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>key</classname> &amp;</type><parameter name="source"><paramtype>string_type &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>key</classname> &amp;</type><template>
          <template-type-parameter name="Source"/>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter></copy-assignment>
</struct><struct name="key_value_pair"><typedef name="value_type"><type>char_type</type></typedef>
<typedef name="traits_type"><type>std::char_traits&lt; char_type &gt;</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; char_type &gt;</type></typedef>
<typedef name="string_view_type"><type><classname>basic_cstring_ref</classname>&lt; char_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="assign"><type><classname>key_value_pair</classname> &amp;</type><parameter name="source"><paramtype>string_type &amp;&amp;</paramtype></parameter></method>
<method name="assign"><type><classname>key_value_pair</classname> &amp;</type><template>
          <template-type-parameter name="Source"/>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter></method>
<method name="assign"><type><classname>key_value_pair</classname> &amp;</type><template>
          <template-type-parameter name="InputIt"/>
        </template><parameter name="first"><paramtype>InputIt</paramtype></parameter><parameter name="last"><paramtype>InputIt</paramtype></parameter></method>
<method name="clear"><type>void</type></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>key_value_pair</classname> &amp;</paramtype></parameter></method>
<method name="c_str" cv="const noexcept"><type>const value_type *</type></method>
<method name="native" cv="const noexcept"><type>const string_type &amp;</type></method>
<method name="native_view" cv="const noexcept"><type><classname>string_view_type</classname></type></method>
<method name="conversion-operator" cv="const"><type>string_type</type></method>
<method name="conversion-operator" cv="const"><type>string_view_type</type></method>
<method name="conversion-operator" cv="const"><type>typename string_view_type::string_view_type</type></method>
<method name="conversion-operator" cv="const"><type>key_value_pair_view</type></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="p"><paramtype>const <classname>key_value_pair</classname> &amp;</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>const string_type &amp;</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype><classname>string_view_type</classname></paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="s"><paramtype>const value_type *</paramtype></parameter></method>
<method name="basic_string" cv="const"><type>std::basic_string&lt; CharT, Traits, Alloc &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
          <template-type-parameter name="Alloc"><default>std::allocator&lt;CharT&gt;</default></template-type-parameter>
        </template><parameter name="alloc"><paramtype>const Alloc &amp;</paramtype><default>Alloc()</default></parameter></method>
<method name="string" cv="const"><type>std::string</type></method>
<method name="wstring" cv="const"><type>std::wstring</type></method>
<method name="native_string" cv="const"><type>const string_type &amp;</type></method>
<method name="empty" cv="const"><type>bool</type></method>
<method name="key" cv="const"><type>struct <classname>key_view</classname></type></method>
<method name="value" cv="const"><type>struct <classname>value_view</classname></type></method>
<method name="data" cv="const"><type>const value_type *</type></method>
<method name="size" cv="const"><type>std::size_t</type></method>
<method name="get" cv="const = 0" specifiers="virtual"><type>auto</type><template>
          <template-nontype-parameter name="Idx"><type>std::size_t</type></template-nontype-parameter>
        </template></method>
<method name="get" cv="const"><type><classname>key_view</classname></type><template>
        </template></method>
<method name="get" cv="const"><type><classname>value_view</classname></type><template>
        </template></method>
</method-group>
<constructor/>
<constructor cv="= default"><parameter name="p"><paramtype>const <classname>key_value_pair</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype><classname>key_value_pair</classname> &amp;&amp;</paramtype></parameter></constructor>
<constructor><parameter name="key"><paramtype><classname>key_view</classname></paramtype></parameter><parameter name="value"><paramtype><classname>value_view</classname></paramtype></parameter></constructor>
<constructor><parameter name="key"><paramtype><classname>key_view</classname></paramtype></parameter><parameter name="values"><paramtype>std::initializer_list&lt; basic_string_view&lt; char_type &gt;&gt;</paramtype></parameter></constructor>
<constructor><parameter name="source"><paramtype>const string_type &amp;</paramtype></parameter></constructor>
<constructor><parameter name="source"><paramtype>string_type &amp;&amp;</paramtype></parameter></constructor>
<constructor><parameter name="raw"><paramtype>const value_type *</paramtype></parameter></constructor>
<constructor><parameter name="raw"><paramtype>value_type *</paramtype></parameter></constructor>
<constructor specifiers="explicit"><parameter name="kv"><paramtype><classname>key_value_pair_view</classname></paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="Source"/>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter><parameter name=""><paramtype>decltype(source.data())</paramtype><default>nullptr</default></parameter><parameter name=""><paramtype>decltype(source.size())</paramtype><default>0u</default></parameter></constructor>
<constructor><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="kv"><paramtype>const std::pair&lt; Key, Value &gt; &amp;</paramtype></parameter></constructor>
<constructor><parameter name="raw"><paramtype>const typename conditional&lt; is_same&lt; value_type, char &gt;::<classname>value</classname>, wchar_t, char &gt;::type *</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="InputIt"/>
          <template-type-parameter name="std::iterator_traits&lt; InputIt &gt;::iterator_category"/>
        </template><parameter name="first"><paramtype>InputIt</paramtype></parameter><parameter name="last"><paramtype>InputIt</paramtype></parameter></constructor>
<destructor/>
<copy-assignment cv="= default"><type><classname>key_value_pair</classname> &amp;</type><parameter name="p"><paramtype>const <classname>key_value_pair</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>key_value_pair</classname> &amp;</type><parameter name="p"><paramtype><classname>key_value_pair</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>key_value_pair</classname> &amp;</type><parameter name="source"><paramtype>string_type &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>key_value_pair</classname> &amp;</type><template>
          <template-type-parameter name="Source"/>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter></copy-assignment>
</struct><struct name="key_value_pair_view"><purpose>A view for a key value pair in an environment. </purpose><typedef name="value_type"><type>char_type</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; char_type &gt;</type></typedef>
<typedef name="string_view_type"><type><classname>basic_cstring_ref</classname>&lt; char_type &gt;</type></typedef>
<typedef name="traits_type"><type>std::char_traits&lt; char_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>key_value_pair_view</classname> &amp;</paramtype></parameter></method>
<method name="native" cv="const noexcept"><type><classname>string_view_type</classname></type></method>
<method name="conversion-operator" cv="const"><type>string_view_type</type></method>
<method name="conversion-operator" cv="const"><type>typename string_view_type::string_view_type</type></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="p"><paramtype><classname>key_value_pair_view</classname></paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>const string_type &amp;</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype><classname>string_view_type</classname></paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="s"><paramtype>const value_type *</paramtype></parameter></method>
<method name="basic_string" cv="const"><type>std::basic_string&lt; CharT, Traits, Alloc &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
          <template-type-parameter name="Alloc"><default>std::allocator&lt;CharT&gt;</default></template-type-parameter>
        </template><parameter name="alloc"><paramtype>const Alloc &amp;</paramtype><default>Alloc()</default></parameter></method>
<method name="string" cv="const"><type>std::string</type></method>
<method name="wstring" cv="const"><type>std::wstring</type></method>
<method name="native_string" cv="const"><type>string_type</type></method>
<method name="empty" cv="const"><type>bool</type></method>
<method name="key" cv="const"><type><classname>key_view</classname></type></method>
<method name="value" cv="const"><type><classname>value_view</classname></type></method>
<method name="get" cv="const = 0" specifiers="virtual"><type>auto</type><template>
          <template-nontype-parameter name="Idx"><type>std::size_t</type></template-nontype-parameter>
        </template></method>
<method name="c_str" cv="const noexcept"><type>const value_type *</type></method>
<method name="data" cv="const"><type>const value_type *</type></method>
<method name="size" cv="const"><type>std::size_t</type></method>
<method name="get" cv="const"><type><classname>key_view</classname></type><template>
        </template></method>
<method name="get" cv="const"><type><classname>value_view</classname></type><template>
        </template></method>
</method-group>
<constructor/>
<constructor cv="= default"><parameter name="p"><paramtype>const <classname>key_value_pair_view</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype><classname>key_value_pair_view</classname> &amp;&amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="Source"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;is_constructible&lt;<classname alt="boost::process::v2::basic_cstring_ref">string_view_type</classname>, Source&gt;::<classname alt="boost::process::v2::environment::value">value</classname>&gt;::type</default></template-type-parameter>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype>const char_type *</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype>char_type *</paramtype></parameter></constructor>
<destructor/>
<copy-assignment cv="= default"><type><classname>key_value_pair_view</classname> &amp;</type><parameter name="p"><paramtype>const <classname>key_value_pair_view</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>key_value_pair_view</classname> &amp;</type><parameter name="p"><paramtype><classname>key_value_pair_view</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
</struct><struct name="key_view"><purpose>A view type for a key of an environment. </purpose><typedef name="value_type"><type>char_type</type></typedef>
<typedef name="traits_type"><type>key_char_traits&lt; char_type &gt;</type></typedef>
<typedef name="string_view_type"><type>basic_string_view&lt; char_type, traits_type &gt;</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; char_type, key_char_traits&lt; char_type &gt; &gt;</type></typedef>
<method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>key_view</classname> &amp;</paramtype></parameter></method>
<method name="native" cv="const noexcept"><type>string_view_type</type></method>
<method name="conversion-operator" cv="const"><type>string_view_type</type></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="p"><paramtype>const <classname>key_view</classname> &amp;</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>string_view_type</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="s"><paramtype>const value_type *</paramtype></parameter></method>
<method name="basic_string" cv="const"><type>std::basic_string&lt; CharT, Traits, Alloc &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
          <template-type-parameter name="Alloc"><default>std::allocator&lt;CharT&gt;</default></template-type-parameter>
        </template><parameter name="alloc"><paramtype>const Alloc &amp;</paramtype><default>Alloc()</default></parameter></method>
<method name="string" cv="const"><type>std::string</type></method>
<method name="wstring" cv="const"><type>std::wstring</type></method>
<method name="native_string" cv="const"><type>string_type</type></method>
<method name="empty" cv="const"><type>bool</type></method>
<method name="data" cv="const"><type>const value_type *</type></method>
<method name="size" cv="const"><type>std::size_t</type></method>
</method-group>
<constructor/>
<constructor cv="= default"><parameter name="p"><paramtype>const <classname>key_view</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype><classname>key_view</classname> &amp;&amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="Source"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;is_constructible&lt;string_view_type, Source&gt;::<classname alt="boost::process::v2::environment::value">value</classname>&gt;::type</default></template-type-parameter>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype>const char_type *</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype>char_type *</paramtype></parameter></constructor>
<destructor/>
<copy-assignment cv="= default"><type><classname>key_view</classname> &amp;</type><parameter name="p"><paramtype>const <classname>key_view</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>key_view</classname> &amp;</type><parameter name="p"><paramtype><classname>key_view</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>key_view</classname> &amp;</type><parameter name="source"><paramtype>string_view_type</paramtype></parameter></copy-assignment>
</struct><struct name="value"><typedef name="value_type"><type>char_type</type></typedef>
<typedef name="traits_type"><type>value_char_traits&lt; char_type &gt;</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; char_type, traits_type &gt;</type></typedef>
<typedef name="string_view_type"><type><classname>basic_cstring_ref</classname>&lt; char_type, traits_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="assign"><type><classname>value</classname> &amp;</type><parameter name="source"><paramtype>string_type &amp;&amp;</paramtype></parameter></method>
<method name="assign"><type><classname>value</classname> &amp;</type><template>
          <template-type-parameter name="Source"/>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter></method>
<method name="assign"><type><classname>value</classname> &amp;</type><template>
          <template-type-parameter name="InputIt"/>
        </template><parameter name="first"><paramtype>InputIt</paramtype></parameter><parameter name="last"><paramtype>InputIt</paramtype></parameter></method>
<method name="push_back"><type>void</type><parameter name="sv"><paramtype>const <classname>value</classname> &amp;</paramtype></parameter></method>
<method name="clear"><type>void</type></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>value</classname> &amp;</paramtype></parameter></method>
<method name="c_str" cv="const noexcept"><type>const value_type *</type></method>
<method name="native" cv="const noexcept"><type>const string_type &amp;</type></method>
<method name="native_view" cv="const noexcept"><type><classname>string_view_type</classname></type></method>
<method name="conversion-operator" cv="const"><type>string_type</type></method>
<method name="conversion-operator" cv="const"><type>string_view_type</type></method>
<method name="conversion-operator" cv="const"><type>typename string_view_type::string_view_type</type></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="p"><paramtype>const <classname>value</classname> &amp;</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>const string_type &amp;</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype><classname>string_view_type</classname></paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="s"><paramtype>const value_type *</paramtype></parameter></method>
<method name="basic_string" cv="const"><type>std::basic_string&lt; CharT, Traits, Alloc &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
          <template-type-parameter name="Alloc"><default>std::allocator&lt;CharT&gt;</default></template-type-parameter>
        </template><parameter name="alloc"><paramtype>const Alloc &amp;</paramtype><default>Alloc()</default></parameter></method>
<method name="string" cv="const"><type>std::string</type></method>
<method name="wstring" cv="const"><type>std::wstring</type></method>
<method name="native_string" cv="const"><type>const string_type &amp;</type></method>
<method name="empty" cv="const"><type>bool</type></method>
<method name="begin" cv="const"><type><classname>value_iterator</classname></type></method>
<method name="end" cv="const"><type><classname>value_iterator</classname></type></method>
<method name="data" cv="const"><type>const value_type *</type></method>
<method name="size" cv="const"><type>std::size_t</type></method>
</method-group>
<constructor/>
<constructor cv="= default"><parameter name="p"><paramtype>const <classname>value</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="source"><paramtype>const string_type &amp;</paramtype></parameter></constructor>
<constructor><parameter name="source"><paramtype>string_type &amp;&amp;</paramtype></parameter></constructor>
<constructor><parameter name="raw"><paramtype>const value_type *</paramtype></parameter></constructor>
<constructor><parameter name="raw"><paramtype>value_type *</paramtype></parameter></constructor>
<constructor specifiers="explicit"><parameter name="kv"><paramtype><classname>value_view</classname></paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="Source"/>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter><parameter name=""><paramtype>decltype(source.data())</paramtype><default>nullptr</default></parameter><parameter name=""><paramtype>decltype(source.size())</paramtype><default>0u</default></parameter></constructor>
<constructor><parameter name="raw"><paramtype>const typename conditional&lt; is_same&lt; value_type, char &gt;::<classname>value</classname>, wchar_t, char &gt;::type *</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="InputIt"/>
        </template><parameter name="first"><paramtype>InputIt</paramtype></parameter><parameter name="last"><paramtype>InputIt</paramtype></parameter></constructor>
<destructor/>
<copy-assignment cv="= default"><type><classname>value</classname> &amp;</type><parameter name="p"><paramtype>const <classname>value</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>value</classname> &amp;</type><parameter name="p"><paramtype><classname>value</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>value</classname> &amp;</type><parameter name="source"><paramtype>string_type &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>value</classname> &amp;</type><template>
          <template-type-parameter name="Source"/>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter></copy-assignment>
</struct><struct name="value_iterator"><purpose>The iterator used by a value or <classname alt="boost::process::v2::environment::value_view">value_view</classname> to iterator through environments that are lists. </purpose><typedef name="string_view_type"><type>basic_string_view&lt; char_type, value_char_traits&lt; char_type &gt; &gt;</type></typedef>
<typedef name="difference_type"><type>int</type></typedef>
<typedef name="reference"><type>string_view_type</type></typedef>
<typedef name="iterator_category"><type>std::forward_iterator_tag</type></typedef>
<method-group name="public member functions">
<method name="operator++"><type><classname>value_iterator</classname> &amp;</type></method>
<method name="operator++"><type><classname>value_iterator</classname></type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method name="operator *" cv="const"><type>string_view_type</type></method>
</method-group>
<constructor cv="= default"/>
<constructor cv="= default"><parameter name=""><paramtype>const <classname>value_iterator</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="view"><paramtype>string_view_type</paramtype></parameter><parameter name="offset"><paramtype>std::size_t</paramtype><default>0u</default></parameter></constructor>
</struct><struct name="value_view"><purpose>A view for a value in an environment. </purpose><typedef name="value_type"><type>char_type</type></typedef>
<typedef name="string_view_type"><type><classname>basic_cstring_ref</classname>&lt; char_type, value_char_traits&lt; char_type &gt; &gt;</type></typedef>
<typedef name="string_type"><type>std::basic_string&lt; char_type, value_char_traits&lt; char_type &gt; &gt;</type></typedef>
<typedef name="traits_type"><type>value_char_traits&lt; char_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>value_view</classname> &amp;</paramtype></parameter></method>
<method name="native" cv="const noexcept"><type><classname>string_view_type</classname></type></method>
<method name="conversion-operator" cv="const"><type>string_view_type</type></method>
<method name="conversion-operator" cv="const"><type>typename string_view_type::string_view_type</type></method>
<method name="compare" cv="const noexcept"><type>int</type><parameter name="p"><paramtype>const <classname>value_view</classname> &amp;</paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype><classname>string_view_type</classname></paramtype></parameter></method>
<method name="compare" cv="const"><type>int</type><parameter name="s"><paramtype>const value_type *</paramtype></parameter></method>
<method name="basic_string" cv="const"><type>std::basic_string&lt; CharT, Traits, Alloc &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
          <template-type-parameter name="Alloc"><default>std::allocator&lt;CharT&gt;</default></template-type-parameter>
        </template><parameter name="alloc"><paramtype>const Alloc &amp;</paramtype><default>Alloc()</default></parameter></method>
<method name="string" cv="const"><type>std::string</type></method>
<method name="wstring" cv="const"><type>std::wstring</type></method>
<method name="native_string" cv="const"><type>string_type</type></method>
<method name="empty" cv="const"><type>bool</type></method>
<method name="begin" cv="const"><type><classname>value_iterator</classname></type></method>
<method name="end" cv="const"><type><classname>value_iterator</classname></type></method>
<method name="c_str"><type>const char_type *</type></method>
<method name="data" cv="const"><type>const value_type *</type></method>
<method name="size" cv="const"><type>std::size_t</type></method>
</method-group>
<constructor/>
<constructor cv="= default"><parameter name="p"><paramtype>const <classname>value_view</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype><classname>value_view</classname> &amp;&amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="Source"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;is_constructible&lt;<classname alt="boost::process::v2::basic_cstring_ref">string_view_type</classname>, Source&gt;::<classname alt="boost::process::v2::environment::value">value</classname>&gt;::type</default></template-type-parameter>
        </template><parameter name="source"><paramtype>const Source &amp;</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype>const char_type *</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype>char_type *</paramtype></parameter></constructor>
<destructor/>
<copy-assignment cv="= default"><type><classname>value_view</classname> &amp;</type><parameter name="p"><paramtype>const <classname>value_view</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>value_view</classname> &amp;</type><parameter name="p"><paramtype><classname>value_view</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>value_view</classname> &amp;</type><parameter name="source"><paramtype><classname>string_view_type</classname></paramtype></parameter></copy-assignment>
</struct><typedef name="key_char_traits"><purpose>A char traits type that reflects the OS rules for string representing environment keys. </purpose><description><para>Can be an alias of std::char_traits. May only be defined for <computeroutput>char</computeroutput> and <computeroutput>wchar_t</computeroutput>.</para><para>Windows treats keys as case-insensitive yet perserving. The char traits are made to reflect that behaviour. </para></description><type>implementation_defined</type></typedef>
<typedef name="value_char_traits"><purpose>A char traits type that reflects the OS rules for string representing environment values. </purpose><description><para>Can be an alias of std::char_traits. May only be defined for <computeroutput>char</computeroutput> and <computeroutput>wchar_t</computeroutput>. </para></description><type>implementation_defined</type></typedef>
<typedef name="char_type"><purpose>The character type used by the environment. Either <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput>. </purpose><type>implementation_defined</type></typedef>
<typedef name="native_handle"><purpose>The native handle of an environment. Note that this can be an owning pointer and is generally not thread safe. </purpose><type>implementation_defined</type></typedef>
<data-member name="equality_sign"><type>constexpr char_type</type><purpose>The equal character in an environment string used to separate key and value. </purpose></data-member>
<data-member name="delimiter"><type>constexpr char_type</type><purpose>The delimiter in environemtn lists. Commonly used by the <computeroutput>PATH</computeroutput> variable. </purpose></data-member>
<function name="hash_value"><type>std::size_t</type><parameter name="value"><paramtype>const <classname>key_view</classname> &amp;</paramtype></parameter></function>
<function name="hash_value"><type>std::size_t</type><parameter name="value"><paramtype>const <classname>boost::process::v2::environment::value_view</classname> &amp;</paramtype></parameter></function>
<function name="hash_value"><type>std::size_t</type><parameter name="value"><paramtype>const <classname>boost::process::v2::environment::key_value_pair_view</classname> &amp;</paramtype></parameter></function>
<function name="operator=="><type>bool</type><parameter name=""><paramtype>const <classname>value_view</classname> &amp;</paramtype></parameter><parameter name="value_view"><paramtype>const</paramtype></parameter></function>
<function name="operator!="><type>bool</type><parameter name=""><paramtype>const <classname>value_view</classname> &amp;</paramtype></parameter><parameter name="value_view"><paramtype>const</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><parameter name=""><paramtype>const <classname>value_view</classname> &amp;</paramtype></parameter><parameter name="value_view"><paramtype>const</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><parameter name=""><paramtype>const <classname>value_view</classname> &amp;</paramtype></parameter><parameter name="value_view"><paramtype>const</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><parameter name=""><paramtype>const <classname>value_view</classname> &amp;</paramtype></parameter><parameter name="value_view"><paramtype>const</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><parameter name=""><paramtype>const <classname>value_view</classname> &amp;</paramtype></parameter><parameter name="value_view"><paramtype>const</paramtype></parameter></function>
<function name="operator=="><type>bool</type><parameter name=""><paramtype>const <classname>key_value_pair_view</classname> &amp;</paramtype></parameter><parameter name="key_value_pair_view"><paramtype>const</paramtype></parameter></function>
<function name="operator!="><type>bool</type><parameter name=""><paramtype>const <classname>key_value_pair_view</classname> &amp;</paramtype></parameter><parameter name="key_value_pair_view"><paramtype>const</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><parameter name=""><paramtype>const <classname>key_value_pair_view</classname> &amp;</paramtype></parameter><parameter name="key_value_pair_view"><paramtype>const</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><parameter name=""><paramtype>const <classname>key_value_pair_view</classname> &amp;</paramtype></parameter><parameter name="key_value_pair_view"><paramtype>const</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><parameter name=""><paramtype>const <classname>key_value_pair_view</classname> &amp;</paramtype></parameter><parameter name="key_value_pair_view"><paramtype>const</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><parameter name=""><paramtype>const <classname>key_value_pair_view</classname> &amp;</paramtype></parameter><parameter name="key_value_pair_view"><paramtype>const</paramtype></parameter></function>
<function name="current"><type><classname>current_view</classname></type><purpose>Obtain a handle to the current environment. </purpose></function>
<function name="home"><type>filesystem::path</type><template>
          <template-type-parameter name="Environment"><default>current_view</default></template-type-parameter>
        </template><parameter name="env"><paramtype>Environment &amp;&amp;</paramtype><default>current()</default><description><para>The environment to search. Defaults to the current environment of this process</para></description></parameter><purpose>Find the home folder in an environment-like type. </purpose><description><para>
The environment type passed in must be a range with value T that fulfills the following requirements:</para><para>For <computeroutput>T value</computeroutput></para><para><itemizedlist>
<listitem><para>std::get&lt;0&gt;(value) must return a type comparable to <computeroutput><classname alt="boost::process::v2::environment::key_view">key_view</classname></computeroutput>.</para>
</listitem><listitem><para>std::get&lt;1&gt;(value) must return a type convertible to filesystem::path.</para>
</listitem></itemizedlist>
</para><para>
</para></description><returns><para>A filesystem::path to the home directory or an empty path if it cannot be found. </para>
</returns></function>
<function name="find_executable"><type>boost::process::v2::filesystem::path</type><template>
          <template-type-parameter name="Environment"><default>current_view</default></template-type-parameter>
        </template><parameter name="name"><paramtype>boost::process::v2::filesystem::path</paramtype></parameter><parameter name="env"><paramtype>Environment &amp;&amp;</paramtype><default>current()</default><description><para>The environment to search. Defaults to the current environment of this process</para></description></parameter><purpose>Find the executable <computeroutput>name</computeroutput> in an environment-like type. </purpose><description><para>
The environment type passed in must be a range with value T that fulfills the following requirements:</para><para>For <computeroutput>T value</computeroutput></para><para><itemizedlist>
<listitem><para>std::get&lt;0&gt;(value) must return a type comparable to <computeroutput><classname alt="boost::process::v2::environment::key_view">key_view</classname></computeroutput>.</para>
</listitem><listitem><para>std::get&lt;1&gt;(value) must return a type convertible to <computeroutput><classname alt="boost::process::v2::environment::value_view">value_view</classname></computeroutput>.</para>
</listitem></itemizedlist>
</para><para>
</para></description><returns><para>A filesystem::path to the executable or an empty path if it cannot be found. </para>
</returns></function>
<overloaded-function name="get"><signature><type><classname>value</classname></type><parameter name="k"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type><classname>value</classname></type><parameter name="k"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter></signature><signature><type><classname>value</classname></type><parameter name="k"><paramtype><classname>basic_cstring_ref</classname>&lt; char_type, key_char_traits&lt; char_type &gt;&gt;</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type><classname>value</classname></type><parameter name="k"><paramtype><classname>basic_cstring_ref</classname>&lt; char_type, key_char_traits&lt; char_type &gt;&gt;</paramtype></parameter></signature><signature><type><classname>value</classname></type><parameter name="c"><paramtype>const char_type *</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type><classname>value</classname></type><parameter name="c"><paramtype>const char_type *</paramtype></parameter></signature><purpose>Get an environment variable from the current process. </purpose></overloaded-function>





<overloaded-function name="set"><signature><type>void</type><parameter name="k"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter><parameter name="vw"><paramtype><classname>value_view</classname></paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type>void</type><parameter name="k"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter><parameter name="vw"><paramtype><classname>value_view</classname></paramtype></parameter></signature><signature><type>void</type><parameter name="k"><paramtype><classname>basic_cstring_ref</classname>&lt; char_type, key_char_traits&lt; char_type &gt;&gt;</paramtype></parameter><parameter name="vw"><paramtype><classname>value_view</classname></paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type>void</type><parameter name="k"><paramtype><classname>basic_cstring_ref</classname>&lt; char_type, key_char_traits&lt; char_type &gt;&gt;</paramtype></parameter><parameter name="vw"><paramtype><classname>value_view</classname></paramtype></parameter></signature><signature><type>void</type><parameter name="k"><paramtype>const char_type *</paramtype></parameter><parameter name="vw"><paramtype><classname>value_view</classname></paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type>void</type><parameter name="k"><paramtype>const char_type *</paramtype></parameter><parameter name="vw"><paramtype><classname>value_view</classname></paramtype></parameter></signature><signature><type>void</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;!std::is_same&lt;Char, char_type&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="k"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter><parameter name="vw"><paramtype>const Char *</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type>void</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;!std::is_same&lt;Char, char_type&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="k"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter><parameter name="vw"><paramtype>const Char *</paramtype></parameter></signature><signature><type>void</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;!std::is_same&lt;Char, char_type&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="k"><paramtype><classname>basic_cstring_ref</classname>&lt; char_type, key_char_traits&lt; char_type &gt;&gt;</paramtype></parameter><parameter name="vw"><paramtype>const Char *</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type>void</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;!std::is_same&lt;Char, char_type&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="k"><paramtype><classname>basic_cstring_ref</classname>&lt; char_type, key_char_traits&lt; char_type &gt;&gt;</paramtype></parameter><parameter name="vw"><paramtype>const Char *</paramtype></parameter></signature><signature><type>void</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;!std::is_same&lt;Char, char_type&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="k"><paramtype>const char_type *</paramtype></parameter><parameter name="vw"><paramtype>const Char *</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type>void</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name=""><default>typename std::enable_if&lt;!std::is_same&lt;Char, char_type&gt;::value&gt;::type</default></template-type-parameter>
        </template><parameter name="k"><paramtype>const char_type *</paramtype></parameter><parameter name="vw"><paramtype>const Char *</paramtype></parameter></signature><purpose>Set an environment variable for the current process. </purpose></overloaded-function>











<overloaded-function name="unset"><signature><type>void</type><parameter name="k"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type>void</type><parameter name="k"><paramtype>const <classname>key</classname> &amp;</paramtype></parameter></signature><signature><type>void</type><parameter name="k"><paramtype><classname>basic_cstring_ref</classname>&lt; char_type, key_char_traits&lt; char_type &gt;&gt;</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type>void</type><parameter name="k"><paramtype><classname>basic_cstring_ref</classname>&lt; char_type, key_char_traits&lt; char_type &gt;&gt;</paramtype></parameter></signature><signature><type>void</type><parameter name="c"><paramtype>const char_type *</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><signature><type>void</type><parameter name="c"><paramtype>const char_type *</paramtype></parameter></signature><purpose>Remove an environment variable from the current process. </purpose></overloaded-function>





</namespace>
<namespace name="posix">
</namespace>


















</namespace>
</namespace>
</namespace>
<namespace name="std">
<struct-specialization name="hash"><template>
    </template><specialization><template-arg>boost::process::v2::environment::key</template-arg></specialization><method-group name="public member functions">
<method name="operator()" cv="const noexcept"><type>std::size_t</type><parameter name="kv"><paramtype><classname>boost::process::v2::environment::key_view</classname></paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="hash"><template>
    </template><specialization><template-arg>boost::process::v2::environment::key_value_pair</template-arg></specialization><method-group name="public member functions">
<method name="operator()" cv="const noexcept"><type>std::size_t</type><parameter name="kv"><paramtype><classname>boost::process::v2::environment::key_value_pair_view</classname></paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="hash"><template>
    </template><specialization><template-arg>boost::process::v2::environment::key_value_pair_view</template-arg></specialization><method-group name="public member functions">
<method name="operator()" cv="const noexcept"><type>std::size_t</type><parameter name="kv"><paramtype><classname>boost::process::v2::environment::key_value_pair_view</classname></paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="hash"><template>
    </template><specialization><template-arg>boost::process::v2::environment::key_view</template-arg></specialization><method-group name="public member functions">
<method name="operator()" cv="const noexcept"><type>std::size_t</type><parameter name="kv"><paramtype><classname>boost::process::v2::environment::key_view</classname></paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="hash"><template>
    </template><specialization><template-arg>boost::process::v2::environment::value</template-arg></specialization><method-group name="public member functions">
<method name="operator()" cv="const noexcept"><type>std::size_t</type><parameter name="kv"><paramtype><classname>boost::process::v2::environment::value_view</classname></paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="hash"><template>
    </template><specialization><template-arg>boost::process::v2::environment::value_view</template-arg></specialization><method-group name="public member functions">
<method name="operator()" cv="const noexcept"><type>std::size_t</type><parameter name="kv"><paramtype><classname>boost::process::v2::environment::value_view</classname></paramtype></parameter></method>
</method-group>
</struct-specialization><class-specialization name="tuple_element"><template>
    </template><specialization><template-arg>0u</template-arg><template-arg>boost::process::v2::environment::key_value_pair</template-arg></specialization><typedef name="type"><type><classname>boost::process::v2::environment::key_view</classname></type></typedef>
</class-specialization><class-specialization name="tuple_element"><template>
    </template><specialization><template-arg>0u</template-arg><template-arg>boost::process::v2::environment::key_value_pair_view</template-arg></specialization><typedef name="type"><type><classname>boost::process::v2::environment::key_view</classname></type></typedef>
</class-specialization><class-specialization name="tuple_element"><template>
    </template><specialization><template-arg>1u</template-arg><template-arg>boost::process::v2::environment::key_value_pair</template-arg></specialization><typedef name="type"><type><classname>boost::process::v2::environment::value_view</classname></type></typedef>
</class-specialization><class-specialization name="tuple_element"><template>
    </template><specialization><template-arg>1u</template-arg><template-arg>boost::process::v2::environment::key_value_pair_view</template-arg></specialization><typedef name="type"><type><classname>boost::process::v2::environment::value_view</classname></type></typedef>
</class-specialization><class-specialization name="tuple_size"><template>
    </template><specialization><template-arg>boost::process::v2::environment::key_value_pair</template-arg></specialization><inherit access="private">integral_constant&lt; std::size_t, 2u &gt;</inherit></class-specialization><class-specialization name="tuple_size"><template>
    </template><specialization><template-arg>boost::process::v2::environment::key_value_pair_view</template-arg></specialization><inherit access="private">integral_constant&lt; std::size_t, 2u &gt;</inherit></class-specialization><function name="get"><type>auto</type><template>
          <template-nontype-parameter name="Idx"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="kvp"><paramtype>const <classname>boost::process::v2::environment::key_value_pair</classname> &amp;</paramtype></parameter></function>
<function name="get"><type>auto</type><template>
          <template-nontype-parameter name="Idx"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="kvp"><paramtype><classname>boost::process::v2::environment::key_value_pair_view</classname></paramtype></parameter></function>
</namespace>
</header>
<header name="boost/process/v2/error.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<namespace name="error">
<enum name="utf8_conv_error"><enumvalue name="insufficient_buffer"><default>= 1</default></enumvalue><enumvalue name="invalid_character"/><purpose>Errors used for utf8 &lt;-&gt; UCS-2 conversions. </purpose></enum>
<data-member name="utf8_category" specifiers="static"><type>const error_category &amp;</type></data-member>
<data-member name="exit_code_category" specifiers="static"><type>const error_category &amp;</type><purpose>An error category that can be used to interpret exit codes of subprocesses. </purpose><description><para>Currently not used by boost.process, but it might be in the future.</para><para>void run_my_process(filesystem::path pt, error_code &amp; ec) { process proc(pt, {}); proc.wait(); ec.assign(proc.native_exit_code(), error::get_exit_code_category()); } </para></description></data-member>
<function name="get_utf8_category"><type>const error_category &amp;</type></function>
<function name="get_exit_code_category"><type>const error_category &amp;</type></function>
</namespace>


















</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/execute.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">











<overloaded-function name="execute"><signature><type>int</type><template>
          <template-type-parameter name="Executor"><purpose><para>The asio executor of the process handle </para></purpose></template-type-parameter>
        </template><parameter name="proc"><paramtype><classname>basic_process</classname>&lt; Executor &gt;</paramtype><description><para>The process to be run. </para></description></parameter></signature><signature><type>int</type><template>
          <template-type-parameter name="Executor"/>
        </template><parameter name="proc"><paramtype><classname>basic_process</classname>&lt; Executor &gt;</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter></signature><purpose>Run a process and wait for it to complete. </purpose><description><para>



</para></description><returns><para>int The exit code of the process </para>
</returns><throws><simpara><classname>system_error</classname> An error that might have occurred during the wait. </simpara></throws></overloaded-function>

<function name="async_execute"><type/><template>
          <template-type-parameter name="Executor"><default>boost::asio::any_io_executor</default></template-type-parameter>
          <template-nontype-parameter name="DEFAULT_TYPE"><type>Token WaitHandler</type></template-nontype-parameter>
        </template><parameter name="proc"><paramtype><classname>basic_process</classname>&lt; Executor &gt;</paramtype></parameter><parameter name="DEFAULT"><paramtype>WaitHandler &amp;&amp;handler </paramtype></parameter><purpose>Execute a process asynchronously. </purpose><description><para>This function asynchronously for a process to complete.</para><para>Cancelling the execution will signal the child process to exit with the following interpretations:</para><para><itemizedlist>
<listitem><para>cancellation_type::total -&gt; interrupt</para>
</listitem><listitem><para>cancellation_type::partial -&gt; request_exit</para>
</listitem><listitem><para>cancellation_type::terminal -&gt; terminate</para>
</listitem></itemizedlist>
</para><para>It is to note that <computeroutput>async_execute</computeroutput> will us the lowest selected cancellation type. A subprocess might ignore anything not terminal. </para></description></function>




</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/exit_code.hpp">
<namespace name="boost">
<namespace name="asio">
<struct-specialization name="associator"><template>
      <template-nontype-parameter name="Associator"><type>template&lt; typename, typename &gt; class</type></template-nontype-parameter>
      <template-type-parameter name="Handler"/>
      <template-type-parameter name="DefaultCandidate"/>
    </template><specialization><template-arg>Associator</template-arg><template-arg>boost::process::v2::detail::code_as_error_handler&lt; Handler &gt;</template-arg><template-arg>DefaultCandidate</template-arg></specialization><inherit access="public">Associator&lt; Handler, DefaultCandidate &gt;</inherit><method-group name="public static functions">
<method name="get" cv="noexcept" specifiers="static"><type>Associator&lt; Handler, DefaultCandidate &gt;::type</type><parameter name="h"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="c"><paramtype>const DefaultCandidate &amp;</paramtype><default>DefaultCandidate()</default></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="async_result"><template>
      <template-type-parameter name="CompletionToken"/>
    </template><specialization><template-arg>boost::process::v2::code_as_error_t&lt; CompletionToken &gt;</template-arg><template-arg>void(boost::process::v2::error_code</template-arg><template-arg>boost::process::v2::native_exit_code_type)</template-arg></specialization><struct name="init_wrapper"><template>
      <template-type-parameter name="Initiation"/>
    </template><data-member name="initiation_"><type>Initiation</type></data-member>
<method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Handler"/>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="handler"><paramtype>Handler &amp;&amp;</paramtype></parameter><parameter name="cat"><paramtype>const boost::process::v2::error_category &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter></method>
</method-group>
<constructor><parameter name="init"><paramtype>Initiation</paramtype></parameter></constructor>
</struct><typedef name="signature"><type>void(boost::process::v2::error_code)</type></typedef>
<typedef name="return_type"><type>typename async_result&lt; CompletionToken, void(boost::process::v2::error_code)&gt;::return_type</type></typedef>
<data-member name="token"><type>RawCompletionToken &amp;&amp;</type></data-member>
<data-member name="args"><type>RawCompletionToken Args &amp;&amp;</type></data-member>
<method-group name="public static functions">
<method name="BOOST_PROCESS_V2_INITFN_DEDUCED_RESULT_TYPE" specifiers="static"><type>static</type><template>
          <template-type-parameter name="Initiation"/>
          <template-type-parameter name="RawCompletionToken"/>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>CompletionToken</paramtype></parameter><parameter name=""><paramtype>signature</paramtype></parameter><parameter name=""><paramtype>(async_initiate&lt; CompletionToken, signature &gt;(declval&lt; init_wrapper&lt; typename decay&lt; Initiation &gt;::type &gt; &gt;(), declval&lt; CompletionToken &amp; &gt;(), declval&lt; BOOST_ASIO_MOVE_ARG(Args)&gt;()...))</paramtype></parameter></method>
</method-group>
</struct-specialization></namespace>
<namespace name="process">
<namespace name="v2">
<struct name="code_as_error_t"><template>
      <template-type-parameter name="CompletionToken"/>
    </template><description><para>Convert the exit-code in a completion into an error if the actual error isn't set. <programlisting language="c++">process proc{ctx, "exit", {"1"}};

proc.async_wait(code_as_error(
   [](error_code ec)
   {
     assert(ec.value() == 10);
     assert(ec.category() == error::get_exit_code_category());
   }));
</programlisting> </para></description><data-member name="token_"><type>CompletionToken</type></data-member>
<data-member name="category"><type>const error_category &amp;</type></data-member>
<method-group name="public member functions">
</method-group>
<constructor><template>
          <template-type-parameter name="Token_"/>
        </template><parameter name="token"><paramtype>Token_ &amp;&amp;</paramtype></parameter><parameter name="category"><paramtype>const error_category &amp;</paramtype></parameter></constructor>
</struct><typedef name="native_exit_code_type"><purpose>The native exit-code type, usually an integral value. </purpose><description><para>The OS may have a value different from <computeroutput>int</computeroutput> to represent the exit codes of subprocesses. It might also contain additional information. </para></description><type>implementation_defined</type></typedef>








<function name="process_is_running"><type>bool</type><parameter name="code"><paramtype>native_exit_code_type</paramtype></parameter><purpose>Check if the native exit code indicates the process is still running. </purpose></function>
<function name="evaluate_exit_code"><type>int</type><parameter name="code"><paramtype>native_exit_code_type</paramtype></parameter><purpose>Obtain the portable part of the exit code, i.e. what the subprocess has returned from main. </purpose></function>
<function name="code_as_error"><type><classname>code_as_error_t</classname>&lt; CompletionToken &gt;</type><template>
          <template-type-parameter name="CompletionToken"/>
        </template><parameter name="token"><paramtype>CompletionToken &amp;&amp;</paramtype></parameter><parameter name="category"><paramtype>const error_category &amp;</paramtype><default>error::get_exit_code_category()</default></parameter><purpose>Deduction function for <classname alt="boost::process::v2::code_as_error_t">code_as_error_t</classname>. </purpose></function>







</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/ext.hpp">
</header>
<header name="boost/process/v2/pid.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<typedef name="pid_type"><type>implementation_defined</type></typedef>

<function name="current_pid"><type>pid_type</type><purpose>Get the process id of the current process. </purpose></function>
<function name="all_pids"><type>std::vector&lt; pid_type &gt;</type><parameter name="ec"><paramtype>boost::system::error_code &amp;</paramtype></parameter><purpose>List all available pids. </purpose></function>
<function name="all_pids"><type>std::vector&lt; pid_type &gt;</type><purpose>List all available pids. </purpose></function>
<function name="parent_pid"><type>pid_type</type><parameter name="pid"><paramtype>pid_type</paramtype></parameter><parameter name="ec"><paramtype>boost::system::error_code &amp;</paramtype></parameter></function>
<function name="parent_pid"><type>pid_type</type><parameter name="pid"><paramtype>pid_type</paramtype></parameter></function>
<function name="child_pids"><type>std::vector&lt; pid_type &gt;</type><parameter name="pid"><paramtype>pid_type</paramtype></parameter><parameter name="ec"><paramtype>boost::system::error_code &amp;</paramtype></parameter></function>
<function name="child_pids"><type>std::vector&lt; pid_type &gt;</type><parameter name="pid"><paramtype>pid_type</paramtype></parameter></function>










</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/popen.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<struct name="basic_popen"><template>
      <template-type-parameter name="Executor"><default>boost::asio::any_io_executor</default></template-type-parameter>
    </template><inherit access="public">boost::process::v2::basic_process&lt; Executor &gt;</inherit><purpose>A subprocess with automatically assigned pipes. </purpose><description><para>The purpose os the popen is to provide a convenient way to use the stdin &amp; stdout of a process.</para><para><programlisting language="c++">popen proc(executor, find_executable("addr2line"), {argv[0]});
asio::write(proc, asio::buffer("main\n"));
std::string line;
asio::read_until(proc, asio::dynamic_buffer(line), '\n');
</programlisting></para><para>Popen can be used as a stream object in other protocols. </para></description><struct name="rebind_executor"><template>
      <template-type-parameter name="Executor1"/>
    </template><purpose>Rebinds the popen type to another executor. </purpose><typedef name="other"><purpose>The pipe type when rebound to the specified executor. </purpose><type><classname>basic_popen</classname>&lt; Executor1 &gt;</type></typedef>
</struct><typedef name="executor_type"><purpose>The executor of the process. </purpose><type>Executor</type></typedef>
<typedef name="stdin_type"><purpose>The type used for stdin on the parent process side. </purpose><type>boost::asio::basic_writable_pipe&lt; Executor &gt;</type></typedef>
<typedef name="stdout_type"><purpose>The type used for stdout on the parent process side. </purpose><type>boost::asio::basic_readable_pipe&lt; Executor &gt;</type></typedef>
<method-group name="public member functions">
<method name="get_stdin"><type>stdin_type &amp;</type><purpose>Get the stdin pipe. </purpose></method>
<method name="get_stdout"><type>stdout_type &amp;</type><purpose>Get the stdout pipe. </purpose></method>
<method name="get_stdin" cv="const"><type>const stdin_type &amp;</type><purpose>Get the stdin pipe. </purpose></method>
<method name="get_stdout" cv="const"><type>const stdout_type &amp;</type><purpose>Get the stdout pipe. </purpose></method>
<method name="write_some"><type>std::size_t</type><template>
          <template-type-parameter name="ConstBufferSequence"/>
        </template><parameter name="buffers"><paramtype>const ConstBufferSequence &amp;</paramtype><description><para>One or more data buffers to be written to the pipe.</para></description></parameter><purpose>Write some data to the pipe. </purpose><description><para>This function is used to write data to the pipe. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</para><para>


<note><para>The write_some operation may not transmit all of the data to the peer. Consider using the write function if you need to ensure that all data is written before the blocking operation completes.</para>
</note>
<formalpara><title>Example</title><para>To write a single data buffer use the buffer function as follows: <programlisting language="c++">pipe.write_some(boost::asio::buffer(data, size));
</programlisting> See the buffer documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </para>
</formalpara>
</para></description><returns><para>The number of bytes written.</para>
</returns><throws><simpara><classname>boost::system::system_error</classname> Thrown on failure. An error code of boost::asio::error::eof indicates that the connection was closed by the subprocess.</simpara></throws></method>
<method name="write_some"><type>std::size_t</type><template>
          <template-type-parameter name="ConstBufferSequence"/>
        </template><parameter name="buffers"><paramtype>const ConstBufferSequence &amp;</paramtype><description><para>One or more data buffers to be written to the pipe.</para></description></parameter><parameter name="ec"><paramtype>boost::system::error_code &amp;</paramtype><description><para>Set to indicate what error occurred, if any.</para></description></parameter><purpose>Write some data to the pipe. </purpose><description><para>This function is used to write data to the pipe. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</para><para>

<note><para>The write_some operation may not transmit all of the data to the subprocess. Consider using the write function if you need to ensure that all data is written before the blocking operation completes. </para>
</note>
</para></description><returns><para>The number of bytes written. Returns 0 if an error occurred.</para>
</returns></method>
<method name="BOOST_PROCESS_V2_INITFN_AUTO_RESULT_TYPE" cv="const"><type/><template>
          <template-type-parameter name="ConstBufferSequence"/>
          <template-nontype-parameter name=""><type>BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) WriteToken BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type)</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>WriteToken</paramtype></parameter><parameter name=""><paramtype>void(boost::system::error_code, std::size_t)</paramtype></parameter><purpose>Start an asynchronous write. </purpose><description><para>This function is used to asynchronously write data to the pipe. It is an initiating function for an asynchronous_operation, and always returns immediately.</para><para>
<formalpara><title>Completion Signature</title><para><programlisting language="c++">void(boost::system::error_code, std::size_t) 
</programlisting></para>
</formalpara>
<note><para>The write operation may not transmit all of the data to the peer. Consider using the async_write function if you need to ensure that all data is written before the asynchronous operation completes.</para>
</note>
<formalpara><title>Example</title><para>To write a single data buffer use the buffer function as follows: <programlisting language="c++">popen.async_write_some(boost::asio::buffer(data, size), handler);
</programlisting> See the buffer documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </para>
</formalpara>
</para></description></method>
<method name="BOOST_ASIO_MOVE_ARG"><type/><parameter name=""><paramtype>WriteToken</paramtype></parameter></method>
<method name="read_some"><type>std::size_t</type><template>
          <template-type-parameter name="MutableBufferSequence"/>
        </template><parameter name="buffers"><paramtype>const MutableBufferSequence &amp;</paramtype><description><para>One or more buffers into which the data will be read.</para></description></parameter><purpose>Read some data from the pipe. </purpose><description><para>This function is used to read data from the pipe. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</para><para>


<note><para>The read_some operation may not read all of the requested number of bytes. Consider using the read function if you need to ensure that the requested amount of data is read before the blocking operation completes.</para>
</note>
<formalpara><title>Example</title><para>To read into a single data buffer use the buffer function as follows: <programlisting language="c++">basic_readable_pipe.read_some(boost::asio::buffer(data, size));
</programlisting> See the buffer documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </para>
</formalpara>
</para></description><returns><para>The number of bytes read.</para>
</returns><throws><simpara><classname>boost::system::system_error</classname> Thrown on failure. An error code of boost::asio::error::eof indicates that the connection was closed by the peer.</simpara></throws></method>
<method name="read_some"><type>std::size_t</type><template>
          <template-type-parameter name="MutableBufferSequence"/>
        </template><parameter name="buffers"><paramtype>const MutableBufferSequence &amp;</paramtype><description><para>One or more buffers into which the data will be read.</para></description></parameter><parameter name="ec"><paramtype>boost::system::error_code &amp;</paramtype><description><para>Set to indicate what error occurred, if any.</para></description></parameter><purpose>Read some data from the pipe. </purpose><description><para>This function is used to read data from the pipe. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</para><para>

<note><para>The read_some operation may not read all of the requested number of bytes. Consider using the read function if you need to ensure that the requested amount of data is read before the blocking operation completes. </para>
</note>
</para></description><returns><para>The number of bytes read. Returns 0 if an error occurred.</para>
</returns></method>
<method name="BOOST_PROCESS_V2_INITFN_AUTO_RESULT_TYPE" cv="const"><type/><template>
          <template-type-parameter name="MutableBufferSequence"/>
          <template-nontype-parameter name=""><type>BOOST_ASIO_COMPLETION_TOKEN_FOR(void(boost::system::error_code, std::size_t)) ReadToken BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type)</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>ReadToken</paramtype></parameter><parameter name=""><paramtype>void(boost::system::error_code, std::size_t)</paramtype></parameter><purpose>Start an asynchronous read. </purpose><description><para>This function is used to asynchronously read data from the pipe. It is an initiating function for an asynchronous_operation, and always returns immediately.</para><para>
<formalpara><title>Completion Signature</title><para><programlisting language="c++">void(boost::system::error_code, std::size_t) 
</programlisting></para>
</formalpara>
<note><para>The read operation may not read all of the requested number of bytes. Consider using the async_read function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.</para>
</note>
<formalpara><title>Example</title><para>To read into a single data buffer use the buffer function as follows: <programlisting language="c++">basic_readable_pipe.async_read_some(
    boost::asio::buffer(data, size), handler);
</programlisting> See the buffer documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </para>
</formalpara>
</para></description></method>
<method name="BOOST_ASIO_MOVE_ARG"><type/><parameter name=""><paramtype>ReadToken</paramtype></parameter></method>
</method-group>
<constructor cv="= default"><parameter name=""><paramtype><classname>basic_popen</classname> &amp;&amp;</paramtype></parameter><purpose>Move construct a popen. </purpose></constructor>
<copy-assignment cv="= default"><type><classname>basic_popen</classname> &amp;</type><parameter name=""><paramtype><classname>basic_popen</classname> &amp;&amp;</paramtype></parameter><purpose>Move assign a popen. </purpose></copy-assignment>
<constructor><template>
          <template-type-parameter name="Executor1"/>
        </template><parameter name="lhs"><paramtype><classname>basic_popen</classname>&lt; Executor1 &gt; &amp;&amp;</paramtype></parameter><purpose>Move construct a popen and change the executor type. </purpose></constructor>
<constructor specifiers="explicit"><parameter name="exec"><paramtype>executor_type</paramtype></parameter><purpose>Create a closed process handle. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="ExecutionContext"/>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, void * &gt;::type</paramtype><default>nullptr</default></parameter><purpose>Create a closed process handle. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="exe"><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name="args"><paramtype>std::initializer_list&lt; string_view &gt;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Launcher"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="launcher"><paramtype>Launcher &amp;&amp;</paramtype></parameter><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="exe"><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name="args"><paramtype>std::initializer_list&lt; string_view &gt;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="exe"><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name="args"><paramtype>std::initializer_list&lt; wstring_view &gt;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Launcher"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="launcher"><paramtype>Launcher &amp;&amp;</paramtype></parameter><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="exe"><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name="args"><paramtype>std::initializer_list&lt; wstring_view &gt;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="exe"><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Launcher"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="launcher"><paramtype>Launcher &amp;&amp;</paramtype></parameter><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="exe"><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="ExecutionContext"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="exe"><paramtype>typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, const filesystem::path &amp; &gt;::type</paramtype></parameter><parameter name="args"><paramtype>std::initializer_list&lt; string_view &gt;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Launcher"/>
          <template-type-parameter name="ExecutionContext"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="launcher"><paramtype>Launcher &amp;&amp;</paramtype></parameter><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="exe"><paramtype>typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, const filesystem::path &amp; &gt;::type</paramtype></parameter><parameter name="args"><paramtype>std::initializer_list&lt; string_view &gt;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="ExecutionContext"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="exe"><paramtype>typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, const filesystem::path &amp; &gt;::type</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Launcher"/>
          <template-type-parameter name="ExecutionContext"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="launcher"><paramtype>Launcher &amp;&amp;</paramtype></parameter><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="exe"><paramtype>typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, const filesystem::path &amp; &gt;::type</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default process launcher. </purpose></constructor>
</struct><typedef name="popen"><purpose>A popen object with the default executor. </purpose><type><classname>basic_popen</classname>&lt;&gt;</type></typedef>


















</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/process.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<struct name="basic_process"><template>
      <template-type-parameter name="Executor"><default>boost::asio::any_io_executor</default></template-type-parameter>
    </template><purpose>A class managing a subprocess. </purpose><struct name="async_wait_op_"><data-member name="handle"><type><classname>basic_process_handle</classname>&lt; Executor &gt; &amp;</type></data-member>
<data-member name="res"><type>native_exit_code_type &amp;</type></data-member>
<method-group name="public member functions">
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Self"/>
        </template><parameter name="self"><paramtype>Self &amp;&amp;</paramtype></parameter></method>
<method name="operator()"><type>void</type><template>
          <template-type-parameter name="Self"/>
        </template><parameter name="self"><paramtype>Self &amp;&amp;</paramtype></parameter><parameter name="ec"><paramtype>error_code</paramtype></parameter><parameter name="code"><paramtype>native_exit_code_type</paramtype></parameter></method>
</method-group>
</struct><struct name="rebind_executor"><template>
      <template-type-parameter name="Executor1"/>
    </template><purpose>Rebinds the process_handle to another executor. </purpose><typedef name="other"><purpose>The socket type when rebound to the specified executor. </purpose><type><classname>basic_process</classname>&lt; Executor1 &gt;</type></typedef>
</struct><typedef name="executor_type"><purpose>The executor of the process. </purpose><type>Executor</type></typedef>
<typedef name="handle_type"><purpose>The non-closing handle type. </purpose><type><classname>basic_process_handle</classname>&lt; executor_type &gt;</type></typedef>
<typedef name="native_handle_type"><purpose>Provides access to underlying operating system facilities. </purpose><type>typename handle_type::native_handle_type</type></typedef>
<method-group name="public member functions">
<method name="get_executor"><type>executor_type</type><purpose>Get the executor of the process. </purpose></method>
<method name="handle"><type>handle_type &amp;</type><purpose>Get the underlying non-closing handle. </purpose></method>
<method name="handle" cv="const"><type>const handle_type &amp;</type><purpose>Get the underlying non-closing handle. </purpose></method>
<method name="interrupt"><type>void</type><purpose>Sends the process a signal to ask for an interrupt, which the process may interpret as a shutdown. </purpose><description><para>Maybe be ignored by the subprocess. </para></description></method>
<method name="interrupt"><type>void</type><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="request_exit"><type>void</type><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="request_exit"><type>void</type><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Sends the process a signal to ask for a graceful shutdown. Maybe be ignored by the subprocess. </purpose></method>
<method name="suspend"><type>void</type><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Send the process a signal requesting it to stop. This may rely on undocumented functions. </purpose></method>
<method name="suspend"><type>void</type><purpose>Send the process a signal requesting it to stop. This may rely on undocumented functions. </purpose></method>
<method name="resume"><type>void</type><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Send the process a signal requesting it to resume. This may rely on undocumented functions. </purpose></method>
<method name="resume"><type>void</type><purpose>Send the process a signal requesting it to resume. This may rely on undocumented functions. </purpose></method>
<method name="terminate"><type>void</type><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="terminate"><type>void</type><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Unconditionally terminates the process and stores the exit code in exit_status. </purpose></method>
<method name="wait"><type>int</type><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="wait"><type>int</type><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Waits for the process to exit, store the exit code internally and return it. </purpose></method>
<method name="detach"><type>handle_type</type><purpose>Detach the process. </purpose></method>
<method name="native_handle"><type>native_handle_type</type></method>
<method name="exit_code" cv="const"><type>int</type></method>
<method name="id" cv="const"><type>pid_type</type><purpose>Get the id of the process;. </purpose></method>
<method name="native_exit_code" cv="const"><type>native_exit_code_type</type><purpose>The native handle of the process. </purpose><description><para>This might be undefined on posix systems that only support signals </para></description></method>
<method name="running"><type>bool</type><purpose>Checks if the current process is running. </purpose><description><para>If it has already completed the exit code will be stored internally and can be obtained by calling `exit_code. </para></description></method>
<method name="running" cv="noexcept"><type>bool</type><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="is_open" cv="const"><type>bool</type><purpose>Check if the process is referring to an existing process. </purpose><description><para>Note that this might be a process that already exited. </para></description></method>
<method name="async_wait"><type/><template>
          <template-nontype-parameter name="DEFAULT_TYPE"><type>Token WaitHandler</type></template-nontype-parameter>
        </template><parameter name="DEFAULT"><paramtype>WaitHandler &amp;&amp;handler </paramtype></parameter><purpose>Asynchronously wait for the process to exit and deliver the portable exit-code in the completion handler. </purpose></method>
</method-group>
<constructor cv="= default"><description><para>An empty process is similar to a default constructed thread. It holds an empty handle and is a place holder for a process that is to be launched later. </para></description></constructor>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>basic_process</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= delete"><type><classname>basic_process</classname> &amp;</type><parameter name=""><paramtype>const <classname>basic_process</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor cv="= default"><parameter name="lhs"><paramtype><classname>basic_process</classname> &amp;&amp;</paramtype></parameter><purpose>Move construct the process. It will be detached from <computeroutput>lhs</computeroutput>. </purpose></constructor>
<copy-assignment cv="= default"><type><classname>basic_process</classname> &amp;</type><parameter name="lhs"><paramtype><classname>basic_process</classname> &amp;&amp;</paramtype></parameter><purpose>Move assign a process. It will be detached from <computeroutput>lhs</computeroutput>. </purpose></copy-assignment>
<constructor><template>
          <template-type-parameter name="Executor1"/>
        </template><parameter name="lhs"><paramtype><classname>basic_process</classname>&lt; Executor1 &gt; &amp;&amp;</paramtype></parameter><purpose>Move construct and rebind the executor. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="exe"><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name="args"><paramtype>std::initializer_list&lt; string_view &gt;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default launcher.. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="exe"><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name="args"><paramtype>std::initializer_list&lt; wstring_view &gt;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default launcher.. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="exe"><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default launcher.. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="ExecutionContext"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="exe"><paramtype>typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, const filesystem::path &amp; &gt;::type</paramtype></parameter><parameter name="args"><paramtype>std::initializer_list&lt; string_view &gt;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default launcher.. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="ExecutionContext"/>
          <template-type-parameter name="Args"/>
          <template-nontype-parameter name="Inits"><type>typename ...</type></template-nontype-parameter>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="exe"><paramtype>typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, const filesystem::path &amp; &gt;::type</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;</paramtype></parameter><parameter name="inits"><paramtype>Inits &amp;&amp;...</paramtype></parameter><purpose>Construct a child from a property list and launch it using the default launcher. </purpose></constructor>
<constructor specifiers="explicit"><parameter name="exec"><paramtype>executor_type</paramtype></parameter><parameter name="pid"><paramtype>pid_type</paramtype></parameter><purpose>Attach to an existing process. </purpose></constructor>
<constructor specifiers="explicit"><parameter name="exec"><paramtype>executor_type</paramtype></parameter><parameter name="pid"><paramtype>pid_type</paramtype></parameter><parameter name="native_handle"><paramtype>native_handle_type</paramtype></parameter><purpose>Attach to an existing process and the internal handle. </purpose></constructor>
<constructor specifiers="explicit"><parameter name="exec"><paramtype>executor_type</paramtype></parameter><purpose>Create an invalid handle. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="ExecutionContext"/>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="pid"><paramtype>pid_type</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, void * &gt;::type</paramtype><default>nullptr</default></parameter><purpose>Attach to an existing process. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="ExecutionContext"/>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name="pid"><paramtype>pid_type</paramtype></parameter><parameter name="native_handle"><paramtype>native_handle_type</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; std::is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, void * &gt;::type</paramtype><default>nullptr</default></parameter><purpose>Attach to an existing process and the internal handle. </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="ExecutionContext"/>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><parameter name=""><paramtype>typename std::enable_if&lt; is_convertible&lt; ExecutionContext &amp;, boost::asio::execution_context &amp; &gt;::value, void * &gt;::type</paramtype><default>nullptr</default></parameter><purpose>Create an invalid handle. </purpose></constructor>
<destructor><purpose>Destruct the handle and terminate the process if it wasn't detached. </purpose></destructor>
</struct><typedef name="process"><purpose>Process with the default executor. </purpose><type><classname>basic_process</classname></type></typedef>


















</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/process_handle.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<struct name="basic_process_handle"><template>
      <template-type-parameter name="Executor"><default>boost::asio::any_io_executor</default></template-type-parameter>
    </template><description><para>A process handle is an unmanaged version of a process. This means it does not terminate the proces on destruction and will not keep track of the exit-code.</para><para>Note that the exit code might be discovered early, during a call to <computeroutput>running</computeroutput>. Thus it can only be discovered that process has exited already. </para></description><struct name="rebind_executor"><template>
      <template-type-parameter name="Executor1"/>
    </template><purpose>Rebinds the process_handle to another executor. </purpose><typedef name="other"><purpose>The socket type when rebound to the specified executor. </purpose><type><classname>basic_process_handle</classname>&lt; Executor1 &gt;</type></typedef>
</struct><typedef name="native_handle_type"><purpose>The native handle of the process. </purpose><description><para>This might be undefined on posix systems that only support signals </para></description><type>implementation_defined</type></typedef>
<typedef name="executor_type"><purpose>The executor_type of the process_handle. </purpose><type>Executor</type></typedef>
<data-member name="ec"><type>void error_code &amp;</type></data-member>
<method-group name="public member functions">
<method name="get_executor"><type>executor_type</type><purpose>Getter for the executor. </purpose></method>
<method name="id" cv="const"><type>pid_type</type><purpose>Get the id of the process. </purpose></method>
<method name="terminate_if_running"><type>void</type><parameter name=""><paramtype>error_code &amp;</paramtype></parameter><purpose>Terminate the process if it's still running and ignore the result. </purpose></method>
<method name="terminate_if_running"><type>void</type><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="wait"><type>void</type><parameter name="exit_status"><paramtype>native_exit_code_type &amp;</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>wait for the process to exit and store the exit code in exit_status. </purpose></method>
<method name="wait"><type>void</type><parameter name="exit_status"><paramtype>native_exit_code_type &amp;</paramtype></parameter><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="interrupt"><type>void</type><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Sends the process a signal to ask for an interrupt, which the process may interpret as a shutdown. </purpose><description><para>Maybe be ignored by the subprocess. </para></description></method>
<method name="interrupt"><type>void</type><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="request_exit"><type>void</type><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Sends the process a signal to ask for a graceful shutdown. Maybe be ignored by the subprocess. </purpose></method>
<method name="request_exit"><type>void</type><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.Unconditionally terminates the process and stores the exit code in exit_status. </para></description></method>
<method name="terminate"><type>void</type><parameter name="exit_status"><paramtype>native_exit_code_type &amp;</paramtype></parameter><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="running"><type>bool</type><parameter name="exit_code"><paramtype>native_exit_code_type &amp;</paramtype></parameter><parameter name="ec"><paramtype>error_code &amp;</paramtype></parameter><purpose>Checks if the current process is running. </purpose><description><para>If it has already completed, it assigns the exit code to <computeroutput>exit_code</computeroutput>. </para></description></method>
<method name="running"><type>bool</type><parameter name="exit_code"><paramtype>native_exit_code_type &amp;</paramtype></parameter><purpose>Throwing. </purpose><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="is_open" cv="const"><type>bool</type><purpose>Check if the process handle is referring to an existing process. </purpose></method>
<method name="async_wait"><type/><template>
          <template-nontype-parameter name="DEFAULT_TYPE"><type>Token WaitHandler</type></template-nontype-parameter>
        </template><parameter name="DEFAULT"><paramtype>WaitHandler &amp;&amp;handler </paramtype></parameter><purpose>Asynchronously wait for the process to exit and deliver the native exit-code in the completion handler. </purpose></method>
</method-group>
<constructor><template>
          <template-type-parameter name="ExecutionContext"><purpose><para>The context must fulfill the asio::execution_context requirements </para></purpose></template-type-parameter>
        </template><parameter name="context"><paramtype>ExecutionContext &amp;</paramtype></parameter><purpose>Construct a <classname alt="boost::process::v2::basic_process_handle">basic_process_handle</classname> from an execution_context. </purpose><description><para>
</para></description></constructor>
<constructor><parameter name="executor"><paramtype>executor_type</paramtype></parameter><purpose>Construct an empty process_handle from an executor. </purpose></constructor>
<constructor><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="pid"><paramtype>pid_type</paramtype></parameter><purpose>Construct an empty process_handle from an executor and bind it to a pid. </purpose><description><para>On NON-linux posix systems this call is not able to obtain a file-descriptor and will thus rely on signals. </para></description></constructor>
<constructor><parameter name="executor"><paramtype>executor_type</paramtype></parameter><parameter name="pid"><paramtype>pid_type</paramtype></parameter><parameter name="process_handle"><paramtype>native_handle_type</paramtype></parameter><purpose>Construct an empty process_handle from an executor and bind it to a pid and the native-handle. </purpose><description><para>On some non-linux posix systems this overload is not present. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Executor1"/>
        </template><parameter name="handle"><paramtype><classname>basic_process_handle</classname>&lt; Executor1 &gt; &amp;&amp;</paramtype></parameter><purpose>Move construct and rebind the executor. </purpose></constructor>
</struct>

















</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/shell.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<struct name="shell"><purpose>Utility to parse commands. </purpose><description><para>This utility class parses command lines into tokens and allows users to executed based on textual inputs.</para><para>In v1, this was possible directly when starting a process, but has been removed based on the security risks associated with this.</para><para>By making the shell parsing explicitly, it encourages a user to run a sanity check on the executable before launching it.</para><para><formalpara><title>Example</title><para><programlisting language="c++">asio::io_context ctx;

auto cmd = shell("my-app --help");
auto exe = cmd.exe();
check_if_malicious(exe);

process proc{ctx, exe, cmd.args()};
</programlisting> </para>
</formalpara>
</para></description><typedef name="char_type"><type>char</type></typedef>
<typedef name="args_type"><type>const char **</type></typedef>
<method-group name="public member functions">
<method name="argc" cv="const"><type>int</type></method>
<method name="argv" cv="const"><type>char_type **</type></method>
<method name="begin" cv="const"><type>char_type **</type></method>
<method name="end" cv="const"><type>char_type **</type></method>
<method name="empty" cv="const"><type>bool</type></method>
<method name="size" cv="const"><type>std::size_t</type></method>
<method name="args" cv="const"><type>args_type</type><purpose>Native representation of the arguments to be used - excluding the executable. </purpose></method>
<method name="exe" cv="const"><type>filesystem::path</type><template>
          <template-type-parameter name="Environment"><default><classname alt="boost::process::v2::environment::current_view">environment::current_view</classname></default></template-type-parameter>
        </template><parameter name="env"><paramtype>Environment &amp;&amp;</paramtype><default>environment::current()</default></parameter></method>
</method-group>
<constructor cv="= default"/>
<constructor><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
        </template><parameter name="input"><paramtype>basic_string_view&lt; Char, Traits &gt;</paramtype></parameter></constructor>
<constructor><parameter name="input"><paramtype><classname>basic_cstring_ref</classname>&lt; char_type &gt;</paramtype></parameter></constructor>
<constructor><parameter name="input"><paramtype>basic_string_view&lt; typename std::conditional&lt; std::is_same&lt; char_type, char &gt;::value, wchar_t, char &gt;::type &gt;</paramtype></parameter></constructor>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>shell</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= delete"><type><classname>shell</classname> &amp;</type><parameter name=""><paramtype>const <classname>shell</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor cv="noexcept"><parameter name="lhs"><paramtype><classname>shell</classname> &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment cv="noexcept"><type><classname>shell</classname> &amp;</type><parameter name="lhs"><paramtype><classname>shell</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<destructor/>
<method-group name="private member functions">
<method name="parse_"><type>void</type></method>
</method-group>
</struct><data-member name="shell_category" specifiers="static"><type>const error_category &amp;</type></data-member>
<function name="get_shell_category"><type>const error_category &amp;</type><purpose>Error category used by the shell parser. </purpose></function>

















</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/src.hpp">
<macro name="BOOST_PROCESS_V2_SOURCE"/>
</header>
<header name="boost/process/v2/start_dir.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<struct name="process_start_dir"><purpose>Initializer for the starting directory of a subprocess to be launched. </purpose><data-member name="start_dir"><type>filesystem::path</type></data-member>
<method-group name="public member functions">
<method name="on_exec_setup"><type>error_code</type><parameter name="launcher"><paramtype>posix::default_launcher &amp;</paramtype></parameter><parameter name=""><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name=""><paramtype>const char *const *</paramtype></parameter></method>
</method-group>
<constructor><parameter name="start_dir"><paramtype>filesystem::path</paramtype></parameter></constructor>
</struct>

















</namespace>
</namespace>
</namespace>
</header>
<header name="boost/process/v2/stdio.hpp">
<namespace name="boost">
<namespace name="process">
<namespace name="v2">
<struct name="process_stdio"><purpose>The initializer for the stdio of a subprocess. </purpose><description><para>The subprocess initializer has three members:</para><para><itemizedlist>
<listitem><para>in for stdin</para>
</listitem><listitem><para>out for stdout</para>
</listitem><listitem><para>err for stderr</para>
</listitem></itemizedlist>
</para><para>If the initializer is present all three will be set for the subprocess. By default they will inherit the stdio handles from the parent process. This means that this will forward stdio to the subprocess:</para><para><programlisting language="c++">asio::io_context ctx;
v2::process proc(ctx, "/bin/bash", {}, v2::process_stdio{});
</programlisting></para><para>No constructors are provided in order to support designated initializers in later version of C++.</para><para><itemizedlist>
<listitem><para><programlisting language="c++">asio::io_context ctx;
v2::process proc17(ctx, "/bin/bash", {}, v2::process_stdio{.stderr=nullptr});
v2::process proc17(ctx, "/bin/bash", {}, v2::process_stdio{ {}, {}, nullptr});
                                                       stdin ^  ^ stderr
</programlisting></para>
</listitem></itemizedlist>
</para><para>Valid initializers for any stdio are:</para><para><itemizedlist>
<listitem><para><computeroutput>std::nullptr_t</computeroutput> assigning a null-device</para>
</listitem><listitem><para><computeroutput>FILE*</computeroutput> any open file, including <computeroutput>stdin</computeroutput>, <computeroutput>stdout</computeroutput> and <computeroutput>stderr</computeroutput></para>
</listitem><listitem><para>a filesystem::path, which will open a readable or writable depending on the direction of the stream</para>
</listitem><listitem><para><computeroutput>native_handle</computeroutput> any native file handle (<computeroutput>HANDLE</computeroutput> on windows) or file descriptor (<computeroutput>int</computeroutput> on posix)</para>
</listitem><listitem><para>any io-object with a .native_handle() function that is compatible with the above. E.g. a asio::ip::tcp::socket</para>
</listitem><listitem><para>an asio::basic_writeable_pipe for stdin or asio::basic_readable_pipe for stderr/stdout. </para>
</listitem></itemizedlist>
</para></description><data-member name="in"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="out"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="err"><type><emphasis>unspecified</emphasis></type></data-member>
<method-group name="public member functions">
<method name="on_exec_setup"><type>error_code</type><parameter name="launcher"><paramtype>posix::default_launcher &amp;</paramtype></parameter><parameter name=""><paramtype>const filesystem::path &amp;</paramtype></parameter><parameter name=""><paramtype>const char *const *</paramtype></parameter></method>
</method-group>
</struct>

















</namespace>
</namespace>
</namespace>
</header>
</library-reference>